/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/reduce-css-calc@2.1.8";
exports.ids = ["vendor-chunks/reduce-css-calc@2.1.8"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/index.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _postcssValueParser = __webpack_require__(/*! postcss-value-parser */ \"(ssr)/./node_modules/.pnpm/postcss-value-parser@3.3.1/node_modules/postcss-value-parser/lib/index.js\");\nvar _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);\nvar _parser = __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/parser.js\");\nvar _reducer = __webpack_require__(/*! ./lib/reducer */ \"(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/reducer.js\");\nvar _reducer2 = _interopRequireDefault(_reducer);\nvar _stringifier = __webpack_require__(/*! ./lib/stringifier */ \"(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/stringifier.js\");\nvar _stringifier2 = _interopRequireDefault(_stringifier);\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// eslint-disable-line\nvar MATCH_CALC = /((?:\\-[a-z]+\\-)?calc)/;\nexports[\"default\"] = function(value) {\n    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n    return (0, _postcssValueParser2.default)(value).walk(function(node) {\n        // skip anything which isn't a calc() function\n        if (node.type !== \"function\" || !MATCH_CALC.test(node.value)) return;\n        // stringify calc expression and produce an AST\n        var contents = _postcssValueParser2.default.stringify(node.nodes);\n        // skip constant() and env()\n        if (contents.indexOf(\"constant\") >= 0 || contents.indexOf(\"env\") >= 0) return;\n        var ast = _parser.parser.parse(contents);\n        // reduce AST to its simplest form, that is, either to a single value\n        // or a simplified calc expression\n        var reducedAst = (0, _reducer2.default)(ast, precision);\n        // stringify AST and write it back\n        node.type = \"word\";\n        node.value = (0, _stringifier2.default)(node.value, reducedAst, precision);\n    }, true).toString();\n};\nmodule.exports = exports[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVkdWNlLWNzcy1jYWxjQDIuMS44L25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFFRixJQUFJQyxzQkFBc0JDLG1CQUFPQSxDQUFDO0FBRWxDLElBQUlDLHVCQUF1QkMsdUJBQXVCSDtBQUVsRCxJQUFJSSxVQUFVSCxtQkFBT0EsQ0FBQztBQUV0QixJQUFJSSxXQUFXSixtQkFBT0EsQ0FBQztBQUV2QixJQUFJSyxZQUFZSCx1QkFBdUJFO0FBRXZDLElBQUlFLGVBQWVOLG1CQUFPQSxDQUFDO0FBRTNCLElBQUlPLGdCQUFnQkwsdUJBQXVCSTtBQUUzQyxTQUFTSix1QkFBdUJNLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRUUsU0FBU0Y7SUFBSTtBQUFHO0FBRTlGLHNCQUFzQjtBQUN0QixJQUFJRyxhQUFhO0FBRWpCZCxrQkFBZSxHQUFHLFNBQVVDLEtBQUs7SUFDL0IsSUFBSWMsWUFBWUMsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFFcEYsT0FBTyxDQUFDLEdBQUdaLHFCQUFxQlMsT0FBTyxFQUFFWixPQUFPa0IsSUFBSSxDQUFDLFNBQVVDLElBQUk7UUFDakUsOENBQThDO1FBQzlDLElBQUlBLEtBQUtDLElBQUksS0FBSyxjQUFjLENBQUNQLFdBQVdRLElBQUksQ0FBQ0YsS0FBS25CLEtBQUssR0FBRztRQUU5RCwrQ0FBK0M7UUFDL0MsSUFBSXNCLFdBQVduQixxQkFBcUJTLE9BQU8sQ0FBQ1csU0FBUyxDQUFDSixLQUFLSyxLQUFLO1FBRWhFLDRCQUE0QjtRQUM1QixJQUFJRixTQUFTRyxPQUFPLENBQUMsZUFBZSxLQUFLSCxTQUFTRyxPQUFPLENBQUMsVUFBVSxHQUFHO1FBRXZFLElBQUlDLE1BQU1yQixRQUFRc0IsTUFBTSxDQUFDQyxLQUFLLENBQUNOO1FBRS9CLHFFQUFxRTtRQUNyRSxrQ0FBa0M7UUFDbEMsSUFBSU8sYUFBYSxDQUFDLEdBQUd0QixVQUFVSyxPQUFPLEVBQUVjLEtBQUtaO1FBRTdDLGtDQUFrQztRQUNsQ0ssS0FBS0MsSUFBSSxHQUFHO1FBQ1pELEtBQUtuQixLQUFLLEdBQUcsQ0FBQyxHQUFHUyxjQUFjRyxPQUFPLEVBQUVPLEtBQUtuQixLQUFLLEVBQUU2QixZQUFZZjtJQUNsRSxHQUFHLE1BQU1nQixRQUFRO0FBQ25CO0FBRUFDLE9BQU9oQyxPQUFPLEdBQUdBLE9BQU8sQ0FBQyxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RyYXRmb3JkX2FpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZHVjZS1jc3MtY2FsY0AyLjEuOC9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL2Rpc3QvaW5kZXguanM/YTgwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcG9zdGNzc1ZhbHVlUGFyc2VyID0gcmVxdWlyZSgncG9zdGNzcy12YWx1ZS1wYXJzZXInKTtcblxudmFyIF9wb3N0Y3NzVmFsdWVQYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zdGNzc1ZhbHVlUGFyc2VyKTtcblxudmFyIF9wYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuXG52YXIgX3JlZHVjZXIgPSByZXF1aXJlKCcuL2xpYi9yZWR1Y2VyJyk7XG5cbnZhciBfcmVkdWNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWR1Y2VyKTtcblxudmFyIF9zdHJpbmdpZmllciA9IHJlcXVpcmUoJy4vbGliL3N0cmluZ2lmaWVyJyk7XG5cbnZhciBfc3RyaW5naWZpZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZpZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lXG52YXIgTUFUQ0hfQ0FMQyA9IC8oKD86XFwtW2Etel0rXFwtKT9jYWxjKS87XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJlY2lzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA1O1xuXG4gIHJldHVybiAoMCwgX3Bvc3Rjc3NWYWx1ZVBhcnNlcjIuZGVmYXVsdCkodmFsdWUpLndhbGsoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBza2lwIGFueXRoaW5nIHdoaWNoIGlzbid0IGEgY2FsYygpIGZ1bmN0aW9uXG4gICAgaWYgKG5vZGUudHlwZSAhPT0gJ2Z1bmN0aW9uJyB8fCAhTUFUQ0hfQ0FMQy50ZXN0KG5vZGUudmFsdWUpKSByZXR1cm47XG5cbiAgICAvLyBzdHJpbmdpZnkgY2FsYyBleHByZXNzaW9uIGFuZCBwcm9kdWNlIGFuIEFTVFxuICAgIHZhciBjb250ZW50cyA9IF9wb3N0Y3NzVmFsdWVQYXJzZXIyLmRlZmF1bHQuc3RyaW5naWZ5KG5vZGUubm9kZXMpO1xuXG4gICAgLy8gc2tpcCBjb25zdGFudCgpIGFuZCBlbnYoKVxuICAgIGlmIChjb250ZW50cy5pbmRleE9mKCdjb25zdGFudCcpID49IDAgfHwgY29udGVudHMuaW5kZXhPZignZW52JykgPj0gMCkgcmV0dXJuO1xuXG4gICAgdmFyIGFzdCA9IF9wYXJzZXIucGFyc2VyLnBhcnNlKGNvbnRlbnRzKTtcblxuICAgIC8vIHJlZHVjZSBBU1QgdG8gaXRzIHNpbXBsZXN0IGZvcm0sIHRoYXQgaXMsIGVpdGhlciB0byBhIHNpbmdsZSB2YWx1ZVxuICAgIC8vIG9yIGEgc2ltcGxpZmllZCBjYWxjIGV4cHJlc3Npb25cbiAgICB2YXIgcmVkdWNlZEFzdCA9ICgwLCBfcmVkdWNlcjIuZGVmYXVsdCkoYXN0LCBwcmVjaXNpb24pO1xuXG4gICAgLy8gc3RyaW5naWZ5IEFTVCBhbmQgd3JpdGUgaXQgYmFja1xuICAgIG5vZGUudHlwZSA9ICd3b3JkJztcbiAgICBub2RlLnZhbHVlID0gKDAsIF9zdHJpbmdpZmllcjIuZGVmYXVsdCkobm9kZS52YWx1ZSwgcmVkdWNlZEFzdCwgcHJlY2lzaW9uKTtcbiAgfSwgdHJ1ZSkudG9TdHJpbmcoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9wb3N0Y3NzVmFsdWVQYXJzZXIiLCJyZXF1aXJlIiwiX3Bvc3Rjc3NWYWx1ZVBhcnNlcjIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3BhcnNlciIsIl9yZWR1Y2VyIiwiX3JlZHVjZXIyIiwiX3N0cmluZ2lmaWVyIiwiX3N0cmluZ2lmaWVyMiIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiTUFUQ0hfQ0FMQyIsInByZWNpc2lvbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIndhbGsiLCJub2RlIiwidHlwZSIsInRlc3QiLCJjb250ZW50cyIsInN0cmluZ2lmeSIsIm5vZGVzIiwiaW5kZXhPZiIsImFzdCIsInBhcnNlciIsInBhcnNlIiwicmVkdWNlZEFzdCIsInRvU3RyaW5nIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/convert.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/convert.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _cssUnitConverter = __webpack_require__(/*! css-unit-converter */ \"(ssr)/./node_modules/.pnpm/css-unit-converter@1.1.2/node_modules/css-unit-converter/index.js\");\nvar _cssUnitConverter2 = _interopRequireDefault(_cssUnitConverter);\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction convertNodes(left, right, precision) {\n    switch(left.type){\n        case \"LengthValue\":\n        case \"AngleValue\":\n        case \"TimeValue\":\n        case \"FrequencyValue\":\n        case \"ResolutionValue\":\n            return convertAbsoluteLength(left, right, precision);\n        default:\n            return {\n                left: left,\n                right: right\n            };\n    }\n}\nfunction convertAbsoluteLength(left, right, precision) {\n    if (right.type === left.type) {\n        right = {\n            type: left.type,\n            value: (0, _cssUnitConverter2.default)(right.value, right.unit, left.unit, precision),\n            unit: left.unit\n        };\n    }\n    return {\n        left: left,\n        right: right\n    };\n}\nexports[\"default\"] = convertNodes;\nmodule.exports = exports[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVkdWNlLWNzcy1jYWxjQDIuMS44L25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvZGlzdC9saWIvY29udmVydC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFFRixJQUFJQyxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBRWhDLElBQUlDLHFCQUFxQkMsdUJBQXVCSDtBQUVoRCxTQUFTRyx1QkFBdUJDLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRUUsU0FBU0Y7SUFBSTtBQUFHO0FBRTlGLFNBQVNHLGFBQWFDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxTQUFTO0lBQzFDLE9BQVFGLEtBQUtHLElBQUk7UUFDZixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9DLHNCQUFzQkosTUFBTUMsT0FBT0M7UUFDNUM7WUFDRSxPQUFPO2dCQUFFRixNQUFNQTtnQkFBTUMsT0FBT0E7WUFBTTtJQUN0QztBQUNGO0FBRUEsU0FBU0csc0JBQXNCSixJQUFJLEVBQUVDLEtBQUssRUFBRUMsU0FBUztJQUNuRCxJQUFJRCxNQUFNRSxJQUFJLEtBQUtILEtBQUtHLElBQUksRUFBRTtRQUM1QkYsUUFBUTtZQUNORSxNQUFNSCxLQUFLRyxJQUFJO1lBQ2ZaLE9BQU8sQ0FBQyxHQUFHRyxtQkFBbUJJLE9BQU8sRUFBRUcsTUFBTVYsS0FBSyxFQUFFVSxNQUFNSSxJQUFJLEVBQUVMLEtBQUtLLElBQUksRUFBRUg7WUFDM0VHLE1BQU1MLEtBQUtLLElBQUk7UUFDakI7SUFDRjtJQUNBLE9BQU87UUFBRUwsTUFBTUE7UUFBTUMsT0FBT0E7SUFBTTtBQUNwQztBQUVBWCxrQkFBZSxHQUFHUztBQUNsQk8sT0FBT2hCLE9BQU8sR0FBR0EsT0FBTyxDQUFDLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHJhdGZvcmRfYWkvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVkdWNlLWNzcy1jYWxjQDIuMS44L25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvZGlzdC9saWIvY29udmVydC5qcz8xNjRkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jc3NVbml0Q29udmVydGVyID0gcmVxdWlyZSgnY3NzLXVuaXQtY29udmVydGVyJyk7XG5cbnZhciBfY3NzVW5pdENvbnZlcnRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jc3NVbml0Q29udmVydGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY29udmVydE5vZGVzKGxlZnQsIHJpZ2h0LCBwcmVjaXNpb24pIHtcbiAgc3dpdGNoIChsZWZ0LnR5cGUpIHtcbiAgICBjYXNlICdMZW5ndGhWYWx1ZSc6XG4gICAgY2FzZSAnQW5nbGVWYWx1ZSc6XG4gICAgY2FzZSAnVGltZVZhbHVlJzpcbiAgICBjYXNlICdGcmVxdWVuY3lWYWx1ZSc6XG4gICAgY2FzZSAnUmVzb2x1dGlvblZhbHVlJzpcbiAgICAgIHJldHVybiBjb252ZXJ0QWJzb2x1dGVMZW5ndGgobGVmdCwgcmlnaHQsIHByZWNpc2lvbik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodCB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRBYnNvbHV0ZUxlbmd0aChsZWZ0LCByaWdodCwgcHJlY2lzaW9uKSB7XG4gIGlmIChyaWdodC50eXBlID09PSBsZWZ0LnR5cGUpIHtcbiAgICByaWdodCA9IHtcbiAgICAgIHR5cGU6IGxlZnQudHlwZSxcbiAgICAgIHZhbHVlOiAoMCwgX2Nzc1VuaXRDb252ZXJ0ZXIyLmRlZmF1bHQpKHJpZ2h0LnZhbHVlLCByaWdodC51bml0LCBsZWZ0LnVuaXQsIHByZWNpc2lvbiksXG4gICAgICB1bml0OiBsZWZ0LnVuaXRcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodCB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjb252ZXJ0Tm9kZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfY3NzVW5pdENvbnZlcnRlciIsInJlcXVpcmUiLCJfY3NzVW5pdENvbnZlcnRlcjIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0Iiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjb252ZXJ0Tm9kZXMiLCJsZWZ0IiwicmlnaHQiLCJwcmVjaXNpb24iLCJ0eXBlIiwiY29udmVydEFic29sdXRlTGVuZ3RoIiwidW5pdCIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/convert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/reducer.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/reducer.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.flip = flip;\nvar _convert = __webpack_require__(/*! ./convert */ \"(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/convert.js\");\nvar _convert2 = _interopRequireDefault(_convert);\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction reduce(node, precision) {\n    if (node.type === \"MathExpression\") return reduceMathExpression(node, precision);\n    if (node.type === \"Calc\") return reduce(node.value, precision);\n    return node;\n}\nfunction isEqual(left, right) {\n    return left.type === right.type && left.value === right.value;\n}\nfunction isValueType(type) {\n    switch(type){\n        case \"LengthValue\":\n        case \"AngleValue\":\n        case \"TimeValue\":\n        case \"FrequencyValue\":\n        case \"ResolutionValue\":\n        case \"EmValue\":\n        case \"ExValue\":\n        case \"ChValue\":\n        case \"RemValue\":\n        case \"VhValue\":\n        case \"VwValue\":\n        case \"VminValue\":\n        case \"VmaxValue\":\n        case \"PercentageValue\":\n        case \"Value\":\n            return true;\n    }\n    return false;\n}\nfunction convertMathExpression(node, precision) {\n    var nodes = (0, _convert2.default)(node.left, node.right, precision);\n    var left = reduce(nodes.left, precision);\n    var right = reduce(nodes.right, precision);\n    if (left.type === \"MathExpression\" && right.type === \"MathExpression\") {\n        if (left.operator === \"/\" && right.operator === \"*\" || left.operator === \"-\" && right.operator === \"+\" || left.operator === \"*\" && right.operator === \"/\" || left.operator === \"+\" && right.operator === \"-\") {\n            if (isEqual(left.right, right.right)) nodes = (0, _convert2.default)(left.left, right.left, precision);\n            else if (isEqual(left.right, right.left)) nodes = (0, _convert2.default)(left.left, right.right, precision);\n            left = reduce(nodes.left, precision);\n            right = reduce(nodes.right, precision);\n        }\n    }\n    node.left = left;\n    node.right = right;\n    return node;\n}\nfunction flip(operator) {\n    return operator === \"+\" ? \"-\" : \"+\";\n}\nfunction flipValue(node) {\n    if (isValueType(node.type)) node.value = -node.value;\n    else if (node.type == \"MathExpression\") {\n        node.left = flipValue(node.left);\n        node.right = flipValue(node.right);\n    }\n    return node;\n}\nfunction reduceAddSubExpression(node, precision) {\n    var _node = node, left = _node.left, right = _node.right, op = _node.operator;\n    if (left.type === \"CssVariable\" || right.type === \"CssVariable\") return node;\n    // something + 0 => something\n    // something - 0 => something\n    if (right.value === 0) return left;\n    // 0 + something => something\n    if (left.value === 0 && op === \"+\") return right;\n    // 0 - something => -something\n    if (left.value === 0 && op === \"-\") return flipValue(right);\n    // value + value\n    // value - value\n    if (left.type === right.type && isValueType(left.type)) {\n        node = Object.assign({}, left);\n        if (op === \"+\") node.value = left.value + right.value;\n        else node.value = left.value - right.value;\n    }\n    // value <op> (expr)\n    if (isValueType(left.type) && (right.operator === \"+\" || right.operator === \"-\") && right.type === \"MathExpression\") {\n        // value + (value + something) => (value + value) + something\n        // value + (value - something) => (value + value) - something\n        // value - (value + something) => (value - value) - something\n        // value - (value - something) => (value - value) + something\n        if (left.type === right.left.type) {\n            node = Object.assign({}, node);\n            node.left = reduce({\n                type: \"MathExpression\",\n                operator: op,\n                left: left,\n                right: right.left\n            }, precision);\n            node.right = right.right;\n            node.operator = op === \"-\" ? flip(right.operator) : right.operator;\n            return reduce(node, precision);\n        } else if (left.type === right.right.type) {\n            node = Object.assign({}, node);\n            node.left = reduce({\n                type: \"MathExpression\",\n                operator: op === \"-\" ? flip(right.operator) : right.operator,\n                left: left,\n                right: right.right\n            }, precision);\n            node.right = right.left;\n            return reduce(node, precision);\n        }\n    }\n    // (expr) <op> value\n    if (left.type === \"MathExpression\" && (left.operator === \"+\" || left.operator === \"-\") && isValueType(right.type)) {\n        // (value + something) + value => (value + value) + something\n        // (value - something) + value => (value + value) - something\n        // (value + something) - value => (value - value) + something\n        // (value - something) - value => (value - value) - something\n        if (right.type === left.left.type) {\n            node = Object.assign({}, left);\n            node.left = reduce({\n                type: \"MathExpression\",\n                operator: op,\n                left: left.left,\n                right: right\n            }, precision);\n            return reduce(node, precision);\n        } else if (right.type === left.right.type) {\n            node = Object.assign({}, left);\n            if (left.operator === \"-\") {\n                node.right = reduce({\n                    type: \"MathExpression\",\n                    operator: op === \"-\" ? \"+\" : \"-\",\n                    left: right,\n                    right: left.right\n                }, precision);\n                node.operator = op === \"-\" ? \"-\" : \"+\";\n            } else {\n                node.right = reduce({\n                    type: \"MathExpression\",\n                    operator: op,\n                    left: left.right,\n                    right: right\n                }, precision);\n            }\n            if (node.right.value < 0) {\n                node.right.value *= -1;\n                node.operator = node.operator === \"-\" ? \"+\" : \"-\";\n            }\n            return reduce(node, precision);\n        }\n    }\n    return node;\n}\nfunction reduceDivisionExpression(node, precision) {\n    if (!isValueType(node.right.type)) return node;\n    if (node.right.type !== \"Value\") throw new Error('Cannot divide by \"' + node.right.unit + '\", number expected');\n    if (node.right.value === 0) throw new Error(\"Cannot divide by zero\");\n    // (expr) / value\n    if (node.left.type === \"MathExpression\") {\n        if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {\n            node.left.left.value /= node.right.value;\n            node.left.right.value /= node.right.value;\n            return reduce(node.left, precision);\n        }\n        return node;\n    } else if (isValueType(node.left.type)) {\n        node.left.value /= node.right.value;\n        return node.left;\n    }\n    return node;\n}\nfunction reduceMultiplicationExpression(node) {\n    // (expr) * value\n    if (node.left.type === \"MathExpression\" && node.right.type === \"Value\") {\n        if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {\n            node.left.left.value *= node.right.value;\n            node.left.right.value *= node.right.value;\n            return node.left;\n        }\n    } else if (isValueType(node.left.type) && node.right.type === \"Value\") {\n        node.left.value *= node.right.value;\n        return node.left;\n    } else if (node.left.type === \"Value\" && node.right.type === \"MathExpression\") {\n        if (isValueType(node.right.left.type) && isValueType(node.right.right.type)) {\n            node.right.left.value *= node.left.value;\n            node.right.right.value *= node.left.value;\n            return node.right;\n        }\n    } else if (node.left.type === \"Value\" && isValueType(node.right.type)) {\n        node.right.value *= node.left.value;\n        return node.right;\n    }\n    return node;\n}\nfunction reduceMathExpression(node, precision) {\n    node = convertMathExpression(node, precision);\n    switch(node.operator){\n        case \"+\":\n        case \"-\":\n            return reduceAddSubExpression(node, precision);\n        case \"/\":\n            return reduceDivisionExpression(node, precision);\n        case \"*\":\n            return reduceMultiplicationExpression(node);\n    }\n    return node;\n}\nexports[\"default\"] = reduce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVkdWNlLWNzcy1jYWxjQDIuMS44L25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvZGlzdC9saWIvcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsWUFBWSxHQUFHRTtBQUVmLElBQUlDLFdBQVdDLG1CQUFPQSxDQUFDLG9IQUFXO0FBRWxDLElBQUlDLFlBQVlDLHVCQUF1Qkg7QUFFdkMsU0FBU0csdUJBQXVCQyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUVFLFNBQVNGO0lBQUk7QUFBRztBQUU5RixTQUFTRyxPQUFPQyxJQUFJLEVBQUVDLFNBQVM7SUFDN0IsSUFBSUQsS0FBS0UsSUFBSSxLQUFLLGtCQUFrQixPQUFPQyxxQkFBcUJILE1BQU1DO0lBQ3RFLElBQUlELEtBQUtFLElBQUksS0FBSyxRQUFRLE9BQU9ILE9BQU9DLEtBQUtWLEtBQUssRUFBRVc7SUFFcEQsT0FBT0Q7QUFDVDtBQUVBLFNBQVNJLFFBQVFDLElBQUksRUFBRUMsS0FBSztJQUMxQixPQUFPRCxLQUFLSCxJQUFJLEtBQUtJLE1BQU1KLElBQUksSUFBSUcsS0FBS2YsS0FBSyxLQUFLZ0IsTUFBTWhCLEtBQUs7QUFDL0Q7QUFFQSxTQUFTaUIsWUFBWUwsSUFBSTtJQUN2QixPQUFRQTtRQUNOLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87SUFDWDtJQUNBLE9BQU87QUFDVDtBQUVBLFNBQVNNLHNCQUFzQlIsSUFBSSxFQUFFQyxTQUFTO0lBQzVDLElBQUlRLFFBQVEsQ0FBQyxHQUFH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QUFJLEVBQUVDLFNBQVM7SUFDM0NELE9BQU9RLHNCQUFzQlIsTUFBTUM7SUFFbkMsT0FBUUQsS0FBS1UsUUFBUTtRQUNuQixLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9FLHVCQUF1QlosTUFBTUM7UUFDdEMsS0FBSztZQUNILE9BQU9lLHlCQUF5QmhCLE1BQU1DO1FBQ3hDLEtBQUs7WUFDSCxPQUFPa0IsK0JBQStCbkI7SUFDMUM7SUFDQSxPQUFPQTtBQUNUO0FBRUFYLGtCQUFlLEdBQUdVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RyYXRmb3JkX2FpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZHVjZS1jc3MtY2FsY0AyLjEuOC9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL2Rpc3QvbGliL3JlZHVjZXIuanM/N2E1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZmxpcCA9IGZsaXA7XG5cbnZhciBfY29udmVydCA9IHJlcXVpcmUoXCIuL2NvbnZlcnRcIik7XG5cbnZhciBfY29udmVydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb252ZXJ0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcmVkdWNlKG5vZGUsIHByZWNpc2lvbikge1xuICBpZiAobm9kZS50eXBlID09PSBcIk1hdGhFeHByZXNzaW9uXCIpIHJldHVybiByZWR1Y2VNYXRoRXhwcmVzc2lvbihub2RlLCBwcmVjaXNpb24pO1xuICBpZiAobm9kZS50eXBlID09PSBcIkNhbGNcIikgcmV0dXJuIHJlZHVjZShub2RlLnZhbHVlLCBwcmVjaXNpb24pO1xuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBsZWZ0LnR5cGUgPT09IHJpZ2h0LnR5cGUgJiYgbGVmdC52YWx1ZSA9PT0gcmlnaHQudmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzVmFsdWVUeXBlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnTGVuZ3RoVmFsdWUnOlxuICAgIGNhc2UgJ0FuZ2xlVmFsdWUnOlxuICAgIGNhc2UgJ1RpbWVWYWx1ZSc6XG4gICAgY2FzZSAnRnJlcXVlbmN5VmFsdWUnOlxuICAgIGNhc2UgJ1Jlc29sdXRpb25WYWx1ZSc6XG4gICAgY2FzZSAnRW1WYWx1ZSc6XG4gICAgY2FzZSAnRXhWYWx1ZSc6XG4gICAgY2FzZSAnQ2hWYWx1ZSc6XG4gICAgY2FzZSAnUmVtVmFsdWUnOlxuICAgIGNhc2UgJ1ZoVmFsdWUnOlxuICAgIGNhc2UgJ1Z3VmFsdWUnOlxuICAgIGNhc2UgJ1ZtaW5WYWx1ZSc6XG4gICAgY2FzZSAnVm1heFZhbHVlJzpcbiAgICBjYXNlICdQZXJjZW50YWdlVmFsdWUnOlxuICAgIGNhc2UgJ1ZhbHVlJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udmVydE1hdGhFeHByZXNzaW9uKG5vZGUsIHByZWNpc2lvbikge1xuICB2YXIgbm9kZXMgPSAoMCwgX2NvbnZlcnQyLmRlZmF1bHQpKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgcHJlY2lzaW9uKTtcbiAgdmFyIGxlZnQgPSByZWR1Y2Uobm9kZXMubGVmdCwgcHJlY2lzaW9uKTtcbiAgdmFyIHJpZ2h0ID0gcmVkdWNlKG5vZGVzLnJpZ2h0LCBwcmVjaXNpb24pO1xuXG4gIGlmIChsZWZ0LnR5cGUgPT09IFwiTWF0aEV4cHJlc3Npb25cIiAmJiByaWdodC50eXBlID09PSBcIk1hdGhFeHByZXNzaW9uXCIpIHtcblxuICAgIGlmIChsZWZ0Lm9wZXJhdG9yID09PSAnLycgJiYgcmlnaHQub3BlcmF0b3IgPT09ICcqJyB8fCBsZWZ0Lm9wZXJhdG9yID09PSAnLScgJiYgcmlnaHQub3BlcmF0b3IgPT09ICcrJyB8fCBsZWZ0Lm9wZXJhdG9yID09PSAnKicgJiYgcmlnaHQub3BlcmF0b3IgPT09ICcvJyB8fCBsZWZ0Lm9wZXJhdG9yID09PSAnKycgJiYgcmlnaHQub3BlcmF0b3IgPT09ICctJykge1xuXG4gICAgICBpZiAoaXNFcXVhbChsZWZ0LnJpZ2h0LCByaWdodC5yaWdodCkpIG5vZGVzID0gKDAsIF9jb252ZXJ0Mi5kZWZhdWx0KShsZWZ0LmxlZnQsIHJpZ2h0LmxlZnQsIHByZWNpc2lvbik7ZWxzZSBpZiAoaXNFcXVhbChsZWZ0LnJpZ2h0LCByaWdodC5sZWZ0KSkgbm9kZXMgPSAoMCwgX2NvbnZlcnQyLmRlZmF1bHQpKGxlZnQubGVmdCwgcmlnaHQucmlnaHQsIHByZWNpc2lvbik7XG5cbiAgICAgIGxlZnQgPSByZWR1Y2Uobm9kZXMubGVmdCwgcHJlY2lzaW9uKTtcbiAgICAgIHJpZ2h0ID0gcmVkdWNlKG5vZGVzLnJpZ2h0LCBwcmVjaXNpb24pO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUucmlnaHQgPSByaWdodDtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZsaXAob3BlcmF0b3IpIHtcbiAgcmV0dXJuIG9wZXJhdG9yID09PSAnKycgPyAnLScgOiAnKyc7XG59XG5cbmZ1bmN0aW9uIGZsaXBWYWx1ZShub2RlKSB7XG4gIGlmIChpc1ZhbHVlVHlwZShub2RlLnR5cGUpKSBub2RlLnZhbHVlID0gLW5vZGUudmFsdWU7ZWxzZSBpZiAobm9kZS50eXBlID09ICdNYXRoRXhwcmVzc2lvbicpIHtcbiAgICBub2RlLmxlZnQgPSBmbGlwVmFsdWUobm9kZS5sZWZ0KTtcbiAgICBub2RlLnJpZ2h0ID0gZmxpcFZhbHVlKG5vZGUucmlnaHQpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VBZGRTdWJFeHByZXNzaW9uKG5vZGUsIHByZWNpc2lvbikge1xuICB2YXIgX25vZGUgPSBub2RlLFxuICAgICAgbGVmdCA9IF9ub2RlLmxlZnQsXG4gICAgICByaWdodCA9IF9ub2RlLnJpZ2h0LFxuICAgICAgb3AgPSBfbm9kZS5vcGVyYXRvcjtcblxuXG4gIGlmIChsZWZ0LnR5cGUgPT09ICdDc3NWYXJpYWJsZScgfHwgcmlnaHQudHlwZSA9PT0gJ0Nzc1ZhcmlhYmxlJykgcmV0dXJuIG5vZGU7XG5cbiAgLy8gc29tZXRoaW5nICsgMCA9PiBzb21ldGhpbmdcbiAgLy8gc29tZXRoaW5nIC0gMCA9PiBzb21ldGhpbmdcbiAgaWYgKHJpZ2h0LnZhbHVlID09PSAwKSByZXR1cm4gbGVmdDtcblxuICAvLyAwICsgc29tZXRoaW5nID0+IHNvbWV0aGluZ1xuICBpZiAobGVmdC52YWx1ZSA9PT0gMCAmJiBvcCA9PT0gXCIrXCIpIHJldHVybiByaWdodDtcblxuICAvLyAwIC0gc29tZXRoaW5nID0+IC1zb21ldGhpbmdcbiAgaWYgKGxlZnQudmFsdWUgPT09IDAgJiYgb3AgPT09IFwiLVwiKSByZXR1cm4gZmxpcFZhbHVlKHJpZ2h0KTtcblxuICAvLyB2YWx1ZSArIHZhbHVlXG4gIC8vIHZhbHVlIC0gdmFsdWVcbiAgaWYgKGxlZnQudHlwZSA9PT0gcmlnaHQudHlwZSAmJiBpc1ZhbHVlVHlwZShsZWZ0LnR5cGUpKSB7XG4gICAgbm9kZSA9IE9iamVjdC5hc3NpZ24oe30sIGxlZnQpO1xuICAgIGlmIChvcCA9PT0gXCIrXCIpIG5vZGUudmFsdWUgPSBsZWZ0LnZhbHVlICsgcmlnaHQudmFsdWU7ZWxzZSBub2RlLnZhbHVlID0gbGVmdC52YWx1ZSAtIHJpZ2h0LnZhbHVlO1xuICB9XG5cbiAgLy8gdmFsdWUgPG9wPiAoZXhwcilcbiAgaWYgKGlzVmFsdWVUeXBlKGxlZnQudHlwZSkgJiYgKHJpZ2h0Lm9wZXJhdG9yID09PSAnKycgfHwgcmlnaHQub3BlcmF0b3IgPT09ICctJykgJiYgcmlnaHQudHlwZSA9PT0gJ01hdGhFeHByZXNzaW9uJykge1xuICAgIC8vIHZhbHVlICsgKHZhbHVlICsgc29tZXRoaW5nKSA9PiAodmFsdWUgKyB2YWx1ZSkgKyBzb21ldGhpbmdcbiAgICAvLyB2YWx1ZSArICh2YWx1ZSAtIHNvbWV0aGluZykgPT4gKHZhbHVlICsgdmFsdWUpIC0gc29tZXRoaW5nXG4gICAgLy8gdmFsdWUgLSAodmFsdWUgKyBzb21ldGhpbmcpID0+ICh2YWx1ZSAtIHZhbHVlKSAtIHNvbWV0aGluZ1xuICAgIC8vIHZhbHVlIC0gKHZhbHVlIC0gc29tZXRoaW5nKSA9PiAodmFsdWUgLSB2YWx1ZSkgKyBzb21ldGhpbmdcbiAgICBpZiAobGVmdC50eXBlID09PSByaWdodC5sZWZ0LnR5cGUpIHtcbiAgICAgIG5vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlKTtcbiAgICAgIG5vZGUubGVmdCA9IHJlZHVjZSh7XG4gICAgICAgIHR5cGU6ICdNYXRoRXhwcmVzc2lvbicsXG4gICAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LmxlZnRcbiAgICAgIH0sIHByZWNpc2lvbik7XG4gICAgICBub2RlLnJpZ2h0ID0gcmlnaHQucmlnaHQ7XG4gICAgICBub2RlLm9wZXJhdG9yID0gb3AgPT09ICctJyA/IGZsaXAocmlnaHQub3BlcmF0b3IpIDogcmlnaHQub3BlcmF0b3I7XG4gICAgICByZXR1cm4gcmVkdWNlKG5vZGUsIHByZWNpc2lvbik7XG4gICAgfVxuICAgIC8vIHZhbHVlICsgKHNvbWV0aGluZyArIHZhbHVlKSA9PiAodmFsdWUgKyB2YWx1ZSkgKyBzb21ldGhpbmdcbiAgICAvLyB2YWx1ZSArIChzb21ldGhpbmcgLSB2YWx1ZSkgPT4gKHZhbHVlIC0gdmFsdWUpICsgc29tZXRoaW5nXG4gICAgLy8gdmFsdWUgLSAoc29tZXRoaW5nICsgdmFsdWUpID0+ICh2YWx1ZSAtIHZhbHVlKSAtIHNvbWV0aGluZ1xuICAgIC8vIHZhbHVlIC0gKHNvbWV0aGluZyAtIHZhbHVlKSA9PiAodmFsdWUgKyB2YWx1ZSkgLSBzb21ldGhpbmdcbiAgICBlbHNlIGlmIChsZWZ0LnR5cGUgPT09IHJpZ2h0LnJpZ2h0LnR5cGUpIHtcbiAgICAgICAgbm9kZSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUpO1xuICAgICAgICBub2RlLmxlZnQgPSByZWR1Y2Uoe1xuICAgICAgICAgIHR5cGU6ICdNYXRoRXhwcmVzc2lvbicsXG4gICAgICAgICAgb3BlcmF0b3I6IG9wID09PSAnLScgPyBmbGlwKHJpZ2h0Lm9wZXJhdG9yKSA6IHJpZ2h0Lm9wZXJhdG9yLFxuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LnJpZ2h0XG4gICAgICAgIH0sIHByZWNpc2lvbik7XG4gICAgICAgIG5vZGUucmlnaHQgPSByaWdodC5sZWZ0O1xuICAgICAgICByZXR1cm4gcmVkdWNlKG5vZGUsIHByZWNpc2lvbik7XG4gICAgICB9XG4gIH1cblxuICAvLyAoZXhwcikgPG9wPiB2YWx1ZVxuICBpZiAobGVmdC50eXBlID09PSAnTWF0aEV4cHJlc3Npb24nICYmIChsZWZ0Lm9wZXJhdG9yID09PSAnKycgfHwgbGVmdC5vcGVyYXRvciA9PT0gJy0nKSAmJiBpc1ZhbHVlVHlwZShyaWdodC50eXBlKSkge1xuICAgIC8vICh2YWx1ZSArIHNvbWV0aGluZykgKyB2YWx1ZSA9PiAodmFsdWUgKyB2YWx1ZSkgKyBzb21ldGhpbmdcbiAgICAvLyAodmFsdWUgLSBzb21ldGhpbmcpICsgdmFsdWUgPT4gKHZhbHVlICsgdmFsdWUpIC0gc29tZXRoaW5nXG4gICAgLy8gKHZhbHVlICsgc29tZXRoaW5nKSAtIHZhbHVlID0+ICh2YWx1ZSAtIHZhbHVlKSArIHNvbWV0aGluZ1xuICAgIC8vICh2YWx1ZSAtIHNvbWV0aGluZykgLSB2YWx1ZSA9PiAodmFsdWUgLSB2YWx1ZSkgLSBzb21ldGhpbmdcbiAgICBpZiAocmlnaHQudHlwZSA9PT0gbGVmdC5sZWZ0LnR5cGUpIHtcbiAgICAgIG5vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBsZWZ0KTtcbiAgICAgIG5vZGUubGVmdCA9IHJlZHVjZSh7XG4gICAgICAgIHR5cGU6ICdNYXRoRXhwcmVzc2lvbicsXG4gICAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgICAgbGVmdDogbGVmdC5sZWZ0LFxuICAgICAgICByaWdodDogcmlnaHRcbiAgICAgIH0sIHByZWNpc2lvbik7XG4gICAgICByZXR1cm4gcmVkdWNlKG5vZGUsIHByZWNpc2lvbik7XG4gICAgfVxuICAgIC8vIChzb21ldGhpbmcgKyB2YWx1ZSkgKyB2YWx1ZSA9PiBzb21ldGhpbmcgKyAodmFsdWUgKyB2YWx1ZSlcbiAgICAvLyAoc29tZXRoaW5nIC0gdmFsdWUxKSArIHZhbHVlMiA9PiBzb21ldGhpbmcgLSAodmFsdWUyIC0gdmFsdWUxKVxuICAgIC8vIChzb21ldGhpbmcgKyB2YWx1ZSkgLSB2YWx1ZSA9PiBzb21ldGhpbmcgKyAodmFsdWUgLSB2YWx1ZSlcbiAgICAvLyAoc29tZXRoaW5nIC0gdmFsdWUpIC0gdmFsdWUgPT4gc29tZXRoaW5nIC0gKHZhbHVlICsgdmFsdWUpXG4gICAgZWxzZSBpZiAocmlnaHQudHlwZSA9PT0gbGVmdC5yaWdodC50eXBlKSB7XG4gICAgICAgIG5vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBsZWZ0KTtcbiAgICAgICAgaWYgKGxlZnQub3BlcmF0b3IgPT09ICctJykge1xuICAgICAgICAgIG5vZGUucmlnaHQgPSByZWR1Y2Uoe1xuICAgICAgICAgICAgdHlwZTogJ01hdGhFeHByZXNzaW9uJyxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBvcCA9PT0gJy0nID8gJysnIDogJy0nLFxuICAgICAgICAgICAgbGVmdDogcmlnaHQsXG4gICAgICAgICAgICByaWdodDogbGVmdC5yaWdodFxuICAgICAgICAgIH0sIHByZWNpc2lvbik7XG4gICAgICAgICAgbm9kZS5vcGVyYXRvciA9IG9wID09PSAnLScgPyAnLScgOiAnKyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yaWdodCA9IHJlZHVjZSh7XG4gICAgICAgICAgICB0eXBlOiAnTWF0aEV4cHJlc3Npb24nLFxuICAgICAgICAgICAgb3BlcmF0b3I6IG9wLFxuICAgICAgICAgICAgbGVmdDogbGVmdC5yaWdodCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICAgIH0sIHByZWNpc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucmlnaHQudmFsdWUgPCAwKSB7XG4gICAgICAgICAgbm9kZS5yaWdodC52YWx1ZSAqPSAtMTtcbiAgICAgICAgICBub2RlLm9wZXJhdG9yID0gbm9kZS5vcGVyYXRvciA9PT0gJy0nID8gJysnIDogJy0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWR1Y2Uobm9kZSwgcHJlY2lzaW9uKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRGl2aXNpb25FeHByZXNzaW9uKG5vZGUsIHByZWNpc2lvbikge1xuICBpZiAoIWlzVmFsdWVUeXBlKG5vZGUucmlnaHQudHlwZSkpIHJldHVybiBub2RlO1xuXG4gIGlmIChub2RlLnJpZ2h0LnR5cGUgIT09ICdWYWx1ZScpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXZpZGUgYnkgXFxcIlwiICsgbm9kZS5yaWdodC51bml0ICsgXCJcXFwiLCBudW1iZXIgZXhwZWN0ZWRcIik7XG5cbiAgaWYgKG5vZGUucmlnaHQudmFsdWUgPT09IDApIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRpdmlkZSBieSB6ZXJvJyk7XG5cbiAgLy8gKGV4cHIpIC8gdmFsdWVcbiAgaWYgKG5vZGUubGVmdC50eXBlID09PSAnTWF0aEV4cHJlc3Npb24nKSB7XG4gICAgaWYgKGlzVmFsdWVUeXBlKG5vZGUubGVmdC5sZWZ0LnR5cGUpICYmIGlzVmFsdWVUeXBlKG5vZGUubGVmdC5yaWdodC50eXBlKSkge1xuICAgICAgbm9kZS5sZWZ0LmxlZnQudmFsdWUgLz0gbm9kZS5yaWdodC52YWx1ZTtcbiAgICAgIG5vZGUubGVmdC5yaWdodC52YWx1ZSAvPSBub2RlLnJpZ2h0LnZhbHVlO1xuICAgICAgcmV0dXJuIHJlZHVjZShub2RlLmxlZnQsIHByZWNpc2lvbik7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIC8vIHNvbWV0aGluZyAvIHZhbHVlXG4gIGVsc2UgaWYgKGlzVmFsdWVUeXBlKG5vZGUubGVmdC50eXBlKSkge1xuICAgICAgbm9kZS5sZWZ0LnZhbHVlIC89IG5vZGUucmlnaHQudmFsdWU7XG4gICAgICByZXR1cm4gbm9kZS5sZWZ0O1xuICAgIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZU11bHRpcGxpY2F0aW9uRXhwcmVzc2lvbihub2RlKSB7XG4gIC8vIChleHByKSAqIHZhbHVlXG4gIGlmIChub2RlLmxlZnQudHlwZSA9PT0gJ01hdGhFeHByZXNzaW9uJyAmJiBub2RlLnJpZ2h0LnR5cGUgPT09ICdWYWx1ZScpIHtcbiAgICBpZiAoaXNWYWx1ZVR5cGUobm9kZS5sZWZ0LmxlZnQudHlwZSkgJiYgaXNWYWx1ZVR5cGUobm9kZS5sZWZ0LnJpZ2h0LnR5cGUpKSB7XG4gICAgICBub2RlLmxlZnQubGVmdC52YWx1ZSAqPSBub2RlLnJpZ2h0LnZhbHVlO1xuICAgICAgbm9kZS5sZWZ0LnJpZ2h0LnZhbHVlICo9IG5vZGUucmlnaHQudmFsdWU7XG4gICAgICByZXR1cm4gbm9kZS5sZWZ0O1xuICAgIH1cbiAgfVxuICAvLyBzb21ldGhpbmcgKiB2YWx1ZVxuICBlbHNlIGlmIChpc1ZhbHVlVHlwZShub2RlLmxlZnQudHlwZSkgJiYgbm9kZS5yaWdodC50eXBlID09PSAnVmFsdWUnKSB7XG4gICAgICBub2RlLmxlZnQudmFsdWUgKj0gbm9kZS5yaWdodC52YWx1ZTtcbiAgICAgIHJldHVybiBub2RlLmxlZnQ7XG4gICAgfVxuICAgIC8vIHZhbHVlICogKGV4cHIpXG4gICAgZWxzZSBpZiAobm9kZS5sZWZ0LnR5cGUgPT09ICdWYWx1ZScgJiYgbm9kZS5yaWdodC50eXBlID09PSAnTWF0aEV4cHJlc3Npb24nKSB7XG4gICAgICAgIGlmIChpc1ZhbHVlVHlwZShub2RlLnJpZ2h0LmxlZnQudHlwZSkgJiYgaXNWYWx1ZVR5cGUobm9kZS5yaWdodC5yaWdodC50eXBlKSkge1xuICAgICAgICAgIG5vZGUucmlnaHQubGVmdC52YWx1ZSAqPSBub2RlLmxlZnQudmFsdWU7XG4gICAgICAgICAgbm9kZS5yaWdodC5yaWdodC52YWx1ZSAqPSBub2RlLmxlZnQudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHZhbHVlICogc29tZXRoaW5nXG4gICAgICBlbHNlIGlmIChub2RlLmxlZnQudHlwZSA9PT0gJ1ZhbHVlJyAmJiBpc1ZhbHVlVHlwZShub2RlLnJpZ2h0LnR5cGUpKSB7XG4gICAgICAgICAgbm9kZS5yaWdodC52YWx1ZSAqPSBub2RlLmxlZnQudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucmlnaHQ7XG4gICAgICAgIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZU1hdGhFeHByZXNzaW9uKG5vZGUsIHByZWNpc2lvbikge1xuICBub2RlID0gY29udmVydE1hdGhFeHByZXNzaW9uKG5vZGUsIHByZWNpc2lvbik7XG5cbiAgc3dpdGNoIChub2RlLm9wZXJhdG9yKSB7XG4gICAgY2FzZSBcIitcIjpcbiAgICBjYXNlIFwiLVwiOlxuICAgICAgcmV0dXJuIHJlZHVjZUFkZFN1YkV4cHJlc3Npb24obm9kZSwgcHJlY2lzaW9uKTtcbiAgICBjYXNlIFwiL1wiOlxuICAgICAgcmV0dXJuIHJlZHVjZURpdmlzaW9uRXhwcmVzc2lvbihub2RlLCBwcmVjaXNpb24pO1xuICAgIGNhc2UgXCIqXCI6XG4gICAgICByZXR1cm4gcmVkdWNlTXVsdGlwbGljYXRpb25FeHByZXNzaW9uKG5vZGUpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSByZWR1Y2U7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZmxpcCIsIl9jb252ZXJ0IiwicmVxdWlyZSIsIl9jb252ZXJ0MiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsInJlZHVjZSIsIm5vZGUiLCJwcmVjaXNpb24iLCJ0eXBlIiwicmVkdWNlTWF0aEV4cHJlc3Npb24iLCJpc0VxdWFsIiwibGVmdCIsInJpZ2h0IiwiaXNWYWx1ZVR5cGUiLCJjb252ZXJ0TWF0aEV4cHJlc3Npb24iLCJub2RlcyIsIm9wZXJhdG9yIiwiZmxpcFZhbHVlIiwicmVkdWNlQWRkU3ViRXhwcmVzc2lvbiIsIl9ub2RlIiwib3AiLCJhc3NpZ24iLCJyZWR1Y2VEaXZpc2lvbkV4cHJlc3Npb24iLCJFcnJvciIsInVuaXQiLCJyZWR1Y2VNdWx0aXBsaWNhdGlvbkV4cHJlc3Npb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/reducer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/stringifier.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/stringifier.js ***!
  \*******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = function(calc, node, precision) {\n    var str = stringify(node, precision);\n    if (node.type === \"MathExpression\") {\n        // if calc expression couldn't be resolved to a single value, re-wrap it as\n        // a calc()\n        str = calc + \"(\" + str + \")\";\n    }\n    return str;\n};\nvar _reducer = __webpack_require__(/*! ./reducer */ \"(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/reducer.js\");\nvar order = {\n    \"*\": 0,\n    \"/\": 0,\n    \"+\": 1,\n    \"-\": 1\n};\nfunction round(value, prec) {\n    if (prec !== false) {\n        var precision = Math.pow(10, prec);\n        return Math.round(value * precision) / precision;\n    }\n    return value;\n}\nfunction stringify(node, prec) {\n    switch(node.type){\n        case \"MathExpression\":\n            {\n                var left = node.left, right = node.right, op = node.operator;\n                var str = \"\";\n                if (left.type === \"MathExpression\" && order[op] < order[left.operator]) str += \"(\" + stringify(left, prec) + \")\";\n                else str += stringify(left, prec);\n                str += \" \" + node.operator + \" \";\n                if (right.type === \"MathExpression\" && order[op] < order[right.operator]) {\n                    str += \"(\" + stringify(right, prec) + \")\";\n                } else if (right.type === \"MathExpression\" && op === \"-\" && [\n                    \"+\",\n                    \"-\"\n                ].includes(right.operator)) {\n                    // fix #52 : a-(b+c) = a-b-c\n                    right.operator = (0, _reducer.flip)(right.operator);\n                    str += stringify(right, prec);\n                } else {\n                    str += stringify(right, prec);\n                }\n                return str;\n            }\n        case \"Value\":\n            return round(node.value, prec);\n        case \"CssVariable\":\n            if (node.fallback) {\n                return \"var(\" + node.value + \", \" + stringify(node.fallback, prec, true) + \")\";\n            }\n            return \"var(\" + node.value + \")\";\n        case \"Calc\":\n            if (node.prefix) {\n                return \"-\" + node.prefix + \"-calc(\" + stringify(node.value, prec) + \")\";\n            }\n            return \"calc(\" + stringify(node.value, prec) + \")\";\n        default:\n            return round(node.value, prec) + node.unit;\n    }\n}\nmodule.exports = exports[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVkdWNlLWNzcy1jYWxjQDIuMS44L25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvZGlzdC9saWIvc3RyaW5naWZpZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBRUZELGtCQUFlLEdBQUcsU0FBVUcsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFNBQVM7SUFDL0MsSUFBSUMsTUFBTUMsVUFBVUgsTUFBTUM7SUFFMUIsSUFBSUQsS0FBS0ksSUFBSSxLQUFLLGtCQUFrQjtRQUNsQywyRUFBMkU7UUFDM0UsV0FBVztRQUNYRixNQUFNSCxPQUFPLE1BQU1HLE1BQU07SUFDM0I7SUFDQSxPQUFPQTtBQUNUO0FBRUEsSUFBSUcsV0FBV0MsbUJBQU9BLENBQUMsb0hBQVc7QUFFbEMsSUFBSUMsUUFBUTtJQUNWLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7QUFDUDtBQUVBLFNBQVNDLE1BQU1YLEtBQUssRUFBRVksSUFBSTtJQUN4QixJQUFJQSxTQUFTLE9BQU87UUFDbEIsSUFBSVIsWUFBWVMsS0FBS0MsR0FBRyxDQUFDLElBQUlGO1FBQzdCLE9BQU9DLEtBQUtGLEtBQUssQ0FBQ1gsUUFBUUksYUFBYUE7SUFDekM7SUFDQSxPQUFPSjtBQUNUO0FBRUEsU0FBU00sVUFBVUgsSUFBSSxFQUFFUyxJQUFJO0lBQzNCLE9BQVFULEtBQUtJLElBQUk7UUFDZixLQUFLO1lBQ0g7Z0JBQ0UsSUFBSVEsT0FBT1osS0FBS1ksSUFBSSxFQUNoQkMsUUFBUWIsS0FBS2EsS0FBSyxFQUNsQkMsS0FBS2QsS0FBS2UsUUFBUTtnQkFFdEIsSUFBSWIsTUFBTTtnQkFFVixJQUFJVSxLQUFLUixJQUFJLEtBQUssb0JBQW9CRyxLQUFLLENBQUNPLEdBQUcsR0FBR1AsS0FBSyxDQUFDSyxLQUFLRyxRQUFRLENBQUMsRUFBRWIsT0FBTyxNQUFNQyxVQUFVUyxNQUFNSCxRQUFRO3FCQUFTUCxPQUFPQyxVQUFVUyxNQUFNSDtnQkFFN0lQLE9BQU8sTUFBTUYsS0FBS2UsUUFBUSxHQUFHO2dCQUU3QixJQUFJRixNQUFNVCxJQUFJLEtBQUssb0JBQW9CRyxLQUFLLENBQUNPLEdBQUcsR0FBR1AsS0FBSyxDQUFDTSxNQUFNRSxRQUFRLENBQUMsRUFBRTtvQkFDeEViLE9BQU8sTUFBTUMsVUFBVVUsT0FBT0osUUFBUTtnQkFDeEMsT0FBTyxJQUFJSSxNQUFNVCxJQUFJLEtBQUssb0JBQW9CVSxPQUFPLE9BQU87b0JBQUM7b0JBQUs7aUJBQUksQ0FBQ0UsUUFBUSxDQUFDSCxNQUFNRSxRQUFRLEdBQUc7b0JBQy9GLDRCQUE0QjtvQkFDNUJGLE1BQU1FLFFBQVEsR0FBRyxDQUFDLEdBQUdWLFNBQVNZLElBQUksRUFBRUosTUFBTUUsUUFBUTtvQkFDbERiLE9BQU9DLFVBQVVVLE9BQU9KO2dCQUMxQixPQUFPO29CQUNMUCxPQUFPQyxVQUFVVSxPQUFPSjtnQkFDMUI7Z0JBRUEsT0FBT1A7WUFDVDtRQUNGLEtBQUs7WUFDSCxPQUFPTSxNQUFNUixLQUFLSCxLQUFLLEVBQUVZO1FBQzNCLEtBQUs7WUFDSCxJQUFJVCxLQUFLa0IsUUFBUSxFQUFFO2dCQUNqQixPQUFPLFNBQVNsQixLQUFLSCxLQUFLLEdBQUcsT0FBT00sVUFBVUgsS0FBS2tCLFFBQVEsRUFBRVQsTUFBTSxRQUFRO1lBQzdFO1lBQ0EsT0FBTyxTQUFTVCxLQUFLSCxLQUFLLEdBQUc7UUFDL0IsS0FBSztZQUNILElBQUlHLEtBQUttQixNQUFNLEVBQUU7Z0JBQ2YsT0FBTyxNQUFNbkIsS0FBS21CLE1BQU0sR0FBRyxXQUFXaEIsVUFBVUgsS0FBS0gsS0FBSyxFQUFFWSxRQUFRO1lBQ3RFO1lBQ0EsT0FBTyxVQUFVTixVQUFVSCxLQUFLSCxLQUFLLEVBQUVZLFFBQVE7UUFDakQ7WUFDRSxPQUFPRCxNQUFNUixLQUFLSCxLQUFLLEVBQUVZLFFBQVFULEtBQUtvQixJQUFJO0lBQzlDO0FBQ0Y7QUFFQUMsT0FBT3pCLE9BQU8sR0FBR0EsT0FBTyxDQUFDLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHJhdGZvcmRfYWkvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVkdWNlLWNzcy1jYWxjQDIuMS44L25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvZGlzdC9saWIvc3RyaW5naWZpZXIuanM/YTY3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNhbGMsIG5vZGUsIHByZWNpc2lvbikge1xuICB2YXIgc3RyID0gc3RyaW5naWZ5KG5vZGUsIHByZWNpc2lvbik7XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJNYXRoRXhwcmVzc2lvblwiKSB7XG4gICAgLy8gaWYgY2FsYyBleHByZXNzaW9uIGNvdWxkbid0IGJlIHJlc29sdmVkIHRvIGEgc2luZ2xlIHZhbHVlLCByZS13cmFwIGl0IGFzXG4gICAgLy8gYSBjYWxjKClcbiAgICBzdHIgPSBjYWxjICsgXCIoXCIgKyBzdHIgKyBcIilcIjtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxudmFyIF9yZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlclwiKTtcblxudmFyIG9yZGVyID0ge1xuICBcIipcIjogMCxcbiAgXCIvXCI6IDAsXG4gIFwiK1wiOiAxLFxuICBcIi1cIjogMVxufTtcblxuZnVuY3Rpb24gcm91bmQodmFsdWUsIHByZWMpIHtcbiAgaWYgKHByZWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBwcmVjKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkobm9kZSwgcHJlYykge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJNYXRoRXhwcmVzc2lvblwiOlxuICAgICAge1xuICAgICAgICB2YXIgbGVmdCA9IG5vZGUubGVmdCxcbiAgICAgICAgICAgIHJpZ2h0ID0gbm9kZS5yaWdodCxcbiAgICAgICAgICAgIG9wID0gbm9kZS5vcGVyYXRvcjtcblxuICAgICAgICB2YXIgc3RyID0gXCJcIjtcblxuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnTWF0aEV4cHJlc3Npb24nICYmIG9yZGVyW29wXSA8IG9yZGVyW2xlZnQub3BlcmF0b3JdKSBzdHIgKz0gXCIoXCIgKyBzdHJpbmdpZnkobGVmdCwgcHJlYykgKyBcIilcIjtlbHNlIHN0ciArPSBzdHJpbmdpZnkobGVmdCwgcHJlYyk7XG5cbiAgICAgICAgc3RyICs9IFwiIFwiICsgbm9kZS5vcGVyYXRvciArIFwiIFwiO1xuXG4gICAgICAgIGlmIChyaWdodC50eXBlID09PSAnTWF0aEV4cHJlc3Npb24nICYmIG9yZGVyW29wXSA8IG9yZGVyW3JpZ2h0Lm9wZXJhdG9yXSkge1xuICAgICAgICAgIHN0ciArPSBcIihcIiArIHN0cmluZ2lmeShyaWdodCwgcHJlYykgKyBcIilcIjtcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodC50eXBlID09PSAnTWF0aEV4cHJlc3Npb24nICYmIG9wID09PSBcIi1cIiAmJiBbXCIrXCIsIFwiLVwiXS5pbmNsdWRlcyhyaWdodC5vcGVyYXRvcikpIHtcbiAgICAgICAgICAvLyBmaXggIzUyIDogYS0oYitjKSA9IGEtYi1jXG4gICAgICAgICAgcmlnaHQub3BlcmF0b3IgPSAoMCwgX3JlZHVjZXIuZmxpcCkocmlnaHQub3BlcmF0b3IpO1xuICAgICAgICAgIHN0ciArPSBzdHJpbmdpZnkocmlnaHQsIHByZWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSBzdHJpbmdpZnkocmlnaHQsIHByZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICBjYXNlIFwiVmFsdWVcIjpcbiAgICAgIHJldHVybiByb3VuZChub2RlLnZhbHVlLCBwcmVjKTtcbiAgICBjYXNlICdDc3NWYXJpYWJsZSc6XG4gICAgICBpZiAobm9kZS5mYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gXCJ2YXIoXCIgKyBub2RlLnZhbHVlICsgXCIsIFwiICsgc3RyaW5naWZ5KG5vZGUuZmFsbGJhY2ssIHByZWMsIHRydWUpICsgXCIpXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJ2YXIoXCIgKyBub2RlLnZhbHVlICsgXCIpXCI7XG4gICAgY2FzZSAnQ2FsYyc6XG4gICAgICBpZiAobm9kZS5wcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIFwiLVwiICsgbm9kZS5wcmVmaXggKyBcIi1jYWxjKFwiICsgc3RyaW5naWZ5KG5vZGUudmFsdWUsIHByZWMpICsgXCIpXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJjYWxjKFwiICsgc3RyaW5naWZ5KG5vZGUudmFsdWUsIHByZWMpICsgXCIpXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiByb3VuZChub2RlLnZhbHVlLCBwcmVjKSArIG5vZGUudW5pdDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJjYWxjIiwibm9kZSIsInByZWNpc2lvbiIsInN0ciIsInN0cmluZ2lmeSIsInR5cGUiLCJfcmVkdWNlciIsInJlcXVpcmUiLCJvcmRlciIsInJvdW5kIiwicHJlYyIsIk1hdGgiLCJwb3ciLCJsZWZ0IiwicmlnaHQiLCJvcCIsIm9wZXJhdG9yIiwiaW5jbHVkZXMiLCJmbGlwIiwiZmFsbGJhY2siLCJwcmVmaXgiLCJ1bml0IiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/lib/stringifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/parser.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/parser.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* parser generated by jison 0.6.1-215 */ /*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own 'description' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that's actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journées Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.\n *\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you're clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function's\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success ('accept')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */ var parser = function() {\n    // See also:\n    // http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n    // but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n    // with userland code which might access the derived class in a 'classic' way.\n    function JisonParserError(msg, hash) {\n        Object.defineProperty(this, \"name\", {\n            enumerable: false,\n            writable: false,\n            value: \"JisonParserError\"\n        });\n        if (msg == null) msg = \"???\";\n        Object.defineProperty(this, \"message\", {\n            enumerable: false,\n            writable: true,\n            value: msg\n        });\n        this.hash = hash;\n        var stacktrace;\n        if (hash && hash.exception instanceof Error) {\n            var ex2 = hash.exception;\n            this.message = ex2.message || msg;\n            stacktrace = ex2.stack;\n        }\n        if (!stacktrace) {\n            if (Error.hasOwnProperty(\"captureStackTrace\")) {\n                Error.captureStackTrace(this, this.constructor);\n            } else {\n                stacktrace = new Error(msg).stack;\n            }\n        }\n        if (stacktrace) {\n            Object.defineProperty(this, \"stack\", {\n                enumerable: false,\n                writable: false,\n                value: stacktrace\n            });\n        }\n    }\n    if (typeof Object.setPrototypeOf === \"function\") {\n        Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n    } else {\n        JisonParserError.prototype = Object.create(Error.prototype);\n    }\n    JisonParserError.prototype.constructor = JisonParserError;\n    JisonParserError.prototype.name = \"JisonParserError\";\n    // helper: reconstruct the productions[] table\n    function bp(s) {\n        var rv = [];\n        var p = s.pop;\n        var r = s.rule;\n        for(var i = 0, l = p.length; i < l; i++){\n            rv.push([\n                p[i],\n                r[i]\n            ]);\n        }\n        return rv;\n    }\n    // helper: reconstruct the defaultActions[] table\n    function bda(s) {\n        var rv = {};\n        var d = s.idx;\n        var g = s.goto;\n        for(var i = 0, l = d.length; i < l; i++){\n            var j = d[i];\n            rv[j] = g[i];\n        }\n        return rv;\n    }\n    // helper: reconstruct the 'goto' table\n    function bt(s) {\n        var rv = [];\n        var d = s.len;\n        var y = s.symbol;\n        var t = s.type;\n        var a = s.state;\n        var m = s.mode;\n        var g = s.goto;\n        for(var i = 0, l = d.length; i < l; i++){\n            var n = d[i];\n            var q = {};\n            for(var j = 0; j < n; j++){\n                var z = y.shift();\n                switch(t.shift()){\n                    case 2:\n                        q[z] = [\n                            m.shift(),\n                            g.shift()\n                        ];\n                        break;\n                    case 0:\n                        q[z] = a.shift();\n                        break;\n                    default:\n                        // type === 1: accept\n                        q[z] = [\n                            3\n                        ];\n                }\n            }\n            rv.push(q);\n        }\n        return rv;\n    }\n    // helper: runlength encoding with increment step: code, length: step (default step = 0)\n    // `this` references an array\n    function s(c, l, a) {\n        a = a || 0;\n        for(var i = 0; i < l; i++){\n            this.push(c);\n            c += a;\n        }\n    }\n    // helper: duplicate sequence from *relative* offset and length.\n    // `this` references an array\n    function c(i, l) {\n        i = this.length - i;\n        for(l += i; i < l; i++){\n            this.push(this[i]);\n        }\n    }\n    // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n    function u(a) {\n        var rv = [];\n        for(var i = 0, l = a.length; i < l; i++){\n            var e = a[i];\n            // Is this entry a helper function?\n            if (typeof e === \"function\") {\n                i++;\n                e.apply(rv, a[i]);\n            } else {\n                rv.push(e);\n            }\n        }\n        return rv;\n    }\n    var parser = {\n        // Code Generator Information Report\n        // ---------------------------------\n        //\n        // Options:\n        //\n        //   default action mode: ............. [\"classic\",\"merge\"]\n        //   test-compile action mode: ........ \"parser:*,lexer:*\"\n        //   try..catch: ...................... true\n        //   default resolve on conflict: ..... true\n        //   on-demand look-ahead: ............ false\n        //   error recovery token skip maximum: 3\n        //   yyerror in parse actions is: ..... NOT recoverable,\n        //   yyerror in lexer actions and other non-fatal lexer are:\n        //   .................................. NOT recoverable,\n        //   debug grammar/output: ............ false\n        //   has partial LR conflict upgrade:   true\n        //   rudimentary token-stack support:   false\n        //   parser table compression mode: ... 2\n        //   export debug tables: ............. false\n        //   export *all* tables: ............. false\n        //   module type: ..................... commonjs\n        //   parser engine type: .............. lalr\n        //   output main() in the module: ..... true\n        //   has user-specified main(): ....... false\n        //   has user-specified require()/import modules for main():\n        //   .................................. false\n        //   number of expected conflicts: .... 0\n        //\n        //\n        // Parser Analysis flags:\n        //\n        //   no significant actions (parser is a language matcher only):\n        //   .................................. false\n        //   uses yyleng: ..................... false\n        //   uses yylineno: ................... false\n        //   uses yytext: ..................... false\n        //   uses yylloc: ..................... false\n        //   uses ParseError API: ............. false\n        //   uses YYERROR: .................... false\n        //   uses YYRECOVERING: ............... false\n        //   uses YYERROK: .................... false\n        //   uses YYCLEARIN: .................. false\n        //   tracks rule values: .............. true\n        //   assigns rule values: ............. true\n        //   uses location tracking: .......... false\n        //   assigns location: ................ false\n        //   uses yystack: .................... false\n        //   uses yysstack: ................... false\n        //   uses yysp: ....................... true\n        //   uses yyrulelength: ............... false\n        //   uses yyMergeLocationInfo API: .... false\n        //   has error recovery: .............. false\n        //   has error reporting: ............. false\n        //\n        // --------- END OF REPORT -----------\n        trace: function no_op_trace() {},\n        JisonParserError: JisonParserError,\n        yy: {},\n        options: {\n            type: \"lalr\",\n            hasPartialLrUpgradeOnConflict: true,\n            errorRecoveryTokenDiscardCount: 3\n        },\n        symbols_: {\n            \"$accept\": 0,\n            \"$end\": 1,\n            \"ADD\": 3,\n            \"ANGLE\": 16,\n            \"CHS\": 22,\n            \"COMMA\": 14,\n            \"CSS_CPROP\": 13,\n            \"CSS_VAR\": 12,\n            \"DIV\": 6,\n            \"EMS\": 20,\n            \"EOF\": 1,\n            \"EXS\": 21,\n            \"FREQ\": 18,\n            \"LENGTH\": 15,\n            \"LPAREN\": 7,\n            \"MUL\": 5,\n            \"NESTED_CALC\": 9,\n            \"NUMBER\": 11,\n            \"PERCENTAGE\": 28,\n            \"PREFIX\": 10,\n            \"REMS\": 23,\n            \"RES\": 19,\n            \"RPAREN\": 8,\n            \"SUB\": 4,\n            \"TIME\": 17,\n            \"VHS\": 24,\n            \"VMAXS\": 27,\n            \"VMINS\": 26,\n            \"VWS\": 25,\n            \"css_value\": 33,\n            \"css_variable\": 32,\n            \"error\": 2,\n            \"expression\": 29,\n            \"math_expression\": 30,\n            \"value\": 31\n        },\n        terminals_: {\n            1: \"EOF\",\n            2: \"error\",\n            3: \"ADD\",\n            4: \"SUB\",\n            5: \"MUL\",\n            6: \"DIV\",\n            7: \"LPAREN\",\n            8: \"RPAREN\",\n            9: \"NESTED_CALC\",\n            10: \"PREFIX\",\n            11: \"NUMBER\",\n            12: \"CSS_VAR\",\n            13: \"CSS_CPROP\",\n            14: \"COMMA\",\n            15: \"LENGTH\",\n            16: \"ANGLE\",\n            17: \"TIME\",\n            18: \"FREQ\",\n            19: \"RES\",\n            20: \"EMS\",\n            21: \"EXS\",\n            22: \"CHS\",\n            23: \"REMS\",\n            24: \"VHS\",\n            25: \"VWS\",\n            26: \"VMINS\",\n            27: \"VMAXS\",\n            28: \"PERCENTAGE\"\n        },\n        TERROR: 2,\n        EOF: 1,\n        // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n        // thus helping JIT compilers like Chrome V8.\n        originalQuoteName: null,\n        originalParseError: null,\n        cleanupAfterParse: null,\n        constructParseErrorInfo: null,\n        yyMergeLocationInfo: null,\n        __reentrant_call_depth: 0,\n        __error_infos: [],\n        __error_recovery_infos: [],\n        // APIs which will be set up depending on user action code analysis:\n        //yyRecovering: 0,\n        //yyErrOk: 0,\n        //yyClearIn: 0,\n        // Helper APIs\n        // -----------\n        // Helper function which can be overridden by user code later on: put suitable quotes around\n        // literal IDs in a description string.\n        quoteName: function parser_quoteName(id_str) {\n            return '\"' + id_str + '\"';\n        },\n        // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n        //\n        // Return NULL when the symbol is unknown to the parser.\n        getSymbolName: function parser_getSymbolName(symbol) {\n            if (this.terminals_[symbol]) {\n                return this.terminals_[symbol];\n            }\n            // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n            //\n            // An example of this may be where a rule's action code contains a call like this:\n            //\n            //      parser.getSymbolName(#$)\n            //\n            // to obtain a human-readable name of the current grammar rule.\n            var s = this.symbols_;\n            for(var key in s){\n                if (s[key] === symbol) {\n                    return key;\n                }\n            }\n            return null;\n        },\n        // Return a more-or-less human-readable description of the given symbol, when available,\n        // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n        //\n        // Return NULL when the symbol is unknown to the parser.\n        describeSymbol: function parser_describeSymbol(symbol) {\n            if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n                return this.terminal_descriptions_[symbol];\n            } else if (symbol === this.EOF) {\n                return \"end of input\";\n            }\n            var id = this.getSymbolName(symbol);\n            if (id) {\n                return this.quoteName(id);\n            }\n            return null;\n        },\n        // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n        //\n        // The produced list may contain token or token set descriptions instead of the tokens\n        // themselves to help turning this output into something that easier to read by humans\n        // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n        // expected terminals and nonterminals is produced.\n        //\n        // The returned list (array) will not contain any duplicate entries.\n        collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n            var TERROR = this.TERROR;\n            var tokenset = [];\n            var check = {};\n            // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n            // If so, use that one instead of the less palatable token set.\n            if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n                return [\n                    this.state_descriptions_[state]\n                ];\n            }\n            for(var p in this.table[state]){\n                p = +p;\n                if (p !== TERROR) {\n                    var d = do_not_describe ? p : this.describeSymbol(p);\n                    if (d && !check[d]) {\n                        tokenset.push(d);\n                        check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.\n                    }\n                }\n            }\n            return tokenset;\n        },\n        productions_: bp({\n            pop: u([\n                29,\n                s,\n                [\n                    30,\n                    10\n                ],\n                31,\n                31,\n                32,\n                32,\n                s,\n                [\n                    33,\n                    15\n                ]\n            ]),\n            rule: u([\n                2,\n                s,\n                [\n                    3,\n                    5\n                ],\n                4,\n                7,\n                s,\n                [\n                    1,\n                    4\n                ],\n                2,\n                4,\n                6,\n                s,\n                [\n                    1,\n                    14\n                ],\n                2\n            ])\n        }),\n        performAction: function parser__PerformAction(yystate /* action[1] */ , yysp, yyvstack) {\n            /* this == yyval */ // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n            var yy = this.yy;\n            var yyparser = yy.parser;\n            var yylexer = yy.lexer;\n            switch(yystate){\n                case 0:\n                    /*! Production::    $accept : expression $end */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):\n                    this.$ = yyvstack[yysp - 1];\n                    break;\n                case 1:\n                    /*! Production::    expression : math_expression EOF */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):\n                    this.$ = yyvstack[yysp - 1];\n                    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)\n                    return yyvstack[yysp - 1];\n                    break;\n                case 2:\n                /*! Production::    math_expression : math_expression ADD math_expression */ case 3:\n                /*! Production::    math_expression : math_expression SUB math_expression */ case 4:\n                /*! Production::    math_expression : math_expression MUL math_expression */ case 5:\n                    /*! Production::    math_expression : math_expression DIV math_expression */ this.$ = {\n                        type: \"MathExpression\",\n                        operator: yyvstack[yysp - 1],\n                        left: yyvstack[yysp - 2],\n                        right: yyvstack[yysp]\n                    };\n                    break;\n                case 6:\n                    /*! Production::    math_expression : LPAREN math_expression RPAREN */ this.$ = yyvstack[yysp - 1];\n                    break;\n                case 7:\n                    /*! Production::    math_expression : NESTED_CALC LPAREN math_expression RPAREN */ this.$ = {\n                        type: \"Calc\",\n                        value: yyvstack[yysp - 1]\n                    };\n                    break;\n                case 8:\n                    /*! Production::    math_expression : SUB PREFIX SUB NESTED_CALC LPAREN math_expression RPAREN */ this.$ = {\n                        type: \"Calc\",\n                        value: yyvstack[yysp - 1],\n                        prefix: yyvstack[yysp - 5]\n                    };\n                    break;\n                case 9:\n                /*! Production::    math_expression : css_variable */ case 10:\n                /*! Production::    math_expression : css_value */ case 11:\n                    /*! Production::    math_expression : value */ this.$ = yyvstack[yysp];\n                    break;\n                case 12:\n                    /*! Production::    value : NUMBER */ this.$ = {\n                        type: \"Value\",\n                        value: parseFloat(yyvstack[yysp])\n                    };\n                    break;\n                case 13:\n                    /*! Production::    value : SUB NUMBER */ this.$ = {\n                        type: \"Value\",\n                        value: parseFloat(yyvstack[yysp]) * -1\n                    };\n                    break;\n                case 14:\n                    /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP RPAREN */ this.$ = {\n                        type: \"CssVariable\",\n                        value: yyvstack[yysp - 1]\n                    };\n                    break;\n                case 15:\n                    /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP COMMA math_expression RPAREN */ this.$ = {\n                        type: \"CssVariable\",\n                        value: yyvstack[yysp - 3],\n                        fallback: yyvstack[yysp - 1]\n                    };\n                    break;\n                case 16:\n                    /*! Production::    css_value : LENGTH */ this.$ = {\n                        type: \"LengthValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n                    };\n                    break;\n                case 17:\n                    /*! Production::    css_value : ANGLE */ this.$ = {\n                        type: \"AngleValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n                    };\n                    break;\n                case 18:\n                    /*! Production::    css_value : TIME */ this.$ = {\n                        type: \"TimeValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n                    };\n                    break;\n                case 19:\n                    /*! Production::    css_value : FREQ */ this.$ = {\n                        type: \"FrequencyValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n                    };\n                    break;\n                case 20:\n                    /*! Production::    css_value : RES */ this.$ = {\n                        type: \"ResolutionValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n                    };\n                    break;\n                case 21:\n                    /*! Production::    css_value : EMS */ this.$ = {\n                        type: \"EmValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"em\"\n                    };\n                    break;\n                case 22:\n                    /*! Production::    css_value : EXS */ this.$ = {\n                        type: \"ExValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"ex\"\n                    };\n                    break;\n                case 23:\n                    /*! Production::    css_value : CHS */ this.$ = {\n                        type: \"ChValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"ch\"\n                    };\n                    break;\n                case 24:\n                    /*! Production::    css_value : REMS */ this.$ = {\n                        type: \"RemValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"rem\"\n                    };\n                    break;\n                case 25:\n                    /*! Production::    css_value : VHS */ this.$ = {\n                        type: \"VhValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"vh\"\n                    };\n                    break;\n                case 26:\n                    /*! Production::    css_value : VWS */ this.$ = {\n                        type: \"VwValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"vw\"\n                    };\n                    break;\n                case 27:\n                    /*! Production::    css_value : VMINS */ this.$ = {\n                        type: \"VminValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"vmin\"\n                    };\n                    break;\n                case 28:\n                    /*! Production::    css_value : VMAXS */ this.$ = {\n                        type: \"VmaxValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"vmax\"\n                    };\n                    break;\n                case 29:\n                    /*! Production::    css_value : PERCENTAGE */ this.$ = {\n                        type: \"PercentageValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"%\"\n                    };\n                    break;\n                case 30:\n                    /*! Production::    css_value : SUB css_value */ var prev = yyvstack[yysp];\n                    prev.value *= -1;\n                    this.$ = prev;\n                    break;\n            }\n        },\n        table: bt({\n            len: u([\n                24,\n                1,\n                5,\n                23,\n                1,\n                18,\n                s,\n                [\n                    0,\n                    3\n                ],\n                1,\n                s,\n                [\n                    0,\n                    16\n                ],\n                s,\n                [\n                    23,\n                    4\n                ],\n                c,\n                [\n                    28,\n                    3\n                ],\n                0,\n                0,\n                16,\n                1,\n                6,\n                6,\n                s,\n                [\n                    0,\n                    3\n                ],\n                5,\n                1,\n                2,\n                c,\n                [\n                    37,\n                    3\n                ],\n                c,\n                [\n                    20,\n                    3\n                ],\n                5,\n                0,\n                0\n            ]),\n            symbol: u([\n                4,\n                7,\n                9,\n                11,\n                12,\n                s,\n                [\n                    15,\n                    19,\n                    1\n                ],\n                1,\n                1,\n                s,\n                [\n                    3,\n                    4,\n                    1\n                ],\n                c,\n                [\n                    30,\n                    19\n                ],\n                c,\n                [\n                    29,\n                    4\n                ],\n                7,\n                4,\n                10,\n                11,\n                c,\n                [\n                    22,\n                    14\n                ],\n                c,\n                [\n                    19,\n                    3\n                ],\n                c,\n                [\n                    43,\n                    22\n                ],\n                c,\n                [\n                    23,\n                    69\n                ],\n                c,\n                [\n                    139,\n                    4\n                ],\n                8,\n                c,\n                [\n                    51,\n                    24\n                ],\n                4,\n                c,\n                [\n                    138,\n                    15\n                ],\n                13,\n                c,\n                [\n                    186,\n                    5\n                ],\n                8,\n                c,\n                [\n                    6,\n                    6\n                ],\n                c,\n                [\n                    5,\n                    5\n                ],\n                9,\n                8,\n                14,\n                c,\n                [\n                    159,\n                    47\n                ],\n                c,\n                [\n                    60,\n                    10\n                ]\n            ]),\n            type: u([\n                s,\n                [\n                    2,\n                    19\n                ],\n                s,\n                [\n                    0,\n                    5\n                ],\n                1,\n                s,\n                [\n                    2,\n                    24\n                ],\n                s,\n                [\n                    0,\n                    4\n                ],\n                c,\n                [\n                    22,\n                    19\n                ],\n                c,\n                [\n                    43,\n                    42\n                ],\n                c,\n                [\n                    23,\n                    70\n                ],\n                c,\n                [\n                    28,\n                    25\n                ],\n                c,\n                [\n                    45,\n                    25\n                ],\n                c,\n                [\n                    113,\n                    54\n                ]\n            ]),\n            state: u([\n                1,\n                2,\n                8,\n                6,\n                7,\n                30,\n                c,\n                [\n                    4,\n                    3\n                ],\n                33,\n                37,\n                c,\n                [\n                    5,\n                    3\n                ],\n                38,\n                c,\n                [\n                    4,\n                    3\n                ],\n                39,\n                c,\n                [\n                    4,\n                    3\n                ],\n                40,\n                c,\n                [\n                    4,\n                    3\n                ],\n                42,\n                c,\n                [\n                    21,\n                    4\n                ],\n                50,\n                c,\n                [\n                    5,\n                    3\n                ],\n                51,\n                c,\n                [\n                    4,\n                    3\n                ]\n            ]),\n            mode: u([\n                s,\n                [\n                    1,\n                    179\n                ],\n                s,\n                [\n                    2,\n                    3\n                ],\n                c,\n                [\n                    5,\n                    5\n                ],\n                c,\n                [\n                    6,\n                    4\n                ],\n                s,\n                [\n                    1,\n                    57\n                ]\n            ]),\n            goto: u([\n                5,\n                3,\n                4,\n                24,\n                s,\n                [\n                    9,\n                    15,\n                    1\n                ],\n                s,\n                [\n                    25,\n                    5,\n                    1\n                ],\n                c,\n                [\n                    24,\n                    19\n                ],\n                31,\n                35,\n                32,\n                34,\n                c,\n                [\n                    18,\n                    14\n                ],\n                36,\n                c,\n                [\n                    38,\n                    19\n                ],\n                c,\n                [\n                    19,\n                    57\n                ],\n                c,\n                [\n                    118,\n                    4\n                ],\n                41,\n                c,\n                [\n                    24,\n                    19\n                ],\n                43,\n                35,\n                c,\n                [\n                    16,\n                    14\n                ],\n                44,\n                s,\n                [\n                    2,\n                    3\n                ],\n                28,\n                29,\n                2,\n                s,\n                [\n                    3,\n                    3\n                ],\n                28,\n                29,\n                3,\n                c,\n                [\n                    53,\n                    4\n                ],\n                s,\n                [\n                    45,\n                    5,\n                    1\n                ],\n                c,\n                [\n                    100,\n                    42\n                ],\n                52,\n                c,\n                [\n                    5,\n                    4\n                ],\n                53\n            ])\n        }),\n        defaultActions: bda({\n            idx: u([\n                6,\n                7,\n                8,\n                s,\n                [\n                    10,\n                    16,\n                    1\n                ],\n                33,\n                34,\n                39,\n                40,\n                41,\n                45,\n                47,\n                52,\n                53\n            ]),\n            goto: u([\n                9,\n                10,\n                11,\n                s,\n                [\n                    16,\n                    14,\n                    1\n                ],\n                12,\n                1,\n                30,\n                13,\n                s,\n                [\n                    4,\n                    4,\n                    1\n                ],\n                14,\n                15,\n                8\n            ])\n        }),\n        parseError: function parseError(str, hash, ExceptionClass) {\n            if (hash.recoverable) {\n                if (typeof this.trace === \"function\") {\n                    this.trace(str);\n                }\n                hash.destroy(); // destroy... well, *almost*!\n            } else {\n                if (typeof this.trace === \"function\") {\n                    this.trace(str);\n                }\n                if (!ExceptionClass) {\n                    ExceptionClass = this.JisonParserError;\n                }\n                throw new ExceptionClass(str, hash);\n            }\n        },\n        parse: function parse(input) {\n            var self = this;\n            var stack = new Array(128); // token stack: stores token which leads to state at the same index (column storage)\n            var sstack = new Array(128); // state stack: stores states (column storage)\n            var vstack = new Array(128); // semantic value stack\n            var table = this.table;\n            var sp = 0; // 'stack pointer': index into the stacks\n            var symbol = 0;\n            var TERROR = this.TERROR;\n            var EOF = this.EOF;\n            var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = this.options.errorRecoveryTokenDiscardCount | 0 || 3;\n            var NO_ACTION = [\n                0,\n                54 /* === table.length :: ensures that anyone using this new state will fail dramatically! */ \n            ];\n            var lexer;\n            if (this.__lexer__) {\n                lexer = this.__lexer__;\n            } else {\n                lexer = this.__lexer__ = Object.create(this.lexer);\n            }\n            var sharedState_yy = {\n                parseError: undefined,\n                quoteName: undefined,\n                lexer: undefined,\n                parser: undefined,\n                pre_parse: undefined,\n                post_parse: undefined,\n                pre_lex: undefined,\n                post_lex: undefined // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n            };\n            var ASSERT;\n            if (typeof assert !== \"function\") {\n                ASSERT = function JisonAssert(cond, msg) {\n                    if (!cond) {\n                        throw new Error(\"assertion failed: \" + (msg || \"***\"));\n                    }\n                };\n            } else {\n                ASSERT = assert;\n            }\n            this.yyGetSharedState = function yyGetSharedState() {\n                return sharedState_yy;\n            };\n            function shallow_copy_noclobber(dst, src) {\n                for(var k in src){\n                    if (typeof dst[k] === \"undefined\" && Object.prototype.hasOwnProperty.call(src, k)) {\n                        dst[k] = src[k];\n                    }\n                }\n            }\n            // copy state\n            shallow_copy_noclobber(sharedState_yy, this.yy);\n            sharedState_yy.lexer = lexer;\n            sharedState_yy.parser = this;\n            // Does the shared state override the default `parseError` that already comes with this instance?\n            if (typeof sharedState_yy.parseError === \"function\") {\n                this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n                    if (!ExceptionClass) {\n                        ExceptionClass = this.JisonParserError;\n                    }\n                    return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n                };\n            } else {\n                this.parseError = this.originalParseError;\n            }\n            // Does the shared state override the default `quoteName` that already comes with this instance?\n            if (typeof sharedState_yy.quoteName === \"function\") {\n                this.quoteName = function quoteNameAlt(id_str) {\n                    return sharedState_yy.quoteName.call(this, id_str);\n                };\n            } else {\n                this.quoteName = this.originalQuoteName;\n            }\n            // set up the cleanup function; make it an API so that external code can re-use this one in case of\n            // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n            // case this parse() API method doesn't come with a `finally { ... }` block any more!\n            //\n            // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n            //       or else your `sharedState`, etc. references will be *wrong*!\n            this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n                var rv;\n                if (invoke_post_methods) {\n                    var hash;\n                    if (sharedState_yy.post_parse || this.post_parse) {\n                        // create an error hash info instance: we re-use this API in a **non-error situation**\n                        // as this one delivers all parser internals ready for access by userland code.\n                        hash = this.constructParseErrorInfo(null, null, null, false);\n                    }\n                    if (sharedState_yy.post_parse) {\n                        rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n                        if (typeof rv !== \"undefined\") resultValue = rv;\n                    }\n                    if (this.post_parse) {\n                        rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n                        if (typeof rv !== \"undefined\") resultValue = rv;\n                    }\n                    // cleanup:\n                    if (hash && hash.destroy) {\n                        hash.destroy();\n                    }\n                }\n                if (this.__reentrant_call_depth > 1) return resultValue; // do not (yet) kill the sharedState when this is a reentrant run.\n                // clean up the lingering lexer structures as well:\n                if (lexer.cleanupAfterLex) {\n                    lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n                }\n                // prevent lingering circular references from causing memory leaks:\n                if (sharedState_yy) {\n                    sharedState_yy.lexer = undefined;\n                    sharedState_yy.parser = undefined;\n                    if (lexer.yy === sharedState_yy) {\n                        lexer.yy = undefined;\n                    }\n                }\n                sharedState_yy = undefined;\n                this.parseError = this.originalParseError;\n                this.quoteName = this.originalQuoteName;\n                // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n                // To be safe, we nuke the other internal stack columns as well...\n                stack.length = 0; // fastest way to nuke an array without overly bothering the GC\n                sstack.length = 0;\n                vstack.length = 0;\n                sp = 0;\n                // nuke the error hash info instances created during this run.\n                // Userland code must COPY any data/references\n                // in the error hash instance(s) it is more permanently interested in.\n                if (!do_not_nuke_errorinfos) {\n                    for(var i = this.__error_infos.length - 1; i >= 0; i--){\n                        var el = this.__error_infos[i];\n                        if (el && typeof el.destroy === \"function\") {\n                            el.destroy();\n                        }\n                    }\n                    this.__error_infos.length = 0;\n                }\n                return resultValue;\n            };\n            // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n            //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n            this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n                var pei = {\n                    errStr: msg,\n                    exception: ex,\n                    text: lexer.match,\n                    value: lexer.yytext,\n                    token: this.describeSymbol(symbol) || symbol,\n                    token_id: symbol,\n                    line: lexer.yylineno,\n                    expected: expected,\n                    recoverable: recoverable,\n                    state: state,\n                    action: action,\n                    new_state: newState,\n                    symbol_stack: stack,\n                    state_stack: sstack,\n                    value_stack: vstack,\n                    stack_pointer: sp,\n                    yy: sharedState_yy,\n                    lexer: lexer,\n                    parser: this,\n                    // and make sure the error info doesn't stay due to potential\n                    // ref cycle via userland code manipulations.\n                    // These would otherwise all be memory leak opportunities!\n                    //\n                    // Note that only array and object references are nuked as those\n                    // constitute the set of elements which can produce a cyclic ref.\n                    // The rest of the members is kept intact as they are harmless.\n                    destroy: function destructParseErrorInfo() {\n                        // remove cyclic references added to error info:\n                        // info.yy = null;\n                        // info.lexer = null;\n                        // info.value = null;\n                        // info.value_stack = null;\n                        // ...\n                        var rec = !!this.recoverable;\n                        for(var key in this){\n                            if (this.hasOwnProperty(key) && typeof key === \"object\") {\n                                this[key] = undefined;\n                            }\n                        }\n                        this.recoverable = rec;\n                    }\n                };\n                // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n                this.__error_infos.push(pei);\n                return pei;\n            };\n            function getNonTerminalFromCode(symbol) {\n                var tokenName = self.getSymbolName(symbol);\n                if (!tokenName) {\n                    tokenName = symbol;\n                }\n                return tokenName;\n            }\n            function stdLex() {\n                var token = lexer.lex();\n                // if token isn't its numeric value, convert\n                if (typeof token !== \"number\") {\n                    token = self.symbols_[token] || token;\n                }\n                return token || EOF;\n            }\n            function fastLex() {\n                var token = lexer.fastLex();\n                // if token isn't its numeric value, convert\n                if (typeof token !== \"number\") {\n                    token = self.symbols_[token] || token;\n                }\n                return token || EOF;\n            }\n            var lex = stdLex;\n            var state, action, r, t;\n            var yyval = {\n                $: true,\n                _$: undefined,\n                yy: sharedState_yy\n            };\n            var p;\n            var yyrulelen;\n            var this_production;\n            var newState;\n            var retval = false;\n            try {\n                this.__reentrant_call_depth++;\n                lexer.setInput(input, sharedState_yy);\n                // NOTE: we *assume* no lexer pre/post handlers are set up *after* \n                // this initial `setInput()` call: hence we can now check and decide\n                // whether we'll go with the standard, slower, lex() API or the\n                // `fast_lex()` one:\n                if (typeof lexer.canIUse === \"function\") {\n                    var lexerInfo = lexer.canIUse();\n                    if (lexerInfo.fastLex && typeof fastLex === \"function\") {\n                        lex = fastLex;\n                    }\n                }\n                vstack[sp] = null;\n                sstack[sp] = 0;\n                stack[sp] = 0;\n                ++sp;\n                if (this.pre_parse) {\n                    this.pre_parse.call(this, sharedState_yy);\n                }\n                if (sharedState_yy.pre_parse) {\n                    sharedState_yy.pre_parse.call(this, sharedState_yy);\n                }\n                newState = sstack[sp - 1];\n                for(;;){\n                    // retrieve state number from top of stack\n                    state = newState; // sstack[sp - 1];\n                    // use default actions if available\n                    if (this.defaultActions[state]) {\n                        action = 2;\n                        newState = this.defaultActions[state];\n                    } else {\n                        // The single `==` condition below covers both these `===` comparisons in a single\n                        // operation:\n                        //\n                        //     if (symbol === null || typeof symbol === 'undefined') ...\n                        if (!symbol) {\n                            symbol = lex();\n                        }\n                        // read action for current state and first input\n                        t = table[state] && table[state][symbol] || NO_ACTION;\n                        newState = t[1];\n                        action = t[0];\n                        // handle parse error\n                        if (!action) {\n                            var errStr;\n                            var errSymbolDescr = this.describeSymbol(symbol) || symbol;\n                            var expected = this.collect_expected_token_set(state);\n                            // Report error\n                            if (typeof lexer.yylineno === \"number\") {\n                                errStr = \"Parse error on line \" + (lexer.yylineno + 1) + \": \";\n                            } else {\n                                errStr = \"Parse error: \";\n                            }\n                            if (typeof lexer.showPosition === \"function\") {\n                                errStr += \"\\n\" + lexer.showPosition(79 - 10, 10) + \"\\n\";\n                            }\n                            if (expected.length) {\n                                errStr += \"Expecting \" + expected.join(\", \") + \", got unexpected \" + errSymbolDescr;\n                            } else {\n                                errStr += \"Unexpected \" + errSymbolDescr;\n                            }\n                            // we cannot recover from the error!\n                            p = this.constructParseErrorInfo(errStr, null, expected, false);\n                            r = this.parseError(p.errStr, p, this.JisonParserError);\n                            if (typeof r !== \"undefined\") {\n                                retval = r;\n                            }\n                            break;\n                        }\n                    }\n                    switch(action){\n                        // catch misc. parse failures:\n                        default:\n                            // this shouldn't happen, unless resolve defaults are off\n                            if (action instanceof Array) {\n                                p = this.constructParseErrorInfo(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol, null, null, false);\n                                r = this.parseError(p.errStr, p, this.JisonParserError);\n                                if (typeof r !== \"undefined\") {\n                                    retval = r;\n                                }\n                                break;\n                            }\n                            // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n                            // or a buggy LUT (LookUp Table):\n                            p = this.constructParseErrorInfo(\"Parsing halted. No viable error recovery approach available due to internal system failure.\", null, null, false);\n                            r = this.parseError(p.errStr, p, this.JisonParserError);\n                            if (typeof r !== \"undefined\") {\n                                retval = r;\n                            }\n                            break;\n                        // shift:\n                        case 1:\n                            stack[sp] = symbol;\n                            vstack[sp] = lexer.yytext;\n                            sstack[sp] = newState; // push state\n                            ++sp;\n                            symbol = 0;\n                            continue;\n                        // reduce:\n                        case 2:\n                            this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                            yyrulelen = this_production[1];\n                            r = this.performAction.call(yyval, newState, sp - 1, vstack);\n                            if (typeof r !== \"undefined\") {\n                                retval = r;\n                                break;\n                            }\n                            // pop off stack\n                            sp -= yyrulelen;\n                            // don't overwrite the `symbol` variable: use a local var to speed things up:\n                            var ntsymbol = this_production[0]; // push nonterminal (reduce)\n                            stack[sp] = ntsymbol;\n                            vstack[sp] = yyval.$;\n                            // goto new state = table[STATE][NONTERMINAL]\n                            newState = table[sstack[sp - 1]][ntsymbol];\n                            sstack[sp] = newState;\n                            ++sp;\n                            continue;\n                        // accept:\n                        case 3:\n                            if (sp !== -2) {\n                                retval = true;\n                                // Return the `$accept` rule's `$$` result, if available.\n                                //\n                                // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                                // default, action):\n                                //\n                                //     $accept: <startSymbol> $end\n                                //                  %{ $$ = $1; @$ = @1; %}\n                                //\n                                // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                                // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                                // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                                //\n                                // In code:\n                                //\n                                //                  %{\n                                //                      @$ = @1;            // if location tracking support is included\n                                //                      if (typeof $1 !== 'undefined')\n                                //                          return $1;\n                                //                      else\n                                //                          return true;           // the default parse result if the rule actions don't produce anything\n                                //                  %}\n                                sp--;\n                                if (typeof vstack[sp] !== \"undefined\") {\n                                    retval = vstack[sp];\n                                }\n                            }\n                            break;\n                    }\n                    break;\n                }\n            } catch (ex) {\n                // report exceptions through the parseError callback too, but keep the exception intact\n                // if it is a known parser or lexer error which has been thrown by parseError() already:\n                if (ex instanceof this.JisonParserError) {\n                    throw ex;\n                } else if (lexer && typeof lexer.JisonLexerError === \"function\" && ex instanceof lexer.JisonLexerError) {\n                    throw ex;\n                }\n                p = this.constructParseErrorInfo(\"Parsing aborted due to exception.\", ex, null, false);\n                retval = false;\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n                if (typeof r !== \"undefined\") {\n                    retval = r;\n                }\n            } finally{\n                retval = this.cleanupAfterParse(retval, true, true);\n                this.__reentrant_call_depth--;\n            } // /finally\n            return retval;\n        }\n    };\n    parser.originalParseError = parser.parseError;\n    parser.originalQuoteName = parser.quoteName;\n    /* lexer generated by jison-lex 0.6.1-215 */ /*\n * Returns a Lexer object of the following structure:\n *\n *  Lexer: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a direct reference!\n *\n *               This \"shared context\" object was passed to the lexer by way of \n *               the `lexer.setInput(str, yy)` API before you may use it.\n *\n *               This \"shared context\" object is passed to the lexer action code in `performAction()`\n *               so userland code in the lexer actions may communicate with the outside world \n *               and/or other lexer rules' actions in more or less complex ways.\n *\n *  }\n *\n *  Lexer.prototype: {\n *    EOF: 1,\n *    ERROR: 2,\n *\n *    yy:        The overall \"shared context\" object reference.\n *\n *    JisonLexerError: function(msg, hash),\n *\n *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `lexer` instance. \n *                               `yy_` is an alias for `this` lexer instance reference used internally.\n *\n *               - `yy`      : a reference to the `yy` \"shared state\" object which was passed to the lexer\n *                             by way of the `lexer.setInput(str, yy)` API before.\n *\n *                             Note:\n *                             The extra arguments you specified in the `%parse-param` statement in your\n *                             **parser** grammar definition file are passed to the lexer via this object\n *                             reference as member variables.\n *\n *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.\n *\n *               - `YY_START`: the current lexer \"start condition\" state.\n *\n *    parseError: function(str, hash, ExceptionClass),\n *\n *    constructLexErrorInfo: function(error_message, is_recoverable),\n *               Helper function.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this lexer kernel in many places; example usage:\n *\n *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);\n *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);\n *\n *    options: { ... lexer %options ... },\n *\n *    lex: function(),\n *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the **parser** or the jison run-time; \n *               when such a collision is detected an exception is thrown to prevent the generated run-time \n *               from silently accepting this confusing and potentially hazardous situation! \n *\n *    cleanupAfterLex: function(do_not_nuke_errorinfos),\n *               Helper function.\n *\n *               This helper API is invoked when the **parse process** has completed: it is the responsibility\n *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. \n *\n *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.\n *\n *    setInput: function(input, [yy]),\n *\n *\n *    input: function(),\n *\n *\n *    unput: function(str),\n *\n *\n *    more: function(),\n *\n *\n *    reject: function(),\n *\n *\n *    less: function(n),\n *\n *\n *    pastInput: function(n),\n *\n *\n *    upcomingInput: function(n),\n *\n *\n *    showPosition: function(),\n *\n *\n *    test_match: function(regex_match_array, rule_index),\n *\n *\n *    next: function(),\n *\n *\n *    begin: function(condition),\n *\n *\n *    pushState: function(condition),\n *\n *\n *    popState: function(),\n *\n *\n *    topState: function(),\n *\n *\n *    _currentRules: function(),\n *\n *\n *    stateStackSize: function(),\n *\n *\n *    performAction: function(yy, yy_, yyrulenumber, YY_START),\n *\n *\n *    rules: [...],\n *\n *\n *    conditions: {associative list: name ==> set},\n *  }\n *\n *\n *  token location info (`yylloc`): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *  }\n *\n * while `this` will reference the current lexer instance.\n *\n * When `parseError` is invoked by the lexer, the default implementation will\n * attempt to invoke `yy.parser.parseError()`; when this callback is not provided\n * it will try to invoke `yy.parseError()` instead. When that callback is also not\n * provided, a `JisonLexerError` exception will be thrown containing the error\n * message and `hash`, as constructed by the `constructLexErrorInfo()` API.\n *\n * Note that the lexer's `JisonLexerError` error class is passed via the\n * `ExceptionClass` argument, which is invoked to construct the exception\n * instance to be thrown, so technically `parseError` will throw the object\n * produced by the `new ExceptionClass(str, hash)` JavaScript expression.\n *\n * ---\n *\n * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.\n * These options are available:\n *\n * (Options are permanent.)\n *  \n *  yy: {\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *  }\n *\n *  lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n * WARNING: the next set of options are not meant to be changed. They echo the abilities of\n * the lexer as per when it was compiled!\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */ var lexer = function() {\n        /**\n   * See also:\n   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n   * with userland code which might access the derived class in a 'classic' way.\n   *\n   * @public\n   * @constructor\n   * @nocollapse\n   */ function JisonLexerError(msg, hash) {\n            Object.defineProperty(this, \"name\", {\n                enumerable: false,\n                writable: false,\n                value: \"JisonLexerError\"\n            });\n            if (msg == null) msg = \"???\";\n            Object.defineProperty(this, \"message\", {\n                enumerable: false,\n                writable: true,\n                value: msg\n            });\n            this.hash = hash;\n            var stacktrace;\n            if (hash && hash.exception instanceof Error) {\n                var ex2 = hash.exception;\n                this.message = ex2.message || msg;\n                stacktrace = ex2.stack;\n            }\n            if (!stacktrace) {\n                if (Error.hasOwnProperty(\"captureStackTrace\")) {\n                    // V8\n                    Error.captureStackTrace(this, this.constructor);\n                } else {\n                    stacktrace = new Error(msg).stack;\n                }\n            }\n            if (stacktrace) {\n                Object.defineProperty(this, \"stack\", {\n                    enumerable: false,\n                    writable: false,\n                    value: stacktrace\n                });\n            }\n        }\n        if (typeof Object.setPrototypeOf === \"function\") {\n            Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);\n        } else {\n            JisonLexerError.prototype = Object.create(Error.prototype);\n        }\n        JisonLexerError.prototype.constructor = JisonLexerError;\n        JisonLexerError.prototype.name = \"JisonLexerError\";\n        var lexer = {\n            // Code Generator Information Report\n            // ---------------------------------\n            //\n            // Options:\n            //\n            //   backtracking: .................... false\n            //   location.ranges: ................. false\n            //   location line+column tracking: ... true\n            //\n            //\n            // Forwarded Parser Analysis flags:\n            //\n            //   uses yyleng: ..................... false\n            //   uses yylineno: ................... false\n            //   uses yytext: ..................... false\n            //   uses yylloc: ..................... false\n            //   uses lexer values: ............... true / true\n            //   location tracking: ............... false\n            //   location assignment: ............. false\n            //\n            //\n            // Lexer Analysis flags:\n            //\n            //   uses yyleng: ..................... ???\n            //   uses yylineno: ................... ???\n            //   uses yytext: ..................... ???\n            //   uses yylloc: ..................... ???\n            //   uses ParseError API: ............. ???\n            //   uses yyerror: .................... ???\n            //   uses location tracking & editing:  ???\n            //   uses more() API: ................. ???\n            //   uses unput() API: ................ ???\n            //   uses reject() API: ............... ???\n            //   uses less() API: ................. ???\n            //   uses display APIs pastInput(), upcomingInput(), showPosition():\n            //        ............................. ???\n            //   uses describeYYLLOC() API: ....... ???\n            //\n            // --------- END OF REPORT -----------\n            EOF: 1,\n            ERROR: 2,\n            // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator\n            // options: {},                             /// <-- injected by the code generator\n            // yy: ...,                                 /// <-- injected by setInput()\n            __currentRuleSet__: null,\n            __error_infos: [],\n            __decompressed: false,\n            done: false,\n            _backtrack: false,\n            _input: \"\",\n            _more: false,\n            _signaled_error_token: false,\n            conditionStack: [],\n            match: \"\",\n            matched: \"\",\n            matches: false,\n            yytext: \"\",\n            offset: 0,\n            yyleng: 0,\n            yylineno: 0,\n            yylloc: null,\n            /**\n     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {\n                msg = \"\" + msg;\n                // heuristic to determine if the error message already contains a (partial) source code dump\n                // as produced by either `showPosition()` or `prettyPrintRange()`:\n                if (show_input_position == undefined) {\n                    show_input_position = !(msg.indexOf(\"\\n\") > 0 && msg.indexOf(\"^\") > 0);\n                }\n                if (this.yylloc && show_input_position) {\n                    if (typeof this.prettyPrintRange === \"function\") {\n                        var pretty_src = this.prettyPrintRange(this.yylloc);\n                        if (!/\\n\\s*$/.test(msg)) {\n                            msg += \"\\n\";\n                        }\n                        msg += \"\\n  Erroneous area:\\n\" + this.prettyPrintRange(this.yylloc);\n                    } else if (typeof this.showPosition === \"function\") {\n                        var pos_str = this.showPosition();\n                        if (pos_str) {\n                            if (msg.length && msg[msg.length - 1] !== \"\\n\" && pos_str[0] !== \"\\n\") {\n                                msg += \"\\n\" + pos_str;\n                            } else {\n                                msg += pos_str;\n                            }\n                        }\n                    }\n                }\n                /** @constructor */ var pei = {\n                    errStr: msg,\n                    recoverable: !!recoverable,\n                    text: this.match,\n                    token: null,\n                    line: this.yylineno,\n                    loc: this.yylloc,\n                    yy: this.yy,\n                    lexer: this,\n                    /**\n         * and make sure the error info doesn't stay due to potential\n         * ref cycle via userland code manipulations.\n         * These would otherwise all be memory leak opportunities!\n         * \n         * Note that only array and object references are nuked as those\n         * constitute the set of elements which can produce a cyclic ref.\n         * The rest of the members is kept intact as they are harmless.\n         * \n         * @public\n         * @this {LexErrorInfo}\n         */ destroy: function destructLexErrorInfo() {\n                        // remove cyclic references added to error info:\n                        // info.yy = null;\n                        // info.lexer = null;\n                        // ...\n                        var rec = !!this.recoverable;\n                        for(var key in this){\n                            if (this.hasOwnProperty(key) && typeof key === \"object\") {\n                                this[key] = undefined;\n                            }\n                        }\n                        this.recoverable = rec;\n                    }\n                };\n                // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n                this.__error_infos.push(pei);\n                return pei;\n            },\n            /**\n     * handler which is invoked when a lexer error occurs.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ parseError: function lexer_parseError(str, hash, ExceptionClass) {\n                if (!ExceptionClass) {\n                    ExceptionClass = this.JisonLexerError;\n                }\n                if (this.yy) {\n                    if (this.yy.parser && typeof this.yy.parser.parseError === \"function\") {\n                        return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n                    } else if (typeof this.yy.parseError === \"function\") {\n                        return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n                    }\n                }\n                throw new ExceptionClass(str, hash);\n            },\n            /**\n     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ yyerror: function yyError(str /*, ...args */ ) {\n                var lineno_msg = \"\";\n                if (this.yylloc) {\n                    lineno_msg = \" on line \" + (this.yylineno + 1);\n                }\n                var p = this.constructLexErrorInfo(\"Lexical error\" + lineno_msg + \": \" + str, this.options.lexerErrorsAreRecoverable);\n                // Add any extra args to the hash under the name `extra_error_attributes`:\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length) {\n                    p.extra_error_attributes = args;\n                }\n                return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n            },\n            /**\n     * final cleanup function for when we have completed lexing the input;\n     * make it an API so that external code can use this one once userland\n     * code has decided it's time to destroy any lingering lexer error\n     * hash object instances and the like: this function helps to clean\n     * up these constructs, which *may* carry cyclic references which would\n     * otherwise prevent the instances from being properly and timely\n     * garbage-collected, i.e. this function helps prevent memory leaks!\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {\n                // prevent lingering circular references from causing memory leaks:\n                this.setInput(\"\", {});\n                // nuke the error hash info instances created during this run.\n                // Userland code must COPY any data/references\n                // in the error hash instance(s) it is more permanently interested in.\n                if (!do_not_nuke_errorinfos) {\n                    for(var i = this.__error_infos.length - 1; i >= 0; i--){\n                        var el = this.__error_infos[i];\n                        if (el && typeof el.destroy === \"function\") {\n                            el.destroy();\n                        }\n                    }\n                    this.__error_infos.length = 0;\n                }\n                return this;\n            },\n            /**\n     * clear the lexer token context; intended for internal use only\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ clear: function lexer_clear() {\n                this.yytext = \"\";\n                this.yyleng = 0;\n                this.match = \"\";\n                // - DO NOT reset `this.matched`\n                this.matches = false;\n                this._more = false;\n                this._backtrack = false;\n                var col = this.yylloc ? this.yylloc.last_column : 0;\n                this.yylloc = {\n                    first_line: this.yylineno + 1,\n                    first_column: col,\n                    last_line: this.yylineno + 1,\n                    last_column: col,\n                    range: [\n                        this.offset,\n                        this.offset\n                    ]\n                };\n            },\n            /**\n     * resets the lexer, sets new input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ setInput: function lexer_setInput(input, yy) {\n                this.yy = yy || this.yy || {};\n                // also check if we've fully initialized the lexer instance,\n                // including expansion work to be done to go from a loaded\n                // lexer to a usable lexer:\n                if (!this.__decompressed) {\n                    // step 1: decompress the regex list:\n                    var rules = this.rules;\n                    for(var i = 0, len = rules.length; i < len; i++){\n                        var rule_re = rules[i];\n                        // compression: is the RE an xref to another RE slot in the rules[] table?\n                        if (typeof rule_re === \"number\") {\n                            rules[i] = rules[rule_re];\n                        }\n                    }\n                    // step 2: unfold the conditions[] set to make these ready for use:\n                    var conditions = this.conditions;\n                    for(var k in conditions){\n                        var spec = conditions[k];\n                        var rule_ids = spec.rules;\n                        var len = rule_ids.length;\n                        var rule_regexes = new Array(len + 1); // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! \n                        var rule_new_ids = new Array(len + 1);\n                        for(var i = 0; i < len; i++){\n                            var idx = rule_ids[i];\n                            var rule_re = rules[idx];\n                            rule_regexes[i + 1] = rule_re;\n                            rule_new_ids[i + 1] = idx;\n                        }\n                        spec.rules = rule_new_ids;\n                        spec.__rule_regexes = rule_regexes;\n                        spec.__rule_count = len;\n                    }\n                    this.__decompressed = true;\n                }\n                this._input = input || \"\";\n                this.clear();\n                this._signaled_error_token = false;\n                this.done = false;\n                this.yylineno = 0;\n                this.matched = \"\";\n                this.conditionStack = [\n                    \"INITIAL\"\n                ];\n                this.__currentRuleSet__ = null;\n                this.yylloc = {\n                    first_line: 1,\n                    first_column: 0,\n                    last_line: 1,\n                    last_column: 0,\n                    range: [\n                        0,\n                        0\n                    ]\n                };\n                this.offset = 0;\n                return this;\n            },\n            /**\n     * edit the remaining input via user-specified callback.\n     * This can be used to forward-adjust the input-to-parse, \n     * e.g. inserting macro expansions and alike in the\n     * input which has yet to be lexed.\n     * The behaviour of this API contrasts the `unput()` et al\n     * APIs as those act on the *consumed* input, while this\n     * one allows one to manipulate the future, without impacting\n     * the current `yyloc` cursor location or any history. \n     * \n     * Use this API to help implement C-preprocessor-like\n     * `#include` statements, etc.\n     * \n     * The provided callback must be synchronous and is\n     * expected to return the edited input (string).\n     *\n     * The `cpsArg` argument value is passed to the callback\n     * as-is.\n     *\n     * `callback` interface: \n     * `function callback(input, cpsArg)`\n     * \n     * - `input` will carry the remaining-input-to-lex string\n     *   from the lexer.\n     * - `cpsArg` is `cpsArg` passed into this API.\n     * \n     * The `this` reference for the callback will be set to\n     * reference this lexer instance so that userland code\n     * in the callback can easily and quickly access any lexer\n     * API. \n     *\n     * When the callback returns a non-string-type falsey value,\n     * we assume the callback did not edit the input and we\n     * will using the input as-is.\n     *\n     * When the callback returns a non-string-type value, it\n     * is converted to a string for lexing via the `\"\" + retval`\n     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html \n     * -- that way any returned object's `toValue()` and `toString()`\n     * methods will be invoked in a proper/desirable order.)\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {\n                var rv = callback.call(this, this._input, cpsArg);\n                if (typeof rv !== \"string\") {\n                    if (rv) {\n                        this._input = \"\" + rv;\n                    }\n                // else: keep `this._input` as is.  \n                } else {\n                    this._input = rv;\n                }\n                return this;\n            },\n            /**\n     * consumes and returns one char from the input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ input: function lexer_input() {\n                if (!this._input) {\n                    //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)\n                    return null;\n                }\n                var ch = this._input[0];\n                this.yytext += ch;\n                this.yyleng++;\n                this.offset++;\n                this.match += ch;\n                this.matched += ch;\n                // Count the linenumber up when we hit the LF (or a stand-alone CR).\n                // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo\n                // and we advance immediately past the LF as well, returning both together as if\n                // it was all a single 'character' only.\n                var slice_len = 1;\n                var lines = false;\n                if (ch === \"\\n\") {\n                    lines = true;\n                } else if (ch === \"\\r\") {\n                    lines = true;\n                    var ch2 = this._input[1];\n                    if (ch2 === \"\\n\") {\n                        slice_len++;\n                        ch += ch2;\n                        this.yytext += ch2;\n                        this.yyleng++;\n                        this.offset++;\n                        this.match += ch2;\n                        this.matched += ch2;\n                        this.yylloc.range[1]++;\n                    }\n                }\n                if (lines) {\n                    this.yylineno++;\n                    this.yylloc.last_line++;\n                    this.yylloc.last_column = 0;\n                } else {\n                    this.yylloc.last_column++;\n                }\n                this.yylloc.range[1]++;\n                this._input = this._input.slice(slice_len);\n                return ch;\n            },\n            /**\n     * unshifts one char (or an entire string) into the input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ unput: function lexer_unput(ch) {\n                var len = ch.length;\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n                this._input = ch + this._input;\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\n                this.yyleng = this.yytext.length;\n                this.offset -= len;\n                this.match = this.match.substr(0, this.match.length - len);\n                this.matched = this.matched.substr(0, this.matched.length - len);\n                if (lines.length > 1) {\n                    this.yylineno -= lines.length - 1;\n                    this.yylloc.last_line = this.yylineno + 1;\n                    // Get last entirely matched line into the `pre_lines[]` array's\n                    // last index slot; we don't mind when other previously \n                    // matched lines end up in the array too. \n                    var pre = this.match;\n                    var pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n                    if (pre_lines.length === 1) {\n                        pre = this.matched;\n                        pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n                    }\n                    this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;\n                } else {\n                    this.yylloc.last_column -= len;\n                }\n                this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;\n                this.done = false;\n                return this;\n            },\n            /**\n     * cache matched text and append it on next action\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ more: function lexer_more() {\n                this._more = true;\n                return this;\n            },\n            /**\n     * signal the lexer that this rule fails to match the input, so the\n     * next matching rule (regex) should be tested instead.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ reject: function lexer_reject() {\n                if (this.options.backtrack_lexer) {\n                    this._backtrack = true;\n                } else {\n                    // when the `parseError()` call returns, we MUST ensure that the error is registered.\n                    // We accomplish this by signaling an 'error' token to be produced for the current\n                    // `.lex()` run.\n                    var lineno_msg = \"\";\n                    if (this.yylloc) {\n                        lineno_msg = \" on line \" + (this.yylineno + 1);\n                    }\n                    var p = this.constructLexErrorInfo(\"Lexical error\" + lineno_msg + \": You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\", false);\n                    this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n                }\n                return this;\n            },\n            /**\n     * retain first n characters of the match\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ less: function lexer_less(n) {\n                return this.unput(this.match.slice(n));\n            },\n            /**\n     * return (part of the) already matched input, i.e. for error\n     * messages.\n     * \n     * Limit the returned string length to `maxSize` (default: 20).\n     * \n     * Limit the returned string to the `maxLines` number of lines of\n     * input (default: 1).\n     * \n     * Negative limit values equal *unlimited*.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ pastInput: function lexer_pastInput(maxSize, maxLines) {\n                var past = this.matched.substring(0, this.matched.length - this.match.length);\n                if (maxSize < 0) maxSize = past.length;\n                else if (!maxSize) maxSize = 20;\n                if (maxLines < 0) maxLines = past.length; // can't ever have more input lines than this! \n                else if (!maxLines) maxLines = 1;\n                // `substr` anticipation: treat \\r\\n as a single character and take a little\n                // more than necessary so that we can still properly check against maxSize\n                // after we've transformed and limited the newLines in here:\n                past = past.substr(-maxSize * 2 - 2);\n                // now that we have a significantly reduced string to process, transform the newlines\n                // and chop them, then limit them:\n                var a = past.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n                a = a.slice(-maxLines);\n                past = a.join(\"\\n\");\n                // When, after limiting to maxLines, we still have too much to return,\n                // do add an ellipsis prefix...\n                if (past.length > maxSize) {\n                    past = \"...\" + past.substr(-maxSize);\n                }\n                return past;\n            },\n            /**\n     * return (part of the) upcoming input, i.e. for error messages.\n     * \n     * Limit the returned string length to `maxSize` (default: 20).\n     * \n     * Limit the returned string to the `maxLines` number of lines of input (default: 1).\n     * \n     * Negative limit values equal *unlimited*.\n     *\n     * > ### NOTE ###\n     * >\n     * > *\"upcoming input\"* is defined as the whole of the both\n     * > the *currently lexed* input, together with any remaining input\n     * > following that. *\"currently lexed\"* input is the input \n     * > already recognized by the lexer but not yet returned with\n     * > the lexer token. This happens when you are invoking this API\n     * > from inside any lexer rule action code block. \n     * >\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {\n                var next = this.match;\n                if (maxSize < 0) maxSize = next.length + this._input.length;\n                else if (!maxSize) maxSize = 20;\n                if (maxLines < 0) maxLines = maxSize; // can't ever have more input lines than this! \n                else if (!maxLines) maxLines = 1;\n                // `substring` anticipation: treat \\r\\n as a single character and take a little\n                // more than necessary so that we can still properly check against maxSize\n                // after we've transformed and limited the newLines in here:\n                if (next.length < maxSize * 2 + 2) {\n                    next += this._input.substring(0, maxSize * 2 + 2); // substring is faster on Chrome/V8 \n                }\n                // now that we have a significantly reduced string to process, transform the newlines\n                // and chop them, then limit them:\n                var a = next.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n                a = a.slice(0, maxLines);\n                next = a.join(\"\\n\");\n                // When, after limiting to maxLines, we still have too much to return,\n                // do add an ellipsis postfix...\n                if (next.length > maxSize) {\n                    next = next.substring(0, maxSize) + \"...\";\n                }\n                return next;\n            },\n            /**\n     * return a string which displays the character position where the\n     * lexing error occurred, i.e. for error messages\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {\n                var pre = this.pastInput(maxPrefix).replace(/\\s/g, \" \");\n                var c = new Array(pre.length + 1).join(\"-\");\n                return pre + this.upcomingInput(maxPostfix).replace(/\\s/g, \" \") + \"\\n\" + c + \"^\";\n            },\n            /**\n     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).\n     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when\n     * it MAY be NULL) and you MUST have a valid location info object anyway:\n     * then we take the given context of the `preceding` and `following` locations, IFF those are available,\n     * and reconstruct the `actual` location info from those.\n     * If this fails, the heuristic is to take the `current` location, IFF available.\n     * If this fails as well, we assume the sought location is at/around the current lexer position\n     * and then produce that one as a response. DO NOTE that these heuristic/derived location info\n     * values MAY be inaccurate!\n     *\n     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just\n     * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {\n                var loc = {\n                    first_line: 1,\n                    first_column: 0,\n                    last_line: 1,\n                    last_column: 0,\n                    range: [\n                        0,\n                        0\n                    ]\n                };\n                if (actual) {\n                    loc.first_line = actual.first_line | 0;\n                    loc.last_line = actual.last_line | 0;\n                    loc.first_column = actual.first_column | 0;\n                    loc.last_column = actual.last_column | 0;\n                    if (actual.range) {\n                        loc.range[0] = actual.range[0] | 0;\n                        loc.range[1] = actual.range[1] | 0;\n                    }\n                }\n                if (loc.first_line <= 0 || loc.last_line < loc.first_line) {\n                    // plan B: heuristic using preceding and following:\n                    if (loc.first_line <= 0 && preceding) {\n                        loc.first_line = preceding.last_line | 0;\n                        loc.first_column = preceding.last_column | 0;\n                        if (preceding.range) {\n                            loc.range[0] = actual.range[1] | 0;\n                        }\n                    }\n                    if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {\n                        loc.last_line = following.first_line | 0;\n                        loc.last_column = following.first_column | 0;\n                        if (following.range) {\n                            loc.range[1] = actual.range[0] | 0;\n                        }\n                    }\n                    // plan C?: see if the 'current' location is useful/sane too:\n                    if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {\n                        loc.first_line = current.first_line | 0;\n                        loc.first_column = current.first_column | 0;\n                        if (current.range) {\n                            loc.range[0] = current.range[0] | 0;\n                        }\n                    }\n                    if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {\n                        loc.last_line = current.last_line | 0;\n                        loc.last_column = current.last_column | 0;\n                        if (current.range) {\n                            loc.range[1] = current.range[1] | 0;\n                        }\n                    }\n                }\n                // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter\n                // or plan D heuristics to produce a 'sensible' last_line value:\n                if (loc.last_line <= 0) {\n                    if (loc.first_line <= 0) {\n                        loc.first_line = this.yylloc.first_line;\n                        loc.last_line = this.yylloc.last_line;\n                        loc.first_column = this.yylloc.first_column;\n                        loc.last_column = this.yylloc.last_column;\n                        loc.range[0] = this.yylloc.range[0];\n                        loc.range[1] = this.yylloc.range[1];\n                    } else {\n                        loc.last_line = this.yylloc.last_line;\n                        loc.last_column = this.yylloc.last_column;\n                        loc.range[1] = this.yylloc.range[1];\n                    }\n                }\n                if (loc.first_line <= 0) {\n                    loc.first_line = loc.last_line;\n                    loc.first_column = 0; // loc.last_column; \n                    loc.range[1] = loc.range[0];\n                }\n                if (loc.first_column < 0) {\n                    loc.first_column = 0;\n                }\n                if (loc.last_column < 0) {\n                    loc.last_column = loc.first_column > 0 ? loc.first_column : 80;\n                }\n                return loc;\n            },\n            /**\n     * return a string which displays the lines & columns of input which are referenced \n     * by the given location info range, plus a few lines of context.\n     * \n     * This function pretty-prints the indicated section of the input, with line numbers \n     * and everything!\n     * \n     * This function is very useful to provide highly readable error reports, while\n     * the location range may be specified in various flexible ways:\n     * \n     * - `loc` is the location info object which references the area which should be\n     *   displayed and 'marked up': these lines & columns of text are marked up by `^`\n     *   characters below each character in the entire input range.\n     * \n     * - `context_loc` is the *optional* location info object which instructs this\n     *   pretty-printer how much *leading* context should be displayed alongside\n     *   the area referenced by `loc`. This can help provide context for the displayed\n     *   error, etc.\n     * \n     *   When this location info is not provided, a default context of 3 lines is\n     *   used.\n     * \n     * - `context_loc2` is another *optional* location info object, which serves\n     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*\n     *   context lines to display in the pretty-print output.\n     * \n     *   When this location info is not provided, a default context of 1 line only is\n     *   used.\n     * \n     * Special Notes:\n     * \n     * - when the `loc`-indicated range is very large (about 5 lines or more), then\n     *   only the first and last few lines of this block are printed while a\n     *   `...continued...` message will be printed between them.\n     * \n     *   This serves the purpose of not printing a huge amount of text when the `loc`\n     *   range happens to be huge: this way a manageable & readable output results\n     *   for arbitrary large ranges.\n     * \n     * - this function can display lines of input which whave not yet been lexed.\n     *   `prettyPrintRange()` can access the entire input!\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {\n                loc = this.deriveLocationInfo(loc, context_loc, context_loc2);\n                const CONTEXT = 3;\n                const CONTEXT_TAIL = 1;\n                const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;\n                var input = this.matched + this._input;\n                var lines = input.split(\"\\n\");\n                var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);\n                var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);\n                var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;\n                var ws_prefix = new Array(lineno_display_width).join(\" \");\n                var nonempty_line_indexes = [];\n                var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {\n                    var lno = index + l0;\n                    var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);\n                    var rv = lno_pfx + \": \" + line;\n                    var errpfx = new Array(lineno_display_width + 1).join(\"^\");\n                    var offset = 2 + 1;\n                    var len = 0;\n                    if (lno === loc.first_line) {\n                        offset += loc.first_column;\n                        len = Math.max(2, (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1);\n                    } else if (lno === loc.last_line) {\n                        len = Math.max(2, loc.last_column + 1);\n                    } else if (lno > loc.first_line && lno < loc.last_line) {\n                        len = Math.max(2, line.length + 1);\n                    }\n                    if (len) {\n                        var lead = new Array(offset).join(\".\");\n                        var mark = new Array(len).join(\"^\");\n                        rv += \"\\n\" + errpfx + lead + mark;\n                        if (line.trim().length > 0) {\n                            nonempty_line_indexes.push(index);\n                        }\n                    }\n                    rv = rv.replace(/\\t/g, \" \");\n                    return rv;\n                });\n                // now make sure we don't print an overly large amount of error area: limit it \n                // to the top and bottom line count:\n                if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {\n                    var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;\n                    var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;\n                    var intermediate_line = new Array(lineno_display_width + 1).join(\" \") + \"  (...continued...)\";\n                    intermediate_line += \"\\n\" + new Array(lineno_display_width + 1).join(\"-\") + \"  (---------------)\";\n                    rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);\n                }\n                return rv.join(\"\\n\");\n            },\n            /**\n     * helper function, used to produce a human readable description as a string, given\n     * the input `yylloc` location object.\n     * \n     * Set `display_range_too` to TRUE to include the string character index position(s)\n     * in the description if the `yylloc.range` is available.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {\n                var l1 = yylloc.first_line;\n                var l2 = yylloc.last_line;\n                var c1 = yylloc.first_column;\n                var c2 = yylloc.last_column;\n                var dl = l2 - l1;\n                var dc = c2 - c1;\n                var rv;\n                if (dl === 0) {\n                    rv = \"line \" + l1 + \", \";\n                    if (dc <= 1) {\n                        rv += \"column \" + c1;\n                    } else {\n                        rv += \"columns \" + c1 + \" .. \" + c2;\n                    }\n                } else {\n                    rv = \"lines \" + l1 + \"(column \" + c1 + \") .. \" + l2 + \"(column \" + c2 + \")\";\n                }\n                if (yylloc.range && display_range_too) {\n                    var r1 = yylloc.range[0];\n                    var r2 = yylloc.range[1] - 1;\n                    if (r2 <= r1) {\n                        rv += \" {String Offset: \" + r1 + \"}\";\n                    } else {\n                        rv += \" {String Offset range: \" + r1 + \" .. \" + r2 + \"}\";\n                    }\n                }\n                return rv;\n            },\n            /**\n     * test the lexed token: return FALSE when not a match, otherwise return token.\n     * \n     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`\n     * contains the actually matched text string.\n     * \n     * Also move the input cursor forward and update the match collectors:\n     * \n     * - `yytext`\n     * - `yyleng`\n     * - `match`\n     * - `matches`\n     * - `yylloc`\n     * - `offset`\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ test_match: function lexer_test_match(match, indexed_rule) {\n                var token, lines, backup, match_str, match_str_len;\n                if (this.options.backtrack_lexer) {\n                    // save context\n                    backup = {\n                        yylineno: this.yylineno,\n                        yylloc: {\n                            first_line: this.yylloc.first_line,\n                            last_line: this.yylloc.last_line,\n                            first_column: this.yylloc.first_column,\n                            last_column: this.yylloc.last_column,\n                            range: this.yylloc.range.slice(0)\n                        },\n                        yytext: this.yytext,\n                        match: this.match,\n                        matches: this.matches,\n                        matched: this.matched,\n                        yyleng: this.yyleng,\n                        offset: this.offset,\n                        _more: this._more,\n                        _input: this._input,\n                        //_signaled_error_token: this._signaled_error_token,\n                        yy: this.yy,\n                        conditionStack: this.conditionStack.slice(0),\n                        done: this.done\n                    };\n                }\n                match_str = match[0];\n                match_str_len = match_str.length;\n                // if (match_str.indexOf('\\n') !== -1 || match_str.indexOf('\\r') !== -1) {\n                lines = match_str.split(/(?:\\r\\n?|\\n)/g);\n                if (lines.length > 1) {\n                    this.yylineno += lines.length - 1;\n                    this.yylloc.last_line = this.yylineno + 1;\n                    this.yylloc.last_column = lines[lines.length - 1].length;\n                } else {\n                    this.yylloc.last_column += match_str_len;\n                }\n                // }\n                this.yytext += match_str;\n                this.match += match_str;\n                this.matched += match_str;\n                this.matches = match;\n                this.yyleng = this.yytext.length;\n                this.yylloc.range[1] += match_str_len;\n                // previous lex rules MAY have invoked the `more()` API rather than producing a token:\n                // those rules will already have moved this `offset` forward matching their match lengths,\n                // hence we must only add our own match length now:\n                this.offset += match_str_len;\n                this._more = false;\n                this._backtrack = false;\n                this._input = this._input.slice(match_str_len);\n                // calling this method:\n                //\n                //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}\n                token = this.performAction.call(this, this.yy, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n                // otherwise, when the action codes are all simple return token statements:\n                //token = this.simpleCaseActionClusters[indexed_rule];\n                if (this.done && this._input) {\n                    this.done = false;\n                }\n                if (token) {\n                    return token;\n                } else if (this._backtrack) {\n                    // recover context\n                    for(var k in backup){\n                        this[k] = backup[k];\n                    }\n                    this.__currentRuleSet__ = null;\n                    return false; // rule action called reject() implying the next rule should be tested instead. \n                } else if (this._signaled_error_token) {\n                    // produce one 'error' token as `.parseError()` in `reject()`\n                    // did not guarantee a failure signal by throwing an exception!\n                    token = this._signaled_error_token;\n                    this._signaled_error_token = false;\n                    return token;\n                }\n                return false;\n            },\n            /**\n     * return next match in input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ next: function lexer_next() {\n                if (this.done) {\n                    this.clear();\n                    return this.EOF;\n                }\n                if (!this._input) {\n                    this.done = true;\n                }\n                var token, match, tempMatch, index;\n                if (!this._more) {\n                    this.clear();\n                }\n                var spec = this.__currentRuleSet__;\n                if (!spec) {\n                    // Update the ruleset cache as we apparently encountered a state change or just started lexing.\n                    // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will\n                    // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps\n                    // speed up those activities a tiny bit.\n                    spec = this.__currentRuleSet__ = this._currentRules();\n                    // Check whether a *sane* condition has been pushed before: this makes the lexer robust against\n                    // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19\n                    if (!spec || !spec.rules) {\n                        var lineno_msg = \"\";\n                        if (this.options.trackPosition) {\n                            lineno_msg = \" on line \" + (this.yylineno + 1);\n                        }\n                        var p = this.constructLexErrorInfo(\"Internal lexer engine error\" + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name \"' + this.topState() + '\"; this is a fatal error and should be reported to the application programmer team!', false);\n                        // produce one 'error' token until this situation has been resolved, most probably by parse termination!\n                        return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n                    }\n                }\n                var rule_ids = spec.rules;\n                var regexes = spec.__rule_regexes;\n                var len = spec.__rule_count;\n                // Note: the arrays are 1-based, while `len` itself is a valid index,\n                // hence the non-standard less-or-equal check in the next loop condition!\n                for(var i = 1; i <= len; i++){\n                    tempMatch = this._input.match(regexes[i]);\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                        match = tempMatch;\n                        index = i;\n                        if (this.options.backtrack_lexer) {\n                            token = this.test_match(tempMatch, rule_ids[i]);\n                            if (token !== false) {\n                                return token;\n                            } else if (this._backtrack) {\n                                match = undefined;\n                                continue; // rule action called reject() implying a rule MISmatch. \n                            } else {\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                                return false;\n                            }\n                        } else if (!this.options.flex) {\n                            break;\n                        }\n                    }\n                }\n                if (match) {\n                    token = this.test_match(match, rule_ids[index]);\n                    if (token !== false) {\n                        return token;\n                    }\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                    return false;\n                }\n                if (!this._input) {\n                    this.done = true;\n                    this.clear();\n                    return this.EOF;\n                } else {\n                    var lineno_msg = \"\";\n                    if (this.options.trackPosition) {\n                        lineno_msg = \" on line \" + (this.yylineno + 1);\n                    }\n                    var p = this.constructLexErrorInfo(\"Lexical error\" + lineno_msg + \": Unrecognized text.\", this.options.lexerErrorsAreRecoverable);\n                    var pendingInput = this._input;\n                    var activeCondition = this.topState();\n                    var conditionStackDepth = this.conditionStack.length;\n                    token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n                    if (token === this.ERROR) {\n                        // we can try to recover from a lexer error that `parseError()` did not 'recover' for us\n                        // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`\n                        // has not consumed/modified any pending input or changed state in the error handler:\n                        if (!this.matches && // and make sure the input has been modified/consumed ...\n                        pendingInput === this._input && // ...or the lexer state has been modified significantly enough\n                        // to merit a non-consuming error handling action right now.\n                        activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {\n                            this.input();\n                        }\n                    }\n                    return token;\n                }\n            },\n            /**\n     * return next match that has a token\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ lex: function lexer_lex() {\n                var r;\n                // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:\n                if (typeof this.pre_lex === \"function\") {\n                    r = this.pre_lex.call(this, 0);\n                }\n                if (typeof this.options.pre_lex === \"function\") {\n                    // (also account for a userdef function which does not return any value: keep the token as is)\n                    r = this.options.pre_lex.call(this, r) || r;\n                }\n                if (this.yy && typeof this.yy.pre_lex === \"function\") {\n                    // (also account for a userdef function which does not return any value: keep the token as is)\n                    r = this.yy.pre_lex.call(this, r) || r;\n                }\n                while(!r){\n                    r = this.next();\n                }\n                if (this.yy && typeof this.yy.post_lex === \"function\") {\n                    // (also account for a userdef function which does not return any value: keep the token as is)\n                    r = this.yy.post_lex.call(this, r) || r;\n                }\n                if (typeof this.options.post_lex === \"function\") {\n                    // (also account for a userdef function which does not return any value: keep the token as is)\n                    r = this.options.post_lex.call(this, r) || r;\n                }\n                if (typeof this.post_lex === \"function\") {\n                    // (also account for a userdef function which does not return any value: keep the token as is)\n                    r = this.post_lex.call(this, r) || r;\n                }\n                return r;\n            },\n            /**\n     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the \n     * `pre_lex()` nor any of the `post_lex()` callbacks.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ fastLex: function lexer_fastLex() {\n                var r;\n                while(!r){\n                    r = this.next();\n                }\n                return r;\n            },\n            /**\n     * return info about the lexer state that can help a parser or other lexer API user to use the\n     * most efficient means available. This API is provided to aid run-time performance for larger\n     * systems which employ this lexer.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ canIUse: function lexer_canIUse() {\n                var rv = {\n                    fastLex: !(typeof this.pre_lex === \"function\" || typeof this.options.pre_lex === \"function\" || this.yy && typeof this.yy.pre_lex === \"function\" || this.yy && typeof this.yy.post_lex === \"function\" || typeof this.options.post_lex === \"function\" || typeof this.post_lex === \"function\") && typeof this.fastLex === \"function\"\n                };\n                return rv;\n            },\n            /**\n     * backwards compatible alias for `pushState()`;\n     * the latter is symmetrical with `popState()` and we advise to use\n     * those APIs in any modern lexer code, rather than `begin()`.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ begin: function lexer_begin(condition) {\n                return this.pushState(condition);\n            },\n            /**\n     * activates a new lexer condition state (pushes the new lexer\n     * condition state onto the condition stack)\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ pushState: function lexer_pushState(condition) {\n                this.conditionStack.push(condition);\n                this.__currentRuleSet__ = null;\n                return this;\n            },\n            /**\n     * pop the previously active lexer condition state off the condition\n     * stack\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ popState: function lexer_popState() {\n                var n = this.conditionStack.length - 1;\n                if (n > 0) {\n                    this.__currentRuleSet__ = null;\n                    return this.conditionStack.pop();\n                } else {\n                    return this.conditionStack[0];\n                }\n            },\n            /**\n     * return the currently active lexer condition state; when an index\n     * argument is provided it produces the N-th previous condition state,\n     * if available\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ topState: function lexer_topState(n) {\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\n                if (n >= 0) {\n                    return this.conditionStack[n];\n                } else {\n                    return \"INITIAL\";\n                }\n            },\n            /**\n     * (internal) determine the lexer rule set which is active for the\n     * currently active lexer condition state\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ _currentRules: function lexer__currentRules() {\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]];\n                } else {\n                    return this.conditions[\"INITIAL\"];\n                }\n            },\n            /**\n     * return the number of states currently on the stack\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ stateStackSize: function lexer_stateStackSize() {\n                return this.conditionStack.length;\n            },\n            options: {\n                trackPosition: true\n            },\n            JisonLexerError: JisonLexerError,\n            performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {\n                var yy_ = this;\n                var YYSTATE = YY_START;\n                switch(yyrulenumber){\n                    case 1:\n                        break;\n                    default:\n                        return this.simpleCaseActionClusters[yyrulenumber];\n                }\n            },\n            simpleCaseActionClusters: {\n                /*! Conditions:: INITIAL */ /*! Rule::       (--[0-9a-z-A-Z-]*) */ 0: 13,\n                /*! Conditions:: INITIAL */ /*! Rule::       \\* */ 2: 5,\n                /*! Conditions:: INITIAL */ /*! Rule::       \\/ */ 3: 6,\n                /*! Conditions:: INITIAL */ /*! Rule::       \\+ */ 4: 3,\n                /*! Conditions:: INITIAL */ /*! Rule::       - */ 5: 4,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)px\\b */ 6: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)cm\\b */ 7: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)mm\\b */ 8: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)in\\b */ 9: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pt\\b */ 10: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pc\\b */ 11: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)deg\\b */ 12: 16,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)grad\\b */ 13: 16,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rad\\b */ 14: 16,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)turn\\b */ 15: 16,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)s\\b */ 16: 17,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ms\\b */ 17: 17,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)Hz\\b */ 18: 18,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)kHz\\b */ 19: 18,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpi\\b */ 20: 19,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpcm\\b */ 21: 19,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dppx\\b */ 22: 19,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)em\\b */ 23: 20,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ex\\b */ 24: 21,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ch\\b */ 25: 22,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rem\\b */ 26: 23,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vw\\b */ 27: 25,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vh\\b */ 28: 24,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmin\\b */ 29: 26,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmax\\b */ 30: 27,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)% */ 31: 28,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)\\b */ 32: 11,\n                /*! Conditions:: INITIAL */ /*! Rule::       (calc) */ 33: 9,\n                /*! Conditions:: INITIAL */ /*! Rule::       (var) */ 34: 12,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([a-z]+) */ 35: 10,\n                /*! Conditions:: INITIAL */ /*! Rule::       \\( */ 36: 7,\n                /*! Conditions:: INITIAL */ /*! Rule::       \\) */ 37: 8,\n                /*! Conditions:: INITIAL */ /*! Rule::       , */ 38: 14,\n                /*! Conditions:: INITIAL */ /*! Rule::       $ */ 39: 1\n            },\n            rules: [\n                /*  0: */ /^(?:(--[\\d\\-A-Za-z]*))/,\n                /*  1: */ /^(?:\\s+)/,\n                /*  2: */ /^(?:\\*)/,\n                /*  3: */ /^(?:\\/)/,\n                /*  4: */ /^(?:\\+)/,\n                /*  5: */ /^(?:-)/,\n                /*  6: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)px\\b)/,\n                /*  7: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)cm\\b)/,\n                /*  8: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)mm\\b)/,\n                /*  9: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)in\\b)/,\n                /* 10: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pt\\b)/,\n                /* 11: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pc\\b)/,\n                /* 12: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)deg\\b)/,\n                /* 13: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)grad\\b)/,\n                /* 14: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rad\\b)/,\n                /* 15: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)turn\\b)/,\n                /* 16: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)s\\b)/,\n                /* 17: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ms\\b)/,\n                /* 18: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)Hz\\b)/,\n                /* 19: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)kHz\\b)/,\n                /* 20: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpi\\b)/,\n                /* 21: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpcm\\b)/,\n                /* 22: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dppx\\b)/,\n                /* 23: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)em\\b)/,\n                /* 24: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ex\\b)/,\n                /* 25: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ch\\b)/,\n                /* 26: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rem\\b)/,\n                /* 27: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vw\\b)/,\n                /* 28: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vh\\b)/,\n                /* 29: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmin\\b)/,\n                /* 30: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmax\\b)/,\n                /* 31: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)%)/,\n                /* 32: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)\\b)/,\n                /* 33: */ /^(?:(calc))/,\n                /* 34: */ /^(?:(var))/,\n                /* 35: */ /^(?:([a-z]+))/,\n                /* 36: */ /^(?:\\()/,\n                /* 37: */ /^(?:\\))/,\n                /* 38: */ /^(?:,)/,\n                /* 39: */ /^(?:$)/\n            ],\n            conditions: {\n                \"INITIAL\": {\n                    rules: [\n                        0,\n                        1,\n                        2,\n                        3,\n                        4,\n                        5,\n                        6,\n                        7,\n                        8,\n                        9,\n                        10,\n                        11,\n                        12,\n                        13,\n                        14,\n                        15,\n                        16,\n                        17,\n                        18,\n                        19,\n                        20,\n                        21,\n                        22,\n                        23,\n                        24,\n                        25,\n                        26,\n                        27,\n                        28,\n                        29,\n                        30,\n                        31,\n                        32,\n                        33,\n                        34,\n                        35,\n                        36,\n                        37,\n                        38,\n                        39\n                    ],\n                    inclusive: true\n                }\n            }\n        };\n        return lexer;\n    }();\n    parser.lexer = lexer;\n    function Parser() {\n        this.yy = {};\n    }\n    Parser.prototype = parser;\n    parser.Parser = Parser;\n    return new Parser();\n}();\nif (true) {\n    exports.parser = parser;\n    exports.Parser = parser.Parser;\n    exports.parse = function() {\n        return parser.parse.apply(parser, arguments);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVkdWNlLWNzcy1jYWxjQDIuMS44L25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvZGlzdC9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQ0EsdUNBQXVDLEdBRXZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcVhDLEdBSVcsSUFBSUEsU0FBUztJQUd6QixZQUFZO0lBQ1osc0dBQXNHO0lBQ3RHLGtHQUFrRztJQUNsRyw4RUFBOEU7SUFDOUUsU0FBU0MsaUJBQWlCQyxHQUFHLEVBQUVDLElBQUk7UUFDL0JDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxVQUFVO1lBQ1ZDLE9BQU87UUFDWDtRQUVBLElBQUlOLE9BQU8sTUFBTUEsTUFBTTtRQUV2QkUsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxXQUFXO1lBQ25DQyxZQUFZO1lBQ1pDLFVBQVU7WUFDVkMsT0FBT047UUFDWDtRQUVBLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUVaLElBQUlNO1FBQ0osSUFBSU4sUUFBUUEsS0FBS08sU0FBUyxZQUFZQyxPQUFPO1lBQ3pDLElBQUlDLE1BQU1U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cy1jYWxjQDIuMS44L25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvZGlzdC9wYXJzZXIuanM/NmYyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHBhcnNlciBnZW5lcmF0ZWQgYnkgamlzb24gMC42LjEtMjE1ICovXG5cbi8qXG4gKiBSZXR1cm5zIGEgUGFyc2VyIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqXG4gKiAgUGFyc2VyOiB7XG4gKiAgICB5eToge30gICAgIFRoZSBzby1jYWxsZWQgXCJzaGFyZWQgc3RhdGVcIiBvciByYXRoZXIgdGhlICpzb3VyY2UqIG9mIGl0O1xuICogICAgICAgICAgICAgICB0aGUgcmVhbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWAgcGFzc2VkIGFyb3VuZCB0b1xuICogICAgICAgICAgICAgICB0aGUgcnVsZSBhY3Rpb25zLCBldGMuIGlzIGEgZGVyaXZhdGl2ZS9jb3B5IG9mIHRoaXMgb25lLFxuICogICAgICAgICAgICAgICBub3QgYSBkaXJlY3QgcmVmZXJlbmNlIVxuICogIH1cbiAqXG4gKiAgUGFyc2VyLnByb3RvdHlwZToge1xuICogICAgeXk6IHt9LFxuICogICAgRU9GOiAxLFxuICogICAgVEVSUk9SOiAyLFxuICpcbiAqICAgIHRyYWNlOiBmdW5jdGlvbihlcnJvck1lc3NhZ2UsIC4uLiksXG4gKlxuICogICAgSmlzb25QYXJzZXJFcnJvcjogZnVuY3Rpb24obXNnLCBoYXNoKSxcbiAqXG4gKiAgICBxdW90ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdXNlciBjb2RlIGxhdGVyIG9uOiBwdXQgc3VpdGFibGVcbiAqICAgICAgICAgICAgICAgcXVvdGVzIGFyb3VuZCBsaXRlcmFsIElEcyBpbiBhIGRlc2NyaXB0aW9uIHN0cmluZy5cbiAqXG4gKiAgICBvcmlnaW5hbFF1b3RlTmFtZTogZnVuY3Rpb24obmFtZSksXG4gKiAgICAgICAgICAgICAgIFRoZSBiYXNpYyBxdW90ZU5hbWUgaGFuZGxlciBwcm92aWRlZCBieSBKSVNPTi5cbiAqICAgICAgICAgICAgICAgYGNsZWFudXBBZnRlclBhcnNlKClgIHdpbGwgY2xlYW4gdXAgYW5kIHJlc2V0IGBxdW90ZU5hbWUoKWAgdG8gcmVmZXJlbmNlIHRoaXMgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgYXQgdGhlIGVuZCBvZiB0aGUgYHBhcnNlKClgLlxuICpcbiAqICAgIGRlc2NyaWJlU3ltYm9sOiBmdW5jdGlvbihzeW1ib2wpLFxuICogICAgICAgICAgICAgICBSZXR1cm4gYSBtb3JlLW9yLWxlc3MgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGdpdmVuIHN5bWJvbCwgd2hlblxuICogICAgICAgICAgICAgICBhdmFpbGFibGUsIG9yIHRoZSBzeW1ib2wgaXRzZWxmLCBzZXJ2aW5nIGFzIGl0cyBvd24gJ2Rlc2NyaXB0aW9uJyBmb3IgbGFja1xuICogICAgICAgICAgICAgICBvZiBzb21ldGhpbmcgYmV0dGVyIHRvIHNlcnZlIHVwLlxuICpcbiAqICAgICAgICAgICAgICAgUmV0dXJuIE5VTEwgd2hlbiB0aGUgc3ltYm9sIGlzIHVua25vd24gdG8gdGhlIHBhcnNlci5cbiAqXG4gKiAgICBzeW1ib2xzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IG51bWJlcn0sXG4gKiAgICB0ZXJtaW5hbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbnVtYmVyID09PiBuYW1lfSxcbiAqICAgIG5vbnRlcm1pbmFsczoge2Fzc29jaWF0aXZlIGxpc3Q6IHJ1bGUtbmFtZSA9PT4ge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gcnVsZS1hbHR9fSxcbiAqICAgIHRlcm1pbmFsX2Rlc2NyaXB0aW9uc186IChpZiB0aGVyZSBhcmUgYW55KSB7YXNzb2NpYXRpdmUgbGlzdDogbnVtYmVyID09PiBkZXNjcmlwdGlvbn0sXG4gKiAgICBwcm9kdWN0aW9uc186IFsuLi5dLFxuICpcbiAqICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIHBhcnNlcl9fcGVyZm9ybUFjdGlvbih5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5bG9jLCB5eXN0YXRlLCB5eXNwLCB5eXZzdGFjaywgeXlsc3RhY2ssIHl5c3RhY2ssIHl5c3N0YWNrKSxcbiAqXG4gKiAgICAgICAgICAgICAgIFRoZSBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFuZCBgdGhpc2AgaGF2ZSB0aGUgZm9sbG93aW5nIHZhbHVlL21lYW5pbmc6XG4gKiAgICAgICAgICAgICAgIC0gYHRoaXNgICAgIDogcmVmZXJlbmNlIHRvIHRoZSBgeXl2YWxgIGludGVybmFsIG9iamVjdCwgd2hpY2ggaGFzIG1lbWJlcnMgKGAkYCBhbmQgYF8kYClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzdG9yZS9yZWZlcmVuY2UgdGhlIHJ1bGUgdmFsdWUgYCQkYCBhbmQgbG9jYXRpb24gaW5mbyBgQCRgLlxuICpcbiAqICAgICAgICAgICAgICAgICBPbmUgaW1wb3J0YW50IHRoaW5nIHRvIG5vdGUgYWJvdXQgYHRoaXNgIGEuay5hLiBgeXl2YWxgOiBldmVyeSAqcmVkdWNlKiBhY3Rpb24gZ2V0c1xuICogICAgICAgICAgICAgICAgIHRvIHNlZSB0aGUgc2FtZSBvYmplY3QgdmlhIHRoZSBgdGhpc2AgcmVmZXJlbmNlLCBpLmUuIGlmIHlvdSB3aXNoIHRvIGNhcnJ5IGN1c3RvbVxuICogICAgICAgICAgICAgICAgIGRhdGEgZnJvbSBvbmUgcmVkdWNlIGFjdGlvbiB0aHJvdWdoIHRvIHRoZSBuZXh0IHdpdGhpbiBhIHNpbmdsZSBwYXJzZSBydW4sIHRoZW4geW91XG4gKiAgICAgICAgICAgICAgICAgbWF5IGdldCBuYXN0eSBhbmQgdXNlIGB5eXZhbGAgYS5rLmEuIGB0aGlzYCBmb3Igc3RvcmluZyB5b3Ugb3duIHNlbWktcGVybWFuZW50IGRhdGEuXG4gKlxuICogICAgICAgICAgICAgICAgIGB0aGlzLnl5YCBpcyBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIGB5eWAgc2hhcmVkIHN0YXRlIG9iamVjdC5cbiAqXG4gKiAgICAgICAgICAgICAgICAgYCVwYXJzZS1wYXJhbWAtc3BlY2lmaWVkIGFkZGl0aW9uYWwgYHBhcnNlKClgIGFyZ3VtZW50cyBoYXZlIGJlZW4gYWRkZWQgdG8gdGhpcyBgeXlgXG4gKiAgICAgICAgICAgICAgICAgb2JqZWN0IGF0IGBwYXJzZSgpYCBzdGFydCBhbmQgYXJlIHRoZXJlZm9yZSBhdmFpbGFibGUgdG8gdGhlIGFjdGlvbiBjb2RlIHZpYSB0aGVcbiAqICAgICAgICAgICAgICAgICBzYW1lIG5hbWVkIGB5eS54eHh4YCBhdHRyaWJ1dGVzICh3aGVyZSBgeHh4eGAgcmVwcmVzZW50cyBhIGlkZW50aWZpZXIgbmFtZSBmcm9tXG4gKiAgICAgICAgICAgICAgICAgdGhlICVwYXJzZS1wYXJhbWAgbGlzdC5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5dGV4dGAgIDogcmVmZXJlbmNlIHRvIHRoZSBsZXhlciB2YWx1ZSB3aGljaCBiZWxvbmdzIHRvIHRoZSBsYXN0IGxleGVyIHRva2VuIHVzZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBtYXRjaCB0aGlzIHJ1bGUuIFRoaXMgaXMgKm5vdCogdGhlIGxvb2stYWhlYWQgdG9rZW4sIGJ1dCB0aGUgbGFzdCB0b2tlblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQncyBhY3R1YWxseSBwYXJ0IG9mIHRoaXMgcnVsZS5cbiAqXG4gKiAgICAgICAgICAgICAgICAgRm9ybXVsYXRlZCBhbm90aGVyIHdheSwgYHl5dGV4dGAgaXMgdGhlIHZhbHVlIG9mIHRoZSB0b2tlbiBpbW1lZGlhdGVseSBwcmVjZWVkaW5nXG4gKiAgICAgICAgICAgICAgICAgdGhlIGN1cnJlbnQgbG9vay1haGVhZCB0b2tlbi5cbiAqICAgICAgICAgICAgICAgICBDYXZlYXRzIGFwcGx5IGZvciBydWxlcyB3aGljaCBkb24ndCByZXF1aXJlIGxvb2stYWhlYWQsIHN1Y2ggYXMgZXBzaWxvbiBydWxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5bGVuZ2AgIDogZGl0dG8gYXMgYHl5dGV4dGAsIG9ubHkgbm93IGZvciB0aGUgbGV4ZXIueXlsZW5nIHZhbHVlLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlsaW5lbm9gOiBkaXR0byBhcyBgeXl0ZXh0YCwgb25seSBub3cgZm9yIHRoZSBsZXhlci55eWxpbmVubyB2YWx1ZS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5bG9jYCAgIDogZGl0dG8gYXMgYHl5dGV4dGAsIG9ubHkgbm93IGZvciB0aGUgbGV4ZXIueXlsbG9jIGxleGVyIHRva2VuIGxvY2F0aW9uIGluZm8uXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV0FSTklORzogc2luY2Ugamlzb24gMC40LjE4LTE4NiB0aGlzIGVudHJ5IG1heSBiZSBOVUxML1VOREVGSU5FRCBpbnN0ZWFkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBhbiBlbXB0eSBvYmplY3Qgd2hlbiBubyBzdWl0YWJsZSBsb2NhdGlvbiBpbmZvIGNhbiBiZSBwcm92aWRlZC5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5c3RhdGVgIDogdGhlIGN1cnJlbnQgcGFyc2VyIHN0YXRlIG51bWJlciwgdXNlZCBpbnRlcm5hbGx5IGZvciBkaXNwYXRjaGluZyBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGluZyB0aGUgYWN0aW9uIGNvZGUgY2h1bmsgbWF0Y2hpbmcgdGhlIHJ1bGUgY3VycmVudGx5IGJlaW5nIHJlZHVjZWQuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXNwYCAgICA6IHRoZSBjdXJyZW50IHN0YXRlIHN0YWNrIHBvc2l0aW9uIChhLmsuYS4gJ3N0YWNrIHBvaW50ZXInKVxuICpcbiAqICAgICAgICAgICAgICAgICBUaGlzIG9uZSBjb21lcyBpbiBoYW5keSB3aGVuIHlvdSBhcmUgZ29pbmcgdG8gZG8gYWR2YW5jZWQgdGhpbmdzIHRvIHRoZSBwYXJzZXJcbiAqICAgICAgICAgICAgICAgICBzdGFja3MsIGFsbCBvZiB3aGljaCBhcmUgYWNjZXNzaWJsZSBmcm9tIHlvdXIgYWN0aW9uIGNvZGUgKHNlZSB0aGUgbmV4dCBlbnRyaWVzIGJlbG93KS5cbiAqXG4gKiAgICAgICAgICAgICAgICAgQWxzbyBub3RlIHRoYXQgeW91IGNhbiBhY2Nlc3MgdGhpcyBhbmQgb3RoZXIgc3RhY2sgaW5kZXggdmFsdWVzIHVzaW5nIHRoZSBuZXcgZG91YmxlLWhhc2hcbiAqICAgICAgICAgICAgICAgICBzeW50YXgsIGkuZS4gYCMjJCA9PT0gIyMwID09PSB5eXNwYCwgd2hpbGUgYCMjMWAgaXMgdGhlIHN0YWNrIGluZGV4IGZvciBhbGwgdGhpbmdzXG4gKiAgICAgICAgICAgICAgICAgcmVsYXRlZCB0byB0aGUgZmlyc3QgcnVsZSB0ZXJtLCBqdXN0IGxpa2UgeW91IGhhdmUgYCQxYCwgYEAxYCBhbmQgYCMxYC5cbiAqICAgICAgICAgICAgICAgICBUaGlzIGlzIG1hZGUgYXZhaWxhYmxlIHRvIHdyaXRlIHZlcnkgYWR2YW5jZWQgZ3JhbW1hciBhY3Rpb24gcnVsZXMsIGUuZy4gd2hlbiB5b3Ugd2FudFxuICogICAgICAgICAgICAgICAgIHRvIGludmVzdGlnYXRlIHRoZSBwYXJzZSBzdGF0ZSBzdGFjayBpbiB5b3VyIGFjdGlvbiBjb2RlLCB3aGljaCB3b3VsZCwgZm9yIGV4YW1wbGUsXG4gKiAgICAgICAgICAgICAgICAgYmUgcmVsZXZhbnQgd2hlbiB5b3Ugd2lzaCB0byBpbXBsZW1lbnQgZXJyb3IgZGlhZ25vc3RpY3MgYW5kIHJlcG9ydGluZyBzY2hlbWVzIHNpbWlsYXJcbiAqICAgICAgICAgICAgICAgICB0byB0aGUgd29yayBkZXNjcmliZWQgaGVyZTpcbiAqXG4gKiAgICAgICAgICAgICAgICAgKyBQb3R0aWVyLCBGLiwgMjAxNi4gUmVhY2hhYmlsaXR5IGFuZCBlcnJvciBkaWFnbm9zaXMgaW4gTFIoMSkgYXV0b21hdGEuXG4gKiAgICAgICAgICAgICAgICAgICBJbiBKb3VybsOpZXMgRnJhbmNvcGhvbmVzIGRlcyBMYW5ndWFnZXMgQXBwbGljYXRpZnMuXG4gKlxuICogICAgICAgICAgICAgICAgICsgSmVmZmVyeSwgQy5MLiwgMjAwMy4gR2VuZXJhdGluZyBMUiBzeW50YXggZXJyb3IgbWVzc2FnZXMgZnJvbSBleGFtcGxlcy5cbiAqICAgICAgICAgICAgICAgICAgIEFDTSBUcmFuc2FjdGlvbnMgb24gUHJvZ3JhbW1pbmcgTGFuZ3VhZ2VzIGFuZCBTeXN0ZW1zIChUT1BMQVMpLCAyNSg1KSwgcHAuNjMx4oCTNjQwLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlydWxlbGVuZ3RoYDogdGhlIGN1cnJlbnQgcnVsZSdzIHRlcm0gY291bnQsIGkuZS4gdGhlIG51bWJlciBvZiBlbnRyaWVzIG9jY3VwaWVkIG9uIHRoZSBzdGFjay5cbiAqXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBvbmUgY29tZXMgaW4gaGFuZHkgd2hlbiB5b3UgYXJlIGdvaW5nIHRvIGRvIGFkdmFuY2VkIHRoaW5ncyB0byB0aGUgcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgc3RhY2tzLCBhbGwgb2Ygd2hpY2ggYXJlIGFjY2Vzc2libGUgZnJvbSB5b3VyIGFjdGlvbiBjb2RlIChzZWUgdGhlIG5leHQgZW50cmllcyBiZWxvdykuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXZzdGFja2A6IHJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIHZhbHVlIHN0YWNrLiBBbHNvIGFjY2Vzc2VkIHZpYSB0aGUgYCQxYCBldGMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0cy5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5bHN0YWNrYDogcmVmZXJlbmNlIHRvIHRoZSBwYXJzZXIgdG9rZW4gbG9jYXRpb24gc3RhY2suIEFsc28gYWNjZXNzZWQgdmlhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGBAMWAgZXRjLiBjb25zdHJ1Y3RzLlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXQVJOSU5HOiBzaW5jZSBqaXNvbiAwLjQuMTgtMTg2IHRoaXMgYXJyYXkgTUFZIGNvbnRhaW4gc2xvdHMgd2hpY2ggYXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVU5ERUZJTkVEIHJhdGhlciB0aGFuIGFuIGVtcHR5IChsb2NhdGlvbikgb2JqZWN0LCB3aGVuIHRoZSBsZXhlci9wYXJzZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gY29kZSBkaWQgbm90IHByb3ZpZGUgYSBzdWl0YWJsZSBsb2NhdGlvbiBpbmZvIG9iamVjdCB3aGVuIHN1Y2ggYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Qgd2FzIGZpbGxlZCFcbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5c3RhY2tgIDogcmVmZXJlbmNlIHRvIHRoZSBwYXJzZXIgdG9rZW4gaWQgc3RhY2suIEFsc28gYWNjZXNzZWQgdmlhIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAjMWAgZXRjLiBjb25zdHJ1Y3RzLlxuICpcbiAqICAgICAgICAgICAgICAgICBOb3RlOiB0aGlzIGlzIGEgYml0IG9mIGEgKip3aGl0ZSBsaWUqKiBhcyB3ZSBjYW4gc3RhdGljYWxseSBkZWNvZGUgYW55IGAjbmAgcmVmZXJlbmNlIHRvXG4gKiAgICAgICAgICAgICAgICAgaXRzIG51bWVyaWMgdG9rZW4gaWQgdmFsdWUsIGhlbmNlIHRoYXQgY29kZSB3b3VsZG4ndCBuZWVkIHRoZSBgeXlzdGFja2AgYnV0ICp5b3UqIG1pZ2h0XG4gKiAgICAgICAgICAgICAgICAgd2FudCBhY2Nlc3MgdGhpcyBhcnJheSBmb3IgeW91ciBvd24gcHVycG9zZXMsIHN1Y2ggYXMgZXJyb3IgYW5hbHlzaXMgYXMgbWVudGlvbmVkIGFib3ZlIVxuICpcbiAqICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgdGhpcyBzdGFjayBzdG9yZXMgdGhlIGN1cnJlbnQgc3RhY2sgb2YgKnRva2VucyosIHRoYXQgaXMgdGhlIHNlcXVlbmNlIG9mXG4gKiAgICAgICAgICAgICAgICAgYWxyZWFkeSBwYXJzZWQ9cmVkdWNlZCAqbm9udGVybWluYWxzKiAodG9rZW5zIHJlcHJlc2VudGluZyBydWxlcykgYW5kICp0ZXJtaW5hbHMqXG4gKiAgICAgICAgICAgICAgICAgKGxleGVyIHRva2VucyAqc2hpZnRlZCogb250byB0aGUgc3RhY2sgdW50aWwgdGhlIHJ1bGUgdGhleSBiZWxvbmcgdG8gaXMgZm91bmQgYW5kXG4gKiAgICAgICAgICAgICAgICAgKnJlZHVjZWQqLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlzc3RhY2tgOiByZWZlcmVuY2UgdG8gdGhlIHBhcnNlciBzdGF0ZSBzdGFjay4gVGhpcyBvbmUgY2FycmllcyB0aGUgaW50ZXJuYWwgcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKnN0YXRlcyogc3VjaCBhcyB0aGUgb25lIGluIGB5eXN0YXRlYCwgd2hpY2ggYXJlIHVzZWQgdG8gcmVwcmVzZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGluIHRoZSAqcGFyc2UgdGFibGUqLiAqVmVyeSogKmludGVybmFsKiBzdHVmZixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGF0IGNhbiBJIHNheT8gSWYgeW91IGFjY2VzcyB0aGlzIG9uZSwgeW91J3JlIGNsZWFybHkgZG9pbmcgd2lja2VkIHRoaW5nc1xuICpcbiAqICAgICAgICAgICAgICAgLSBgLi4uYCAgICAgOiB0aGUgZXh0cmEgYXJndW1lbnRzIHlvdSBzcGVjaWZpZWQgaW4gdGhlIGAlcGFyc2UtcGFyYW1gIHN0YXRlbWVudCBpbiB5b3VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbW1hciBkZWZpbml0aW9uIGZpbGUuXG4gKlxuICogICAgdGFibGU6IFsuLi5dLFxuICogICAgICAgICAgICAgICBTdGF0ZSB0cmFuc2l0aW9uIHRhYmxlXG4gKiAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAgICAgICAgICAgICAgIGluZGV4IGxldmVscyBhcmU6XG4gKiAgICAgICAgICAgICAgIC0gYHN0YXRlYCAgLS0+IGhhc2ggdGFibGVcbiAqICAgICAgICAgICAgICAgLSBgc3ltYm9sYCAtLT4gYWN0aW9uIChudW1iZXIgb3IgYXJyYXkpXG4gKlxuICogICAgICAgICAgICAgICAgIElmIHRoZSBgYWN0aW9uYCBpcyBhbiBhcnJheSwgdGhlc2UgYXJlIHRoZSBlbGVtZW50cycgbWVhbmluZzpcbiAqICAgICAgICAgICAgICAgICAtIGluZGV4IFswXTogMSA9IHNoaWZ0LCAyID0gcmVkdWNlLCAzID0gYWNjZXB0XG4gKiAgICAgICAgICAgICAgICAgLSBpbmRleCBbMV06IEdPVE8gYHN0YXRlYFxuICpcbiAqICAgICAgICAgICAgICAgICBJZiB0aGUgYGFjdGlvbmAgaXMgYSBudW1iZXIsIGl0IGlzIHRoZSBHT1RPIGBzdGF0ZWBcbiAqXG4gKiAgICBkZWZhdWx0QWN0aW9uczogey4uLn0sXG4gKlxuICogICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcyksXG4gKiAgICB5eUVycm9yOiBmdW5jdGlvbihzdHIsIC4uLiksXG4gKiAgICB5eVJlY292ZXJpbmc6IGZ1bmN0aW9uKCksXG4gKiAgICB5eUVyck9rOiBmdW5jdGlvbigpLFxuICogICAgeXlDbGVhckluOiBmdW5jdGlvbigpLFxuICpcbiAqICAgIGNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvOiBmdW5jdGlvbihlcnJvcl9tZXNzYWdlLCBleGNlcHRpb25fb2JqZWN0LCBleHBlY3RlZF90b2tlbl9zZXQsIGlzX3JlY292ZXJhYmxlKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uICoqd2hpY2ggd2lsbCBiZSBzZXQgdXAgZHVyaW5nIHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIHRoZSBgcGFyc2UoKWAgbWV0aG9kKiouXG4gKiAgICAgICAgICAgICAgIFByb2R1Y2VzIGEgbmV3IGVycm9ySW5mbyAnaGFzaCBvYmplY3QnIHdoaWNoIGNhbiBiZSBwYXNzZWQgaW50byBgcGFyc2VFcnJvcigpYC5cbiAqICAgICAgICAgICAgICAgU2VlIGl0J3MgdXNlIGluIHRoaXMgcGFyc2VyIGtlcm5lbCBpbiBtYW55IHBsYWNlczsgZXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICB2YXIgaW5mb09iaiA9IHBhcnNlci5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbygnZmFpbCEnLCBudWxsLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbGxlY3RfZXhwZWN0ZWRfdG9rZW5fc2V0KHN0YXRlKSwgdHJ1ZSk7XG4gKiAgICAgICAgICAgICAgICAgICB2YXIgcmV0VmFsID0gcGFyc2VyLnBhcnNlRXJyb3IoaW5mb09iai5lcnJTdHIsIGluZm9PYmosIHBhcnNlci5KaXNvblBhcnNlckVycm9yKTtcbiAqXG4gKiAgICBvcmlnaW5hbFBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpLFxuICogICAgICAgICAgICAgICBUaGUgYmFzaWMgYHBhcnNlRXJyb3JgIGhhbmRsZXIgcHJvdmlkZWQgYnkgSklTT04uXG4gKiAgICAgICAgICAgICAgIGBjbGVhbnVwQWZ0ZXJQYXJzZSgpYCB3aWxsIGNsZWFuIHVwIGFuZCByZXNldCBgcGFyc2VFcnJvcigpYCB0byByZWZlcmVuY2UgdGhpcyBmdW5jdGlvblxuICogICAgICAgICAgICAgICBhdCB0aGUgZW5kIG9mIHRoZSBgcGFyc2UoKWAuXG4gKlxuICogICAgb3B0aW9uczogeyAuLi4gcGFyc2VyICVvcHRpb25zIC4uLiB9LFxuICpcbiAqICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dFssIGFyZ3MuLi5dKSxcbiAqICAgICAgICAgICAgICAgUGFyc2UgdGhlIGdpdmVuIGBpbnB1dGAgYW5kIHJldHVybiB0aGUgcGFyc2VkIHZhbHVlIChvciBgdHJ1ZWAgd2hlbiBub25lIHdhcyBwcm92aWRlZCBieVxuICogICAgICAgICAgICAgICB0aGUgcm9vdCBhY3Rpb24sIGluIHdoaWNoIGNhc2UgdGhlIHBhcnNlciBpcyBhY3RpbmcgYXMgYSAqbWF0Y2hlciopLlxuICogICAgICAgICAgICAgICBZb3UgTUFZIHVzZSB0aGUgYWRkaXRpb25hbCBgYXJncy4uLmAgcGFyYW1ldGVycyBhcyBwZXIgYCVwYXJzZS1wYXJhbWAgc3BlYyBvZiB0aGlzIGdyYW1tYXI6XG4gKiAgICAgICAgICAgICAgIHRoZXNlIGV4dHJhIGBhcmdzLi4uYCBhcmUgYWRkZWQgdmVyYmF0aW0gdG8gdGhlIGB5eWAgb2JqZWN0IHJlZmVyZW5jZSBhcyBtZW1iZXIgdmFyaWFibGVzLlxuICpcbiAqICAgICAgICAgICAgICAgV0FSTklORzpcbiAqICAgICAgICAgICAgICAgUGFyc2VyJ3MgYWRkaXRpb25hbCBgYXJncy4uLmAgcGFyYW1ldGVycyAodmlhIGAlcGFyc2UtcGFyYW1gKSBNQVkgY29uZmxpY3Qgd2l0aFxuICogICAgICAgICAgICAgICBhbnkgYXR0cmlidXRlcyBhbHJlYWR5IGFkZGVkIHRvIGB5eWAgYnkgdGhlIGppc29uIHJ1bi10aW1lO1xuICogICAgICAgICAgICAgICB3aGVuIHN1Y2ggYSBjb2xsaXNpb24gaXMgZGV0ZWN0ZWQgYW4gZXhjZXB0aW9uIGlzIHRocm93biB0byBwcmV2ZW50IHRoZSBnZW5lcmF0ZWQgcnVuLXRpbWVcbiAqICAgICAgICAgICAgICAgZnJvbSBzaWxlbnRseSBhY2NlcHRpbmcgdGhpcyBjb25mdXNpbmcgYW5kIHBvdGVudGlhbGx5IGhhemFyZG91cyBzaXR1YXRpb24hXG4gKlxuICogICAgICAgICAgICAgICBUaGUgbGV4ZXIgTUFZIGFkZCBpdHMgb3duIHNldCBvZiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgKHZpYSB0aGUgYCVwYXJzZS1wYXJhbWAgbGluZSBpblxuICogICAgICAgICAgICAgICB0aGUgbGV4ZXIgc2VjdGlvbiBvZiB0aGUgZ3JhbW1hciBzcGVjKTogdGhlc2Ugd2lsbCBiZSBpbnNlcnRlZCBpbiB0aGUgYHl5YCBzaGFyZWQgc3RhdGVcbiAqICAgICAgICAgICAgICAgb2JqZWN0IGFuZCBhbnkgY29sbGlzaW9uIHdpdGggdGhvc2Ugd2lsbCBiZSByZXBvcnRlZCBieSB0aGUgbGV4ZXIgdmlhIGEgdGhyb3duIGV4Y2VwdGlvbi5cbiAqXG4gKiAgICBjbGVhbnVwQWZ0ZXJQYXJzZTogZnVuY3Rpb24ocmVzdWx0VmFsdWUsIGludm9rZV9wb3N0X21ldGhvZHMsIGRvX25vdF9udWtlX2Vycm9yaW5mb3MpLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24gKip3aGljaCB3aWxsIGJlIHNldCB1cCBkdXJpbmcgdGhlIGZpcnN0IGludm9jYXRpb24gb2YgdGhlIGBwYXJzZSgpYCBtZXRob2QqKi5cbiAqICAgICAgICAgICAgICAgVGhpcyBoZWxwZXIgQVBJIGlzIGludm9rZWQgYXQgdGhlIGVuZCBvZiB0aGUgYHBhcnNlKClgIGNhbGwsIHVubGVzcyBhbiBleGNlcHRpb24gd2FzIHRocm93blxuICogICAgICAgICAgICAgICBhbmQgYCVvcHRpb25zIG5vLXRyeS1jYXRjaGAgaGFzIGJlZW4gZGVmaW5lZCBmb3IgdGhpcyBncmFtbWFyOiBpbiB0aGF0IGNhc2UgdGhpcyBoZWxwZXIgTUFZXG4gKiAgICAgICAgICAgICAgIGJlIGludm9rZWQgYnkgY2FsbGluZyB1c2VyIGNvZGUgdG8gZW5zdXJlIHRoZSBgcG9zdF9wYXJzZWAgY2FsbGJhY2tzIGFyZSBpbnZva2VkIGFuZFxuICogICAgICAgICAgICAgICB0aGUgaW50ZXJuYWwgcGFyc2VyIGdldHMgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0ZWQgdW5kZXIgdGhlc2UgcGFydGljdWxhciBjaXJjdW1zdGFuY2VzLlxuICpcbiAqICAgIHl5TWVyZ2VMb2NhdGlvbkluZm86IGZ1bmN0aW9uKGZpcnN0X2luZGV4LCBsYXN0X2luZGV4LCBmaXJzdF95eWxsb2MsIGxhc3RfeXlsbG9jLCBkb250X2xvb2tfYmFjayksXG4gKiAgICAgICAgICAgICAgIEhlbHBlciBmdW5jdGlvbiAqKndoaWNoIHdpbGwgYmUgc2V0IHVwIGR1cmluZyB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGUgYHBhcnNlKClgIG1ldGhvZCoqLlxuICogICAgICAgICAgICAgICBUaGlzIGhlbHBlciBBUEkgY2FuIGJlIGludm9rZWQgdG8gY2FsY3VsYXRlIGEgc3Bhbm5pbmcgYHl5bGxvY2AgbG9jYXRpb24gaW5mbyBvYmplY3QuXG4gKlxuICogICAgICAgICAgICAgICBOb3RlOiAlZXBzaWxvbiBydWxlcyBNQVkgc3BlY2lmeSBubyBgZmlyc3RfaW5kZXhgIGFuZCBgZmlyc3RfeXlsbG9jYCwgaW4gd2hpY2ggY2FzZVxuICogICAgICAgICAgICAgICB0aGlzIGZ1bmN0aW9uIHdpbGwgYXR0ZW1wdCB0byBvYnRhaW4gYSBzdWl0YWJsZSBsb2NhdGlvbiBtYXJrZXIgYnkgaW5zcGVjdGluZyB0aGUgbG9jYXRpb24gc3RhY2tcbiAqICAgICAgICAgICAgICAgYmFja3dhcmRzLlxuICpcbiAqICAgICAgICAgICAgICAgRm9yIG1vcmUgaW5mbyBzZWUgdGhlIGRvY3VtZW50YXRpb24gY29tbWVudCBmdXJ0aGVyIGJlbG93LCBpbW1lZGlhdGVseSBhYm92ZSB0aGlzIGZ1bmN0aW9uJ3NcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogICAgbGV4ZXI6IHtcbiAqICAgICAgICB5eTogey4uLn0sICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgc28tY2FsbGVkIFwic2hhcmVkIHN0YXRlXCIgYHl5YCBvbmNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQgdmlhIGEgY2FsbCB0byB0aGUgYC5zZXRJbnB1dChpbnB1dCwgeXkpYCBsZXhlciBBUEkuXG4gKiAgICAgICAgRU9GOiAxLFxuICogICAgICAgIEVSUk9SOiAyLFxuICogICAgICAgIEppc29uTGV4ZXJFcnJvcjogZnVuY3Rpb24obXNnLCBoYXNoKSxcbiAqICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSxcbiAqICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24oaW5wdXQsIFt5eV0pLFxuICogICAgICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICogICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICogICAgICAgIG1vcmU6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgcmVqZWN0OiBmdW5jdGlvbigpLFxuICogICAgICAgIGxlc3M6IGZ1bmN0aW9uKG4pLFxuICogICAgICAgIHBhc3RJbnB1dDogZnVuY3Rpb24obiksXG4gKiAgICAgICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24obiksXG4gKiAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLFxuICogICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4LCAuLi4pLFxuICogICAgICAgIG5leHQ6IGZ1bmN0aW9uKC4uLiksXG4gKiAgICAgICAgbGV4OiBmdW5jdGlvbiguLi4pLFxuICogICAgICAgIGJlZ2luOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICogICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAqICAgICAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAqICAgICAgICB0b3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAqICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbigpLFxuICogICAgICAgIHN0YXRlU3RhY2tTaXplOiBmdW5jdGlvbigpLFxuICogICAgICAgIGNsZWFudXBBZnRlckxleDogZnVuY3Rpb24oKVxuICpcbiAqICAgICAgICBvcHRpb25zOiB7IC4uLiBsZXhlciAlb3B0aW9ucyAuLi4gfSxcbiAqXG4gKiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQsIC4uLiksXG4gKiAgICAgICAgcnVsZXM6IFsuLi5dLFxuICogICAgICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICogICAgfVxuICogIH1cbiAqXG4gKlxuICogIHRva2VuIGxvY2F0aW9uIGluZm8gKEAkLCBfJCwgZXRjLik6IHtcbiAqICAgIGZpcnN0X2xpbmU6IG4sXG4gKiAgICBsYXN0X2xpbmU6IG4sXG4gKiAgICBmaXJzdF9jb2x1bW46IG4sXG4gKiAgICBsYXN0X2NvbHVtbjogbixcbiAqICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXVxuICogICAgICAgICAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCB6ZXJvLWJhc2VkKVxuICogIH1cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGUgYHBhcnNlRXJyb3JgIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGFuZFxuICogcGFyc2VyIGVycm9yczpcbiAqXG4gKiAge1xuICogICAgdGV4dDogICAgICAgIChtYXRjaGVkIHRleHQpXG4gKiAgICB0b2tlbjogICAgICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiwgaWYgYW55KVxuICogICAgdG9rZW5faWQ6ICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4gbnVtZXJpYyBJRCwgaWYgYW55KVxuICogICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAqICAgIGxvYzogICAgICAgICAoeXlsbG9jKVxuICogIH1cbiAqXG4gKiBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBhZGRpdGlvbmFsIG1lbWJlcnM6XG4gKlxuICogIHtcbiAqICAgIGV4cGVjdGVkOiAgICAoYXJyYXkgZGVzY3JpYmluZyB0aGUgc2V0IG9mIGV4cGVjdGVkIHRva2VucztcbiAqICAgICAgICAgICAgICAgICAgbWF5IGJlIFVOREVGSU5FRCB3aGVuIHdlIGNhbm5vdCBlYXNpbHkgcHJvZHVjZSBzdWNoIGEgc2V0KVxuICogICAgc3RhdGU6ICAgICAgIChpbnRlZ2VyIChvciBhcnJheSB3aGVuIHRoZSB0YWJsZSBpbmNsdWRlcyBncmFtbWFyIGNvbGxpc2lvbnMpO1xuICogICAgICAgICAgICAgICAgICByZXByZXNlbnRzIHRoZSBjdXJyZW50IGludGVybmFsIHN0YXRlIG9mIHRoZSBwYXJzZXIga2VybmVsLlxuICogICAgICAgICAgICAgICAgICBjYW4sIGZvciBleGFtcGxlLCBiZSB1c2VkIHRvIHBhc3MgdG8gdGhlIGBjb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldCgpYFxuICogICAgICAgICAgICAgICAgICBBUEkgdG8gb2J0YWluIHRoZSBleHBlY3RlZCB0b2tlbiBzZXQpXG4gKiAgICBhY3Rpb246ICAgICAgKGludGVnZXI7IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgaW50ZXJuYWwgYWN0aW9uIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQpXG4gKiAgICBuZXdfc3RhdGU6ICAgKGludGVnZXI7IHJlcHJlc2VudHMgdGhlIG5leHQvcGxhbm5lZCBpbnRlcm5hbCBzdGF0ZSwgb25jZSB0aGUgY3VycmVudFxuICogICAgICAgICAgICAgICAgICBhY3Rpb24gaGFzIGV4ZWN1dGVkKVxuICogICAgcmVjb3ZlcmFibGU6IChib29sZWFuOiBUUlVFIHdoZW4gdGhlIHBhcnNlciBNQVkgaGF2ZSBhbiBlcnJvciByZWNvdmVyeSBydWxlXG4gKiAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVycm9yKVxuICogICAgc3RhdGVfc3RhY2s6IChhcnJheTogdGhlIGN1cnJlbnQgcGFyc2VyIExBTFIvTFIgaW50ZXJuYWwgc3RhdGUgc3RhY2s7IHRoaXMgY2FuIGJlIHVzZWQsXG4gKiAgICAgICAgICAgICAgICAgIGZvciBpbnN0YW5jZSwgZm9yIGFkdmFuY2VkIGVycm9yIGFuYWx5c2lzIGFuZCByZXBvcnRpbmcpXG4gKiAgICB2YWx1ZV9zdGFjazogKGFycmF5OiB0aGUgY3VycmVudCBwYXJzZXIgTEFMUi9MUiBpbnRlcm5hbCBgJCRgIHZhbHVlIHN0YWNrOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgbG9jYXRpb25fc3RhY2s6IChhcnJheTogdGhlIGN1cnJlbnQgcGFyc2VyIExBTFIvTFIgaW50ZXJuYWwgbG9jYXRpb24gc3RhY2s7IHRoaXMgY2FuIGJlIHVzZWQsXG4gKiAgICAgICAgICAgICAgICAgIGZvciBpbnN0YW5jZSwgZm9yIGFkdmFuY2VkIGVycm9yIGFuYWx5c2lzIGFuZCByZXBvcnRpbmcpXG4gKiAgICB5eTogICAgICAgICAgKG9iamVjdDogdGhlIGN1cnJlbnQgcGFyc2VyIGludGVybmFsIFwic2hhcmVkIHN0YXRlXCIgYHl5YFxuICogICAgICAgICAgICAgICAgICBhcyBpcyBhbHNvIGF2YWlsYWJsZSBpbiB0aGUgcnVsZSBhY3Rpb25zOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgbGV4ZXI6ICAgICAgIChyZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbGV4ZXIgaW5zdGFuY2UgdXNlZCBieSB0aGUgcGFyc2VyKVxuICogICAgcGFyc2VyOiAgICAgIChyZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGFyc2VyIGluc3RhbmNlKVxuICogIH1cbiAqXG4gKiB3aGlsZSBgdGhpc2Agd2lsbCByZWZlcmVuY2UgdGhlIGN1cnJlbnQgcGFyc2VyIGluc3RhbmNlLlxuICpcbiAqIFdoZW4gYHBhcnNlRXJyb3JgIGlzIGludm9rZWQgYnkgdGhlIGxleGVyLCBgdGhpc2Agd2lsbCBzdGlsbCByZWZlcmVuY2UgdGhlIHJlbGF0ZWQgKnBhcnNlcipcbiAqIGluc3RhbmNlLCB3aGlsZSB0aGVzZSBhZGRpdGlvbmFsIGBoYXNoYCBmaWVsZHMgd2lsbCBhbHNvIGJlIHByb3ZpZGVkOlxuICpcbiAqICB7XG4gKiAgICBsZXhlcjogICAgICAgKHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBsZXhlciBpbnN0YW5jZSB3aGljaCByZXBvcnRlZCB0aGUgZXJyb3IpXG4gKiAgfVxuICpcbiAqIFdoZW4gYHBhcnNlRXJyb3JgIGlzIGludm9rZWQgYnkgdGhlIHBhcnNlciBkdWUgdG8gYSAqKkphdmFTY3JpcHQgZXhjZXB0aW9uKiogYmVpbmcgZmlyZWRcbiAqIGZyb20gZWl0aGVyIHRoZSBwYXJzZXIgb3IgbGV4ZXIsIGB0aGlzYCB3aWxsIHN0aWxsIHJlZmVyZW5jZSB0aGUgcmVsYXRlZCAqcGFyc2VyKlxuICogaW5zdGFuY2UsIHdoaWxlIHRoZXNlIGFkZGl0aW9uYWwgYGhhc2hgIGZpZWxkcyB3aWxsIGFsc28gYmUgcHJvdmlkZWQ6XG4gKlxuICogIHtcbiAqICAgIGV4Y2VwdGlvbjogICAocmVmZXJlbmNlIHRvIHRoZSBleGNlcHRpb24gdGhyb3duKVxuICogIH1cbiAqXG4gKiBQbGVhc2UgZG8gbm90ZSB0aGF0IGluIHRoZSBsYXR0ZXIgc2l0dWF0aW9uLCB0aGUgYGV4cGVjdGVkYCBmaWVsZCB3aWxsIGJlIG9taXR0ZWQgYXNcbiAqIHRoaXMgdHlwZSBvZiBmYWlsdXJlIGlzIGFzc3VtZWQgbm90IHRvIGJlIGR1ZSB0byAqcGFyc2UgZXJyb3JzKiBidXQgcmF0aGVyIGR1ZSB0byB1c2VyXG4gKiBhY3Rpb24gY29kZSBpbiBlaXRoZXIgcGFyc2VyIG9yIGxleGVyIGZhaWxpbmcgdW5leHBlY3RlZGx5LlxuICpcbiAqIC0tLVxuICpcbiAqIFlvdSBjYW4gc3BlY2lmeSBwYXJzZXIgb3B0aW9ucyBieSBzZXR0aW5nIC8gbW9kaWZ5aW5nIHRoZSBgLnl5YCBvYmplY3Qgb2YgeW91ciBQYXJzZXIgaW5zdGFuY2UuXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBhdmFpbGFibGU6XG4gKlxuICogIyMjIG9wdGlvbnMgd2hpY2ggYXJlIGdsb2JhbCBmb3IgYWxsIHBhcnNlciBpbnN0YW5jZXNcbiAqXG4gKiAgUGFyc2VyLnByZV9wYXJzZTogZnVuY3Rpb24oeXkpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHlvdSBjYW4gc3BlY2lmeSBhIHByZV9wYXJzZSgpIGZ1bmN0aW9uIGluIHRoZSBjaHVuayBmb2xsb3dpbmdcbiAqICAgICAgICAgICAgICAgICB0aGUgZ3JhbW1hciwgaS5lLiBhZnRlciB0aGUgbGFzdCBgJSVgLlxuICogIFBhcnNlci5wb3N0X3BhcnNlOiBmdW5jdGlvbih5eSwgcmV0dmFsLCBwYXJzZUluZm8pIHsgcmV0dXJuIHJldHZhbDsgfVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB5b3UgY2FuIHNwZWNpZnkgYSBwb3N0X3BhcnNlKCkgZnVuY3Rpb24gaW4gdGhlIGNodW5rIGZvbGxvd2luZ1xuICogICAgICAgICAgICAgICAgIHRoZSBncmFtbWFyLCBpLmUuIGFmdGVyIHRoZSBsYXN0IGAlJWAuIFdoZW4gaXQgZG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZSxcbiAqICAgICAgICAgICAgICAgICB0aGUgcGFyc2VyIHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCBgcmV0dmFsYC5cbiAqXG4gKiAjIyMgb3B0aW9ucyB3aGljaCBjYW4gYmUgc2V0IHVwIHBlciBwYXJzZXIgaW5zdGFuY2VcbiAqXG4gKiAgeXk6IHtcbiAqICAgICAgcHJlX3BhcnNlOiAgZnVuY3Rpb24oeXkpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgYmVmb3JlIHRoZSBwYXJzZSBjeWNsZSBzdGFydHMgKGFuZCBiZWZvcmUgdGhlIGZpcnN0XG4gKiAgICAgICAgICAgICAgICAgaW52b2NhdGlvbiBvZiBgbGV4KClgKSBidXQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGludm9jYXRpb24gb2ZcbiAqICAgICAgICAgICAgICAgICBgcGFyc2VyLnByZV9wYXJzZSgpYCkuXG4gKiAgICAgIHBvc3RfcGFyc2U6IGZ1bmN0aW9uKHl5LCByZXR2YWwsIHBhcnNlSW5mbykgeyByZXR1cm4gcmV0dmFsOyB9XG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgd2hlbiB0aGUgcGFyc2UgdGVybWluYXRlcyBkdWUgdG8gc3VjY2VzcyAoJ2FjY2VwdCcpXG4gKiAgICAgICAgICAgICAgICAgb3IgZmFpbHVyZSAoZXZlbiB3aGVuIGV4Y2VwdGlvbnMgYXJlIHRocm93bikuXG4gKiAgICAgICAgICAgICAgICAgYHJldHZhbGAgY29udGFpbnMgdGhlIHJldHVybiB2YWx1ZSB0byBiZSBwcm9kdWNlZCBieSBgUGFyc2VyLnBhcnNlKClgO1xuICogICAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gY2FuIG92ZXJyaWRlIHRoZSByZXR1cm4gdmFsdWUgYnkgcmV0dXJuaW5nIGFub3RoZXIuXG4gKiAgICAgICAgICAgICAgICAgV2hlbiBpdCBkb2VzIG5vdCByZXR1cm4gYW55IHZhbHVlLCB0aGUgcGFyc2VyIHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICogICAgICAgICAgICAgICAgIGByZXR2YWxgLlxuICogICAgICAgICAgICAgICAgIFRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYHBhcnNlci5wb3N0X3BhcnNlKClgLlxuICpcbiAqICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcylcbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBwYXJzZUVycm9yYCBmdW5jdGlvbi5cbiAqICAgICAgcXVvdGVOYW1lOiBmdW5jdGlvbihuYW1lKSxcbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBxdW90ZU5hbWVgIGZ1bmN0aW9uLlxuICogIH1cbiAqXG4gKiAgcGFyc2VyLmxleGVyLm9wdGlvbnM6IHtcbiAqICAgICAgcHJlX2xleDogIGZ1bmN0aW9uKClcbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCBiZWZvcmUgdGhlIGxleGVyIGlzIGludm9rZWQgdG8gcHJvZHVjZSBhbm90aGVyIHRva2VuLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqICAgICAgcG9zdF9sZXg6IGZ1bmN0aW9uKHRva2VuKSB7IHJldHVybiB0b2tlbjsgfVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIHdoZW4gdGhlIGxleGVyIGhhcyBwcm9kdWNlZCBhIHRva2VuIGB0b2tlbmA7XG4gKiAgICAgICAgICAgICAgICAgdGhpcyBmdW5jdGlvbiBjYW4gb3ZlcnJpZGUgdGhlIHJldHVybmVkIHRva2VuIHZhbHVlIGJ5IHJldHVybmluZyBhbm90aGVyLlxuICogICAgICAgICAgICAgICAgIFdoZW4gaXQgZG9lcyBub3QgcmV0dXJuIGFueSAodHJ1dGh5KSB2YWx1ZSwgdGhlIGxleGVyIHdpbGwgcmV0dXJuXG4gKiAgICAgICAgICAgICAgICAgdGhlIG9yaWdpbmFsIGB0b2tlbmAuXG4gKiAgICAgICAgICAgICAgICAgYHRoaXNgIHJlZmVycyB0byB0aGUgTGV4ZXIgb2JqZWN0LlxuICpcbiAqICAgICAgcmFuZ2VzOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIuXG4gKiAgICAgIGZsZXg6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZFxuICogICAgICAgICAgICAgICAgIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoLlxuICogICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBsZXhlciByZWdleGVzIGFyZSB0ZXN0ZWQgaW4gb3JkZXIgYW5kIGZvciBpbnZva2VkO1xuICogICAgICAgICAgICAgICAgIHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUuXG4gKiAgICAgIHhyZWdleHA6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBsZXhlciBydWxlIHJlZ2V4ZXMgYXJlIFwiZXh0ZW5kZWQgcmVnZXggZm9ybWF0XCIgcmVxdWlyaW5nIHRoZVxuICogICAgICAgICAgICAgICAgIGBYUmVnRXhwYCBsaWJyYXJ5LiBXaGVuIHRoaXMgYCVvcHRpb25gIGhhcyBub3QgYmVlbiBzcGVjaWZpZWQgYXQgY29tcGlsZSB0aW1lLCBhbGwgbGV4ZXJcbiAqICAgICAgICAgICAgICAgICBydWxlIHJlZ2V4ZXMgaGF2ZSBiZWVuIHdyaXR0ZW4gYXMgc3RhbmRhcmQgSmF2YVNjcmlwdCBSZWdFeHAgZXhwcmVzc2lvbnMuXG4gKiAgfVxuICovXG5cbiAgICAgICAgXG4gICAgXG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcblxuXG4vLyBTZWUgYWxzbzpcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM4MjEwNy93aGF0cy1hLWdvb2Qtd2F5LXRvLWV4dGVuZC1lcnJvci1pbi1qYXZhc2NyaXB0LyMzNTg4MTUwOFxuLy8gYnV0IHdlIGtlZXAgdGhlIHByb3RvdHlwZS5jb25zdHJ1Y3RvciBhbmQgcHJvdG90eXBlLm5hbWUgYXNzaWdubWVudCBsaW5lcyB0b28gZm9yIGNvbXBhdGliaWxpdHlcbi8vIHdpdGggdXNlcmxhbmQgY29kZSB3aGljaCBtaWdodCBhY2Nlc3MgdGhlIGRlcml2ZWQgY2xhc3MgaW4gYSAnY2xhc3NpYycgd2F5LlxuZnVuY3Rpb24gSmlzb25QYXJzZXJFcnJvcihtc2csIGhhc2gpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiAnSmlzb25QYXJzZXJFcnJvcidcbiAgICB9KTtcblxuICAgIGlmIChtc2cgPT0gbnVsbCkgbXNnID0gJz8/Pyc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IG1zZ1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNoID0gaGFzaDtcblxuICAgIHZhciBzdGFja3RyYWNlO1xuICAgIGlmIChoYXNoICYmIGhhc2guZXhjZXB0aW9uIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdmFyIGV4MiA9IGhhc2guZXhjZXB0aW9uO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBleDIubWVzc2FnZSB8fCBtc2c7XG4gICAgICAgIHN0YWNrdHJhY2UgPSBleDIuc3RhY2s7XG4gICAgfVxuICAgIGlmICghc3RhY2t0cmFjZSkge1xuICAgICAgICBpZiAoRXJyb3IuaGFzT3duUHJvcGVydHkoJ2NhcHR1cmVTdGFja1RyYWNlJykpIHsgICAgICAgIC8vIFY4L0Nocm9tZSBlbmdpbmVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhY2t0cmFjZSA9IChuZXcgRXJyb3IobXNnKSkuc3RhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YWNrdHJhY2UpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHN0YWNrdHJhY2VcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5pZiAodHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihKaXNvblBhcnNlckVycm9yLnByb3RvdHlwZSwgRXJyb3IucHJvdG90eXBlKTtcbn0gZWxzZSB7XG4gICAgSmlzb25QYXJzZXJFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG59XG5KaXNvblBhcnNlckVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEppc29uUGFyc2VyRXJyb3I7XG5KaXNvblBhcnNlckVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ppc29uUGFyc2VyRXJyb3InO1xuXG5cblxuXG4gICAgICAgIC8vIGhlbHBlcjogcmVjb25zdHJ1Y3QgdGhlIHByb2R1Y3Rpb25zW10gdGFibGVcbiAgICAgICAgZnVuY3Rpb24gYnAocykge1xuICAgICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgICB2YXIgcCA9IHMucG9wO1xuICAgICAgICAgICAgdmFyIHIgPSBzLnJ1bGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcnYucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBbaV0sXG4gICAgICAgICAgICAgICAgICAgIHJbaV1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiByZWNvbnN0cnVjdCB0aGUgZGVmYXVsdEFjdGlvbnNbXSB0YWJsZVxuICAgICAgICBmdW5jdGlvbiBiZGEocykge1xuICAgICAgICAgICAgdmFyIHJ2ID0ge307XG4gICAgICAgICAgICB2YXIgZCA9IHMuaWR4O1xuICAgICAgICAgICAgdmFyIGcgPSBzLmdvdG87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSBkW2ldO1xuICAgICAgICAgICAgICAgIHJ2W2pdID0gZ1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiByZWNvbnN0cnVjdCB0aGUgJ2dvdG8nIHRhYmxlXG4gICAgICAgIGZ1bmN0aW9uIGJ0KHMpIHtcbiAgICAgICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICAgICAgdmFyIGQgPSBzLmxlbjtcbiAgICAgICAgICAgIHZhciB5ID0gcy5zeW1ib2w7XG4gICAgICAgICAgICB2YXIgdCA9IHMudHlwZTtcbiAgICAgICAgICAgIHZhciBhID0gcy5zdGF0ZTtcbiAgICAgICAgICAgIHZhciBtID0gcy5tb2RlO1xuICAgICAgICAgICAgdmFyIGcgPSBzLmdvdG87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBkW2ldO1xuICAgICAgICAgICAgICAgIHZhciBxID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHogPSB5LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodC5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbel0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5zaGlmdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcuc2hpZnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbel0gPSBhLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSA9PT0gMTogYWNjZXB0XG4gICAgICAgICAgICAgICAgICAgICAgICBxW3pdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDNcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnYucHVzaChxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgIFxuXG5cbiAgICAgICAgLy8gaGVscGVyOiBydW5sZW5ndGggZW5jb2Rpbmcgd2l0aCBpbmNyZW1lbnQgc3RlcDogY29kZSwgbGVuZ3RoOiBzdGVwIChkZWZhdWx0IHN0ZXAgPSAwKVxuICAgICAgICAvLyBgdGhpc2AgcmVmZXJlbmNlcyBhbiBhcnJheVxuICAgICAgICBmdW5jdGlvbiBzKGMsIGwsIGEpIHtcbiAgICAgICAgICAgIGEgPSBhIHx8IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChjKTtcbiAgICAgICAgICAgICAgICBjICs9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZWxwZXI6IGR1cGxpY2F0ZSBzZXF1ZW5jZSBmcm9tICpyZWxhdGl2ZSogb2Zmc2V0IGFuZCBsZW5ndGguXG4gICAgICAgIC8vIGB0aGlzYCByZWZlcmVuY2VzIGFuIGFycmF5XG4gICAgICAgIGZ1bmN0aW9uIGMoaSwgbCkge1xuICAgICAgICAgICAgaSA9IHRoaXMubGVuZ3RoIC0gaTtcbiAgICAgICAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGVscGVyOiB1bnBhY2sgYW4gYXJyYXkgdXNpbmcgaGVscGVycyBhbmQgZGF0YSwgYWxsIHBhc3NlZCBpbiBhbiBhcnJheSBhcmd1bWVudCAnYScuXG4gICAgICAgIGZ1bmN0aW9uIHUoYSkge1xuICAgICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBhW2ldO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgZW50cnkgYSBoZWxwZXIgZnVuY3Rpb24/XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBseShydiwgYVtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcnYucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICBcblxudmFyIHBhcnNlciA9IHtcbiAgICAvLyBDb2RlIEdlbmVyYXRvciBJbmZvcm1hdGlvbiBSZXBvcnRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIE9wdGlvbnM6XG4gICAgLy9cbiAgICAvLyAgIGRlZmF1bHQgYWN0aW9uIG1vZGU6IC4uLi4uLi4uLi4uLi4gW1wiY2xhc3NpY1wiLFwibWVyZ2VcIl1cbiAgICAvLyAgIHRlc3QtY29tcGlsZSBhY3Rpb24gbW9kZTogLi4uLi4uLi4gXCJwYXJzZXI6KixsZXhlcjoqXCJcbiAgICAvLyAgIHRyeS4uY2F0Y2g6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gdHJ1ZVxuICAgIC8vICAgZGVmYXVsdCByZXNvbHZlIG9uIGNvbmZsaWN0OiAuLi4uLiB0cnVlXG4gICAgLy8gICBvbi1kZW1hbmQgbG9vay1haGVhZDogLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICBlcnJvciByZWNvdmVyeSB0b2tlbiBza2lwIG1heGltdW06IDNcbiAgICAvLyAgIHl5ZXJyb3IgaW4gcGFyc2UgYWN0aW9ucyBpczogLi4uLi4gTk9UIHJlY292ZXJhYmxlLFxuICAgIC8vICAgeXllcnJvciBpbiBsZXhlciBhY3Rpb25zIGFuZCBvdGhlciBub24tZmF0YWwgbGV4ZXIgYXJlOlxuICAgIC8vICAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBOT1QgcmVjb3ZlcmFibGUsXG4gICAgLy8gICBkZWJ1ZyBncmFtbWFyL291dHB1dDogLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICBoYXMgcGFydGlhbCBMUiBjb25mbGljdCB1cGdyYWRlOiAgIHRydWVcbiAgICAvLyAgIHJ1ZGltZW50YXJ5IHRva2VuLXN0YWNrIHN1cHBvcnQ6ICAgZmFsc2VcbiAgICAvLyAgIHBhcnNlciB0YWJsZSBjb21wcmVzc2lvbiBtb2RlOiAuLi4gMlxuICAgIC8vICAgZXhwb3J0IGRlYnVnIHRhYmxlczogLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgZXhwb3J0ICphbGwqIHRhYmxlczogLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgbW9kdWxlIHR5cGU6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBjb21tb25qc1xuICAgIC8vICAgcGFyc2VyIGVuZ2luZSB0eXBlOiAuLi4uLi4uLi4uLi4uLiBsYWxyXG4gICAgLy8gICBvdXRwdXQgbWFpbigpIGluIHRoZSBtb2R1bGU6IC4uLi4uIHRydWVcbiAgICAvLyAgIGhhcyB1c2VyLXNwZWNpZmllZCBtYWluKCk6IC4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIGhhcyB1c2VyLXNwZWNpZmllZCByZXF1aXJlKCkvaW1wb3J0IG1vZHVsZXMgZm9yIG1haW4oKTpcbiAgICAvLyAgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIG51bWJlciBvZiBleHBlY3RlZCBjb25mbGljdHM6IC4uLi4gMFxuICAgIC8vXG4gICAgLy9cbiAgICAvLyBQYXJzZXIgQW5hbHlzaXMgZmxhZ3M6XG4gICAgLy9cbiAgICAvLyAgIG5vIHNpZ25pZmljYW50IGFjdGlvbnMgKHBhcnNlciBpcyBhIGxhbmd1YWdlIG1hdGNoZXIgb25seSk6XG4gICAgLy8gICAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIHl5bGVuZzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIHl5bGluZW5vOiAuLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIHl5dGV4dDogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIHl5bGxvYzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIFBhcnNlRXJyb3IgQVBJOiAuLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIFlZRVJST1I6IC4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIFlZUkVDT1ZFUklORzogLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIFlZRVJST0s6IC4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIFlZQ0xFQVJJTjogLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB0cmFja3MgcnVsZSB2YWx1ZXM6IC4uLi4uLi4uLi4uLi4uIHRydWVcbiAgICAvLyAgIGFzc2lnbnMgcnVsZSB2YWx1ZXM6IC4uLi4uLi4uLi4uLi4gdHJ1ZVxuICAgIC8vICAgdXNlcyBsb2NhdGlvbiB0cmFja2luZzogLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgYXNzaWducyBsb2NhdGlvbjogLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXN0YWNrOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXNzdGFjazogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXNwOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiB0cnVlXG4gICAgLy8gICB1c2VzIHl5cnVsZWxlbmd0aDogLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICB1c2VzIHl5TWVyZ2VMb2NhdGlvbkluZm8gQVBJOiAuLi4uIGZhbHNlXG4gICAgLy8gICBoYXMgZXJyb3IgcmVjb3Zlcnk6IC4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICBoYXMgZXJyb3IgcmVwb3J0aW5nOiAuLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0gRU5EIE9GIFJFUE9SVCAtLS0tLS0tLS0tLVxuXG50cmFjZTogZnVuY3Rpb24gbm9fb3BfdHJhY2UoKSB7IH0sXG5KaXNvblBhcnNlckVycm9yOiBKaXNvblBhcnNlckVycm9yLFxueXk6IHt9LFxub3B0aW9uczoge1xuICB0eXBlOiBcImxhbHJcIixcbiAgaGFzUGFydGlhbExyVXBncmFkZU9uQ29uZmxpY3Q6IHRydWUsXG4gIGVycm9yUmVjb3ZlcnlUb2tlbkRpc2NhcmRDb3VudDogM1xufSxcbnN5bWJvbHNfOiB7XG4gIFwiJGFjY2VwdFwiOiAwLFxuICBcIiRlbmRcIjogMSxcbiAgXCJBRERcIjogMyxcbiAgXCJBTkdMRVwiOiAxNixcbiAgXCJDSFNcIjogMjIsXG4gIFwiQ09NTUFcIjogMTQsXG4gIFwiQ1NTX0NQUk9QXCI6IDEzLFxuICBcIkNTU19WQVJcIjogMTIsXG4gIFwiRElWXCI6IDYsXG4gIFwiRU1TXCI6IDIwLFxuICBcIkVPRlwiOiAxLFxuICBcIkVYU1wiOiAyMSxcbiAgXCJGUkVRXCI6IDE4LFxuICBcIkxFTkdUSFwiOiAxNSxcbiAgXCJMUEFSRU5cIjogNyxcbiAgXCJNVUxcIjogNSxcbiAgXCJORVNURURfQ0FMQ1wiOiA5LFxuICBcIk5VTUJFUlwiOiAxMSxcbiAgXCJQRVJDRU5UQUdFXCI6IDI4LFxuICBcIlBSRUZJWFwiOiAxMCxcbiAgXCJSRU1TXCI6IDIzLFxuICBcIlJFU1wiOiAxOSxcbiAgXCJSUEFSRU5cIjogOCxcbiAgXCJTVUJcIjogNCxcbiAgXCJUSU1FXCI6IDE3LFxuICBcIlZIU1wiOiAyNCxcbiAgXCJWTUFYU1wiOiAyNyxcbiAgXCJWTUlOU1wiOiAyNixcbiAgXCJWV1NcIjogMjUsXG4gIFwiY3NzX3ZhbHVlXCI6IDMzLFxuICBcImNzc192YXJpYWJsZVwiOiAzMixcbiAgXCJlcnJvclwiOiAyLFxuICBcImV4cHJlc3Npb25cIjogMjksXG4gIFwibWF0aF9leHByZXNzaW9uXCI6IDMwLFxuICBcInZhbHVlXCI6IDMxXG59LFxudGVybWluYWxzXzoge1xuICAxOiBcIkVPRlwiLFxuICAyOiBcImVycm9yXCIsXG4gIDM6IFwiQUREXCIsXG4gIDQ6IFwiU1VCXCIsXG4gIDU6IFwiTVVMXCIsXG4gIDY6IFwiRElWXCIsXG4gIDc6IFwiTFBBUkVOXCIsXG4gIDg6IFwiUlBBUkVOXCIsXG4gIDk6IFwiTkVTVEVEX0NBTENcIixcbiAgMTA6IFwiUFJFRklYXCIsXG4gIDExOiBcIk5VTUJFUlwiLFxuICAxMjogXCJDU1NfVkFSXCIsXG4gIDEzOiBcIkNTU19DUFJPUFwiLFxuICAxNDogXCJDT01NQVwiLFxuICAxNTogXCJMRU5HVEhcIixcbiAgMTY6IFwiQU5HTEVcIixcbiAgMTc6IFwiVElNRVwiLFxuICAxODogXCJGUkVRXCIsXG4gIDE5OiBcIlJFU1wiLFxuICAyMDogXCJFTVNcIixcbiAgMjE6IFwiRVhTXCIsXG4gIDIyOiBcIkNIU1wiLFxuICAyMzogXCJSRU1TXCIsXG4gIDI0OiBcIlZIU1wiLFxuICAyNTogXCJWV1NcIixcbiAgMjY6IFwiVk1JTlNcIixcbiAgMjc6IFwiVk1BWFNcIixcbiAgMjg6IFwiUEVSQ0VOVEFHRVwiXG59LFxuVEVSUk9SOiAyLFxuICAgIEVPRjogMSxcblxuICAgIC8vIGludGVybmFsczogZGVmaW5lZCBoZXJlIHNvIHRoZSBvYmplY3QgKnN0cnVjdHVyZSogZG9lc24ndCBnZXQgbW9kaWZpZWQgYnkgcGFyc2UoKSBldCBhbCxcbiAgICAvLyB0aHVzIGhlbHBpbmcgSklUIGNvbXBpbGVycyBsaWtlIENocm9tZSBWOC5cbiAgICBvcmlnaW5hbFF1b3RlTmFtZTogbnVsbCxcbiAgICBvcmlnaW5hbFBhcnNlRXJyb3I6IG51bGwsXG4gICAgY2xlYW51cEFmdGVyUGFyc2U6IG51bGwsXG4gICAgY29uc3RydWN0UGFyc2VFcnJvckluZm86IG51bGwsXG4gICAgeXlNZXJnZUxvY2F0aW9uSW5mbzogbnVsbCxcblxuICAgIF9fcmVlbnRyYW50X2NhbGxfZGVwdGg6IDAsICAgICAgLy8gSU5URVJOQUwgVVNFIE9OTFlcbiAgICBfX2Vycm9yX2luZm9zOiBbXSwgICAgICAgICAgICAgIC8vIElOVEVSTkFMIFVTRSBPTkxZOiB0aGUgc2V0IG9mIHBhcnNlRXJyb3JJbmZvIG9iamVjdHMgY3JlYXRlZCBzaW5jZSB0aGUgbGFzdCBjbGVhbnVwXG4gICAgX19lcnJvcl9yZWNvdmVyeV9pbmZvczogW10sICAgICAvLyBJTlRFUk5BTCBVU0UgT05MWTogdGhlIHNldCBvZiBwYXJzZUVycm9ySW5mbyBvYmplY3RzIGNyZWF0ZWQgc2luY2UgdGhlIGxhc3QgY2xlYW51cFxuXG4gICAgLy8gQVBJcyB3aGljaCB3aWxsIGJlIHNldCB1cCBkZXBlbmRpbmcgb24gdXNlciBhY3Rpb24gY29kZSBhbmFseXNpczpcbiAgICAvL3l5UmVjb3ZlcmluZzogMCxcbiAgICAvL3l5RXJyT2s6IDAsXG4gICAgLy95eUNsZWFySW46IDAsXG5cbiAgICAvLyBIZWxwZXIgQVBJc1xuICAgIC8vIC0tLS0tLS0tLS0tXG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdXNlciBjb2RlIGxhdGVyIG9uOiBwdXQgc3VpdGFibGUgcXVvdGVzIGFyb3VuZFxuICAgIC8vIGxpdGVyYWwgSURzIGluIGEgZGVzY3JpcHRpb24gc3RyaW5nLlxuICAgIHF1b3RlTmFtZTogZnVuY3Rpb24gcGFyc2VyX3F1b3RlTmFtZShpZF9zdHIpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyBpZF9zdHIgKyAnXCInO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGdpdmVuIHN5bWJvbCAodGVybWluYWwgb3Igbm9uLXRlcm1pbmFsKSBhcyBhIHN0cmluZywgd2hlbiBhdmFpbGFibGUuXG4gICAgLy9cbiAgICAvLyBSZXR1cm4gTlVMTCB3aGVuIHRoZSBzeW1ib2wgaXMgdW5rbm93biB0byB0aGUgcGFyc2VyLlxuICAgIGdldFN5bWJvbE5hbWU6IGZ1bmN0aW9uIHBhcnNlcl9nZXRTeW1ib2xOYW1lKHN5bWJvbCkge1xuICAgICAgICBpZiAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZS4uLiB0aGlzIG1pZ2h0IHJlZmVyIHRvIGEgUlVMRSB0b2tlbiBpLmUuIGEgbm9uLXRlcm1pbmFsOiBzZWUgaWYgd2UgY2FuIGRpZyB0aGF0IG9uZSB1cC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQW4gZXhhbXBsZSBvZiB0aGlzIG1heSBiZSB3aGVyZSBhIHJ1bGUncyBhY3Rpb24gY29kZSBjb250YWlucyBhIGNhbGwgbGlrZSB0aGlzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgIHBhcnNlci5nZXRTeW1ib2xOYW1lKCMkKVxuICAgICAgICAvL1xuICAgICAgICAvLyB0byBvYnRhaW4gYSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjdXJyZW50IGdyYW1tYXIgcnVsZS5cbiAgICAgICAgdmFyIHMgPSB0aGlzLnN5bWJvbHNfO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcykge1xuICAgICAgICAgICAgaWYgKHNba2V5XSA9PT0gc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGEgbW9yZS1vci1sZXNzIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBnaXZlbiBzeW1ib2wsIHdoZW4gYXZhaWxhYmxlLFxuICAgIC8vIG9yIHRoZSBzeW1ib2wgaXRzZWxmLCBzZXJ2aW5nIGFzIGl0cyBvd24gJ2Rlc2NyaXB0aW9uJyBmb3IgbGFjayBvZiBzb21ldGhpbmcgYmV0dGVyIHRvIHNlcnZlIHVwLlxuICAgIC8vXG4gICAgLy8gUmV0dXJuIE5VTEwgd2hlbiB0aGUgc3ltYm9sIGlzIHVua25vd24gdG8gdGhlIHBhcnNlci5cbiAgICBkZXNjcmliZVN5bWJvbDogZnVuY3Rpb24gcGFyc2VyX2Rlc2NyaWJlU3ltYm9sKHN5bWJvbCkge1xuICAgICAgICBpZiAoc3ltYm9sICE9PSB0aGlzLkVPRiAmJiB0aGlzLnRlcm1pbmFsX2Rlc2NyaXB0aW9uc18gJiYgdGhpcy50ZXJtaW5hbF9kZXNjcmlwdGlvbnNfW3N5bWJvbF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlcm1pbmFsX2Rlc2NyaXB0aW9uc19bc3ltYm9sXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzeW1ib2wgPT09IHRoaXMuRU9GKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2VuZCBvZiBpbnB1dCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRTeW1ib2xOYW1lKHN5bWJvbCk7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVvdGVOYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gUHJvZHVjZSBhIChtb3JlIG9yIGxlc3MpIGh1bWFuLXJlYWRhYmxlIGxpc3Qgb2YgZXhwZWN0ZWQgdG9rZW5zIGF0IHRoZSBwb2ludCBvZiBmYWlsdXJlLlxuICAgIC8vXG4gICAgLy8gVGhlIHByb2R1Y2VkIGxpc3QgbWF5IGNvbnRhaW4gdG9rZW4gb3IgdG9rZW4gc2V0IGRlc2NyaXB0aW9ucyBpbnN0ZWFkIG9mIHRoZSB0b2tlbnNcbiAgICAvLyB0aGVtc2VsdmVzIHRvIGhlbHAgdHVybmluZyB0aGlzIG91dHB1dCBpbnRvIHNvbWV0aGluZyB0aGF0IGVhc2llciB0byByZWFkIGJ5IGh1bWFuc1xuICAgIC8vIHVubGVzcyBgZG9fbm90X2Rlc2NyaWJlYCBwYXJhbWV0ZXIgaXMgc2V0LCBpbiB3aGljaCBjYXNlIGEgbGlzdCBvZiB0aGUgcmF3LCAqbnVtZXJpYyosXG4gICAgLy8gZXhwZWN0ZWQgdGVybWluYWxzIGFuZCBub250ZXJtaW5hbHMgaXMgcHJvZHVjZWQuXG4gICAgLy9cbiAgICAvLyBUaGUgcmV0dXJuZWQgbGlzdCAoYXJyYXkpIHdpbGwgbm90IGNvbnRhaW4gYW55IGR1cGxpY2F0ZSBlbnRyaWVzLlxuICAgIGNvbGxlY3RfZXhwZWN0ZWRfdG9rZW5fc2V0OiBmdW5jdGlvbiBwYXJzZXJfY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQoc3RhdGUsIGRvX25vdF9kZXNjcmliZSkge1xuICAgICAgICB2YXIgVEVSUk9SID0gdGhpcy5URVJST1I7XG4gICAgICAgIHZhciB0b2tlbnNldCA9IFtdO1xuICAgICAgICB2YXIgY2hlY2sgPSB7fTtcbiAgICAgICAgLy8gSGFzIHRoaXMgKGVycm9yPykgc3RhdGUgYmVlbiBvdXRmaXR0ZWQgd2l0aCBhIGN1c3RvbSBleHBlY3RhdGlvbnMgZGVzY3JpcHRpb24gdGV4dCBmb3IgaHVtYW4gY29uc3VtcHRpb24/XG4gICAgICAgIC8vIElmIHNvLCB1c2UgdGhhdCBvbmUgaW5zdGVhZCBvZiB0aGUgbGVzcyBwYWxhdGFibGUgdG9rZW4gc2V0LlxuICAgICAgICBpZiAoIWRvX25vdF9kZXNjcmliZSAmJiB0aGlzLnN0YXRlX2Rlc2NyaXB0aW9uc18gJiYgdGhpcy5zdGF0ZV9kZXNjcmlwdGlvbnNfW3N0YXRlXSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlX2Rlc2NyaXB0aW9uc19bc3RhdGVdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHAgaW4gdGhpcy50YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgICAgIHAgPSArcDtcbiAgICAgICAgICAgIGlmIChwICE9PSBURVJST1IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRvX25vdF9kZXNjcmliZSA/IHAgOiB0aGlzLmRlc2NyaWJlU3ltYm9sKHApO1xuICAgICAgICAgICAgICAgIGlmIChkICYmICFjaGVja1tkXSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNldC5wdXNoKGQpO1xuICAgICAgICAgICAgICAgICAgICBjaGVja1tkXSA9IHRydWU7ICAgICAgICAvLyBNYXJrIHRoaXMgdG9rZW4gZGVzY3JpcHRpb24gYXMgYWxyZWFkeSBtZW50aW9uZWQgdG8gcHJldmVudCBvdXRwdXR0aW5nIGR1cGxpY2F0ZSBlbnRyaWVzLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zZXQ7XG4gICAgfSxcbnByb2R1Y3Rpb25zXzogYnAoe1xuICBwb3A6IHUoW1xuICAyOSxcbiAgcyxcbiAgWzMwLCAxMF0sXG4gIDMxLFxuICAzMSxcbiAgMzIsXG4gIDMyLFxuICBzLFxuICBbMzMsIDE1XVxuXSksXG4gIHJ1bGU6IHUoW1xuICAyLFxuICBzLFxuICBbMywgNV0sXG4gIDQsXG4gIDcsXG4gIHMsXG4gIFsxLCA0XSxcbiAgMixcbiAgNCxcbiAgNixcbiAgcyxcbiAgWzEsIDE0XSxcbiAgMlxuXSlcbn0pLFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gcGFyc2VyX19QZXJmb3JtQWN0aW9uKHl5c3RhdGUgLyogYWN0aW9uWzFdICovLCB5eXNwLCB5eXZzdGFjaykge1xuXG4gICAgICAgICAgLyogdGhpcyA9PSB5eXZhbCAqL1xuXG4gICAgICAgICAgLy8gdGhlIEpTIGVuZ2luZSBpdHNlbGYgY2FuIGdvIGFuZCByZW1vdmUgdGhlc2Ugc3RhdGVtZW50cyB3aGVuIGB5eWAgdHVybnMgb3V0IHRvIGJlIHVudXNlZCBpbiBhbnkgYWN0aW9uIGNvZGUhXG4gICAgICAgICAgdmFyIHl5ID0gdGhpcy55eTtcbiAgICAgICAgICB2YXIgeXlwYXJzZXIgPSB5eS5wYXJzZXI7XG4gICAgICAgICAgdmFyIHl5bGV4ZXIgPSB5eS5sZXhlcjtcblxuICAgICAgICAgIFxuXG4gICAgICAgICAgc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICAkYWNjZXB0IDogZXhwcmVzc2lvbiAkZW5kICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiAxLFZULFZBLC0sLSwtLC0sLSwtKTpcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwIC0gMV07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IDEsVlQsVkEsLSwtLC0sLSwtLC0pXG4gICAgYnJlYWs7XG5cbmNhc2UgMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGV4cHJlc3Npb24gOiBtYXRoX2V4cHJlc3Npb24gRU9GICovXG5cbiAgICAvLyBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiAyLFZULFZBLC0sLSwtLC0sLSwtKTpcbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwIC0gMV07XG4gICAgLy8gRU5EIG9mIGRlZmF1bHQgYWN0aW9uIChnZW5lcmF0ZWQgYnkgSklTT04gbW9kZSBjbGFzc2ljL21lcmdlIDo6IDIsVlQsVkEsLSwtLC0sLSwtLC0pXG4gICAgXG4gICAgXG4gICAgcmV0dXJuIHl5dnN0YWNrW3l5c3AgLSAxXTtcbiAgICBicmVhaztcblxuY2FzZSAyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWF0aF9leHByZXNzaW9uIDogbWF0aF9leHByZXNzaW9uIEFERCBtYXRoX2V4cHJlc3Npb24gKi9cbmNhc2UgMzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1hdGhfZXhwcmVzc2lvbiA6IG1hdGhfZXhwcmVzc2lvbiBTVUIgbWF0aF9leHByZXNzaW9uICovXG5jYXNlIDQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYXRoX2V4cHJlc3Npb24gOiBtYXRoX2V4cHJlc3Npb24gTVVMIG1hdGhfZXhwcmVzc2lvbiAqL1xuY2FzZSA1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWF0aF9leHByZXNzaW9uIDogbWF0aF9leHByZXNzaW9uIERJViBtYXRoX2V4cHJlc3Npb24gKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ01hdGhFeHByZXNzaW9uJywgb3BlcmF0b3I6IHl5dnN0YWNrW3l5c3AgLSAxXSwgbGVmdDogeXl2c3RhY2tbeXlzcCAtIDJdLCByaWdodDogeXl2c3RhY2tbeXlzcF0gfTtcbiAgICBicmVhaztcblxuY2FzZSA2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWF0aF9leHByZXNzaW9uIDogTFBBUkVOIG1hdGhfZXhwcmVzc2lvbiBSUEFSRU4gKi9cblxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3AgLSAxXTtcbiAgICBicmVhaztcblxuY2FzZSA3OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWF0aF9leHByZXNzaW9uIDogTkVTVEVEX0NBTEMgTFBBUkVOIG1hdGhfZXhwcmVzc2lvbiBSUEFSRU4gKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ0NhbGMnLCB2YWx1ZTogeXl2c3RhY2tbeXlzcCAtIDFdIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1hdGhfZXhwcmVzc2lvbiA6IFNVQiBQUkVGSVggU1VCIE5FU1RFRF9DQUxDIExQQVJFTiBtYXRoX2V4cHJlc3Npb24gUlBBUkVOICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdDYWxjJywgdmFsdWU6IHl5dnN0YWNrW3l5c3AgLSAxXSwgcHJlZml4OiB5eXZzdGFja1t5eXNwIC0gNV0gfTtcbiAgICBicmVhaztcblxuY2FzZSA5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWF0aF9leHByZXNzaW9uIDogY3NzX3ZhcmlhYmxlICovXG5jYXNlIDEwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWF0aF9leHByZXNzaW9uIDogY3NzX3ZhbHVlICovXG5jYXNlIDExOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWF0aF9leHByZXNzaW9uIDogdmFsdWUgKi9cblxuICAgIHRoaXMuJCA9IHl5dnN0YWNrW3l5c3BdO1xuICAgIGJyZWFrO1xuXG5jYXNlIDEyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdmFsdWUgOiBOVU1CRVIgKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ1ZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgMTM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICB2YWx1ZSA6IFNVQiBOVU1CRVIgKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ1ZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pICogLTEgfTtcbiAgICBicmVhaztcblxuY2FzZSAxNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YXJpYWJsZSA6IENTU19WQVIgTFBBUkVOIENTU19DUFJPUCBSUEFSRU4gKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ0Nzc1ZhcmlhYmxlJywgdmFsdWU6IHl5dnN0YWNrW3l5c3AgLSAxXSB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDE1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhcmlhYmxlIDogQ1NTX1ZBUiBMUEFSRU4gQ1NTX0NQUk9QIENPTU1BIG1hdGhfZXhwcmVzc2lvbiBSUEFSRU4gKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ0Nzc1ZhcmlhYmxlJywgdmFsdWU6IHl5dnN0YWNrW3l5c3AgLSAzXSwgZmFsbGJhY2s6IHl5dnN0YWNrW3l5c3AgLSAxXSB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDE2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogTEVOR1RIICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdMZW5ndGhWYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSwgdW5pdDogL1thLXpdKy8uZXhlYyh5eXZzdGFja1t5eXNwXSlbMF0gfTtcbiAgICBicmVhaztcblxuY2FzZSAxNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IEFOR0xFICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdBbmdsZVZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pLCB1bml0OiAvW2Etel0rLy5leGVjKHl5dnN0YWNrW3l5c3BdKVswXSB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDE4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogVElNRSAqL1xuXG4gICAgdGhpcy4kID0geyB0eXBlOiAnVGltZVZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pLCB1bml0OiAvW2Etel0rLy5leGVjKHl5dnN0YWNrW3l5c3BdKVswXSB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDE5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogRlJFUSAqL1xuXG4gICAgdGhpcy4kID0geyB0eXBlOiAnRnJlcXVlbmN5VmFsdWUnLCB2YWx1ZTogcGFyc2VGbG9hdCh5eXZzdGFja1t5eXNwXSksIHVuaXQ6IC9bYS16XSsvLmV4ZWMoeXl2c3RhY2tbeXlzcF0pWzBdIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgMjA6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjc3NfdmFsdWUgOiBSRVMgKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ1Jlc29sdXRpb25WYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSwgdW5pdDogL1thLXpdKy8uZXhlYyh5eXZzdGFja1t5eXNwXSlbMF0gfTtcbiAgICBicmVhaztcblxuY2FzZSAyMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IEVNUyAqL1xuXG4gICAgdGhpcy4kID0geyB0eXBlOiAnRW1WYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSwgdW5pdDogJ2VtJyB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDIyOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogRVhTICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdFeFZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pLCB1bml0OiAnZXgnIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgMjM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjc3NfdmFsdWUgOiBDSFMgKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ0NoVmFsdWUnLCB2YWx1ZTogcGFyc2VGbG9hdCh5eXZzdGFja1t5eXNwXSksIHVuaXQ6ICdjaCcgfTtcbiAgICBicmVhaztcblxuY2FzZSAyNDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IFJFTVMgKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ1JlbVZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pLCB1bml0OiAncmVtJyB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDI1OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogVkhTICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdWaFZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pLCB1bml0OiAndmgnIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgMjY6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjc3NfdmFsdWUgOiBWV1MgKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ1Z3VmFsdWUnLCB2YWx1ZTogcGFyc2VGbG9hdCh5eXZzdGFja1t5eXNwXSksIHVuaXQ6ICd2dycgfTtcbiAgICBicmVhaztcblxuY2FzZSAyNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IFZNSU5TICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdWbWluVmFsdWUnLCB2YWx1ZTogcGFyc2VGbG9hdCh5eXZzdGFja1t5eXNwXSksIHVuaXQ6ICd2bWluJyB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDI4OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogVk1BWFMgKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ1ZtYXhWYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSwgdW5pdDogJ3ZtYXgnIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgMjk6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjc3NfdmFsdWUgOiBQRVJDRU5UQUdFICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdQZXJjZW50YWdlVmFsdWUnLCB2YWx1ZTogcGFyc2VGbG9hdCh5eXZzdGFja1t5eXNwXSksIHVuaXQ6ICclJyB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDMwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogU1VCIGNzc192YWx1ZSAqL1xuXG4gICAgdmFyIHByZXYgPSB5eXZzdGFja1t5eXNwXTsgcHJldi52YWx1ZSAqPSAtMTsgdGhpcy4kID0gcHJldjtcbiAgICBicmVhaztcblxufVxufSxcbnRhYmxlOiBidCh7XG4gIGxlbjogdShbXG4gIDI0LFxuICAxLFxuICA1LFxuICAyMyxcbiAgMSxcbiAgMTgsXG4gIHMsXG4gIFswLCAzXSxcbiAgMSxcbiAgcyxcbiAgWzAsIDE2XSxcbiAgcyxcbiAgWzIzLCA0XSxcbiAgYyxcbiAgWzI4LCAzXSxcbiAgMCxcbiAgMCxcbiAgMTYsXG4gIDEsXG4gIDYsXG4gIDYsXG4gIHMsXG4gIFswLCAzXSxcbiAgNSxcbiAgMSxcbiAgMixcbiAgYyxcbiAgWzM3LCAzXSxcbiAgYyxcbiAgWzIwLCAzXSxcbiAgNSxcbiAgMCxcbiAgMFxuXSksXG4gIHN5bWJvbDogdShbXG4gIDQsXG4gIDcsXG4gIDksXG4gIDExLFxuICAxMixcbiAgcyxcbiAgWzE1LCAxOSwgMV0sXG4gIDEsXG4gIDEsXG4gIHMsXG4gIFszLCA0LCAxXSxcbiAgYyxcbiAgWzMwLCAxOV0sXG4gIGMsXG4gIFsyOSwgNF0sXG4gIDcsXG4gIDQsXG4gIDEwLFxuICAxMSxcbiAgYyxcbiAgWzIyLCAxNF0sXG4gIGMsXG4gIFsxOSwgM10sXG4gIGMsXG4gIFs0MywgMjJdLFxuICBjLFxuICBbMjMsIDY5XSxcbiAgYyxcbiAgWzEzOSwgNF0sXG4gIDgsXG4gIGMsXG4gIFs1MSwgMjRdLFxuICA0LFxuICBjLFxuICBbMTM4LCAxNV0sXG4gIDEzLFxuICBjLFxuICBbMTg2LCA1XSxcbiAgOCxcbiAgYyxcbiAgWzYsIDZdLFxuICBjLFxuICBbNSwgNV0sXG4gIDksXG4gIDgsXG4gIDE0LFxuICBjLFxuICBbMTU5LCA0N10sXG4gIGMsXG4gIFs2MCwgMTBdXG5dKSxcbiAgdHlwZTogdShbXG4gIHMsXG4gIFsyLCAxOV0sXG4gIHMsXG4gIFswLCA1XSxcbiAgMSxcbiAgcyxcbiAgWzIsIDI0XSxcbiAgcyxcbiAgWzAsIDRdLFxuICBjLFxuICBbMjIsIDE5XSxcbiAgYyxcbiAgWzQzLCA0Ml0sXG4gIGMsXG4gIFsyMywgNzBdLFxuICBjLFxuICBbMjgsIDI1XSxcbiAgYyxcbiAgWzQ1LCAyNV0sXG4gIGMsXG4gIFsxMTMsIDU0XVxuXSksXG4gIHN0YXRlOiB1KFtcbiAgMSxcbiAgMixcbiAgOCxcbiAgNixcbiAgNyxcbiAgMzAsXG4gIGMsXG4gIFs0LCAzXSxcbiAgMzMsXG4gIDM3LFxuICBjLFxuICBbNSwgM10sXG4gIDM4LFxuICBjLFxuICBbNCwgM10sXG4gIDM5LFxuICBjLFxuICBbNCwgM10sXG4gIDQwLFxuICBjLFxuICBbNCwgM10sXG4gIDQyLFxuICBjLFxuICBbMjEsIDRdLFxuICA1MCxcbiAgYyxcbiAgWzUsIDNdLFxuICA1MSxcbiAgYyxcbiAgWzQsIDNdXG5dKSxcbiAgbW9kZTogdShbXG4gIHMsXG4gIFsxLCAxNzldLFxuICBzLFxuICBbMiwgM10sXG4gIGMsXG4gIFs1LCA1XSxcbiAgYyxcbiAgWzYsIDRdLFxuICBzLFxuICBbMSwgNTddXG5dKSxcbiAgZ290bzogdShbXG4gIDUsXG4gIDMsXG4gIDQsXG4gIDI0LFxuICBzLFxuICBbOSwgMTUsIDFdLFxuICBzLFxuICBbMjUsIDUsIDFdLFxuICBjLFxuICBbMjQsIDE5XSxcbiAgMzEsXG4gIDM1LFxuICAzMixcbiAgMzQsXG4gIGMsXG4gIFsxOCwgMTRdLFxuICAzNixcbiAgYyxcbiAgWzM4LCAxOV0sXG4gIGMsXG4gIFsxOSwgNTddLFxuICBjLFxuICBbMTE4LCA0XSxcbiAgNDEsXG4gIGMsXG4gIFsyNCwgMTldLFxuICA0MyxcbiAgMzUsXG4gIGMsXG4gIFsxNiwgMTRdLFxuICA0NCxcbiAgcyxcbiAgWzIsIDNdLFxuICAyOCxcbiAgMjksXG4gIDIsXG4gIHMsXG4gIFszLCAzXSxcbiAgMjgsXG4gIDI5LFxuICAzLFxuICBjLFxuICBbNTMsIDRdLFxuICBzLFxuICBbNDUsIDUsIDFdLFxuICBjLFxuICBbMTAwLCA0Ml0sXG4gIDUyLFxuICBjLFxuICBbNSwgNF0sXG4gIDUzXG5dKVxufSksXG5kZWZhdWx0QWN0aW9uczogYmRhKHtcbiAgaWR4OiB1KFtcbiAgNixcbiAgNyxcbiAgOCxcbiAgcyxcbiAgWzEwLCAxNiwgMV0sXG4gIDMzLFxuICAzNCxcbiAgMzksXG4gIDQwLFxuICA0MSxcbiAgNDUsXG4gIDQ3LFxuICA1MixcbiAgNTNcbl0pLFxuICBnb3RvOiB1KFtcbiAgOSxcbiAgMTAsXG4gIDExLFxuICBzLFxuICBbMTYsIDE0LCAxXSxcbiAgMTIsXG4gIDEsXG4gIDMwLFxuICAxMyxcbiAgcyxcbiAgWzQsIDQsIDFdLFxuICAxNCxcbiAgMTUsXG4gIDhcbl0pXG59KSxcbnBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcykge1xuICAgIGlmIChoYXNoLnJlY292ZXJhYmxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgICAgICB9XG4gICAgICAgIGhhc2guZGVzdHJveSgpOyAgICAgICAgICAgICAvLyBkZXN0cm95Li4uIHdlbGwsICphbG1vc3QqIVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgIEV4Y2VwdGlvbkNsYXNzID0gdGhpcy5KaXNvblBhcnNlckVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25DbGFzcyhzdHIsIGhhc2gpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0YWNrID0gbmV3IEFycmF5KDEyOCk7ICAgICAgICAgLy8gdG9rZW4gc3RhY2s6IHN0b3JlcyB0b2tlbiB3aGljaCBsZWFkcyB0byBzdGF0ZSBhdCB0aGUgc2FtZSBpbmRleCAoY29sdW1uIHN0b3JhZ2UpXG4gICAgdmFyIHNzdGFjayA9IG5ldyBBcnJheSgxMjgpOyAgICAgICAgLy8gc3RhdGUgc3RhY2s6IHN0b3JlcyBzdGF0ZXMgKGNvbHVtbiBzdG9yYWdlKVxuXG4gICAgdmFyIHZzdGFjayA9IG5ldyBBcnJheSgxMjgpOyAgICAgICAgLy8gc2VtYW50aWMgdmFsdWUgc3RhY2tcblxuICAgIHZhciB0YWJsZSA9IHRoaXMudGFibGU7XG4gICAgdmFyIHNwID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ3N0YWNrIHBvaW50ZXInOiBpbmRleCBpbnRvIHRoZSBzdGFja3NcblxuXG4gICAgXG5cblxuICAgIHZhciBzeW1ib2wgPSAwO1xuXG5cblxuICAgIHZhciBURVJST1IgPSB0aGlzLlRFUlJPUjtcbiAgICB2YXIgRU9GID0gdGhpcy5FT0Y7XG4gICAgdmFyIEVSUk9SX1JFQ09WRVJZX1RPS0VOX0RJU0NBUkRfQ09VTlQgPSAodGhpcy5vcHRpb25zLmVycm9yUmVjb3ZlcnlUb2tlbkRpc2NhcmRDb3VudCB8IDApIHx8IDM7XG4gICAgdmFyIE5PX0FDVElPTiA9IFswLCA1NCAvKiA9PT0gdGFibGUubGVuZ3RoIDo6IGVuc3VyZXMgdGhhdCBhbnlvbmUgdXNpbmcgdGhpcyBuZXcgc3RhdGUgd2lsbCBmYWlsIGRyYW1hdGljYWxseSEgKi9dO1xuXG4gICAgdmFyIGxleGVyO1xuICAgIGlmICh0aGlzLl9fbGV4ZXJfXykge1xuICAgICAgICBsZXhlciA9IHRoaXMuX19sZXhlcl9fO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxleGVyID0gdGhpcy5fX2xleGVyX18gPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgIH1cblxuICAgIHZhciBzaGFyZWRTdGF0ZV95eSA9IHtcbiAgICAgICAgcGFyc2VFcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBxdW90ZU5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgbGV4ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyc2VyOiB1bmRlZmluZWQsXG4gICAgICAgIHByZV9wYXJzZTogdW5kZWZpbmVkLFxuICAgICAgICBwb3N0X3BhcnNlOiB1bmRlZmluZWQsXG4gICAgICAgIHByZV9sZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9zdF9sZXg6IHVuZGVmaW5lZCAgICAgIC8vIFdBUk5JTkc6IG11c3QgYmUgd3JpdHRlbiB0aGlzIHdheSBmb3IgdGhlIGNvZGUgZXhwYW5kZXJzIHRvIHdvcmsgY29ycmVjdGx5IGluIGJvdGggRVM1IGFuZCBFUzYgbW9kZXMhXG4gICAgfTtcblxuICAgIHZhciBBU1NFUlQ7XG4gICAgaWYgKHR5cGVvZiBhc3NlcnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgQVNTRVJUID0gZnVuY3Rpb24gSmlzb25Bc3NlcnQoY29uZCwgbXNnKSB7XG4gICAgICAgICAgICBpZiAoIWNvbmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc2VydGlvbiBmYWlsZWQ6ICcgKyAobXNnIHx8ICcqKionKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgQVNTRVJUID0gYXNzZXJ0O1xuICAgIH1cblxuICAgIHRoaXMueXlHZXRTaGFyZWRTdGF0ZSA9IGZ1bmN0aW9uIHl5R2V0U2hhcmVkU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBzaGFyZWRTdGF0ZV95eTtcbiAgICB9O1xuXG5cblxuXG5cblxuXG5cbiAgICBmdW5jdGlvbiBzaGFsbG93X2NvcHlfbm9jbG9iYmVyKGRzdCwgc3JjKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gc3JjKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRzdFtrXSA9PT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgaykpIHtcbiAgICAgICAgICAgICAgICBkc3Rba10gPSBzcmNba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb3B5IHN0YXRlXG4gICAgc2hhbGxvd19jb3B5X25vY2xvYmJlcihzaGFyZWRTdGF0ZV95eSwgdGhpcy55eSk7XG5cbiAgICBzaGFyZWRTdGF0ZV95eS5sZXhlciA9IGxleGVyO1xuICAgIHNoYXJlZFN0YXRlX3l5LnBhcnNlciA9IHRoaXM7XG5cblxuXG5cblxuXG4gICAgLy8gRG9lcyB0aGUgc2hhcmVkIHN0YXRlIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGBwYXJzZUVycm9yYCB0aGF0IGFscmVhZHkgY29tZXMgd2l0aCB0aGlzIGluc3RhbmNlP1xuICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGVfeXkucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBmdW5jdGlvbiBwYXJzZUVycm9yQWx0KHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmICghRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBFeGNlcHRpb25DbGFzcyA9IHRoaXMuSmlzb25QYXJzZXJFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaGFyZWRTdGF0ZV95eS5wYXJzZUVycm9yLmNhbGwodGhpcywgc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gdGhpcy5vcmlnaW5hbFBhcnNlRXJyb3I7XG4gICAgfVxuXG4gICAgLy8gRG9lcyB0aGUgc2hhcmVkIHN0YXRlIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGBxdW90ZU5hbWVgIHRoYXQgYWxyZWFkeSBjb21lcyB3aXRoIHRoaXMgaW5zdGFuY2U/XG4gICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZV95eS5xdW90ZU5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5xdW90ZU5hbWUgPSBmdW5jdGlvbiBxdW90ZU5hbWVBbHQoaWRfc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhcmVkU3RhdGVfeXkucXVvdGVOYW1lLmNhbGwodGhpcywgaWRfc3RyKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1b3RlTmFtZSA9IHRoaXMub3JpZ2luYWxRdW90ZU5hbWU7XG4gICAgfVxuXG4gICAgLy8gc2V0IHVwIHRoZSBjbGVhbnVwIGZ1bmN0aW9uOyBtYWtlIGl0IGFuIEFQSSBzbyB0aGF0IGV4dGVybmFsIGNvZGUgY2FuIHJlLXVzZSB0aGlzIG9uZSBpbiBjYXNlIG9mXG4gICAgLy8gY2FsYW1pdGllcyBvciB3aGVuIHRoZSBgJW9wdGlvbnMgbm8tdHJ5LWNhdGNoYCBvcHRpb24gaGFzIGJlZW4gc3BlY2lmaWVkIGZvciB0aGUgZ3JhbW1hciwgaW4gd2hpY2hcbiAgICAvLyBjYXNlIHRoaXMgcGFyc2UoKSBBUEkgbWV0aG9kIGRvZXNuJ3QgY29tZSB3aXRoIGEgYGZpbmFsbHkgeyAuLi4gfWAgYmxvY2sgYW55IG1vcmUhXG4gICAgLy9cbiAgICAvLyBOT1RFOiBhcyB0aGlzIEFQSSB1c2VzIHBhcnNlKCkgYXMgYSBjbG9zdXJlLCBpdCBNVVNUIGJlIHNldCBhZ2FpbiBvbiBldmVyeSBwYXJzZSgpIGludm9jYXRpb24sXG4gICAgLy8gICAgICAgb3IgZWxzZSB5b3VyIGBzaGFyZWRTdGF0ZWAsIGV0Yy4gcmVmZXJlbmNlcyB3aWxsIGJlICp3cm9uZyohXG4gICAgdGhpcy5jbGVhbnVwQWZ0ZXJQYXJzZSA9IGZ1bmN0aW9uIHBhcnNlcl9jbGVhbnVwQWZ0ZXJQYXJzZShyZXN1bHRWYWx1ZSwgaW52b2tlX3Bvc3RfbWV0aG9kcywgZG9fbm90X251a2VfZXJyb3JpbmZvcykge1xuICAgICAgICB2YXIgcnY7XG5cbiAgICAgICAgaWYgKGludm9rZV9wb3N0X21ldGhvZHMpIHtcbiAgICAgICAgICAgIHZhciBoYXNoO1xuXG4gICAgICAgICAgICBpZiAoc2hhcmVkU3RhdGVfeXkucG9zdF9wYXJzZSB8fCB0aGlzLnBvc3RfcGFyc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gZXJyb3IgaGFzaCBpbmZvIGluc3RhbmNlOiB3ZSByZS11c2UgdGhpcyBBUEkgaW4gYSAqKm5vbi1lcnJvciBzaXR1YXRpb24qKlxuICAgICAgICAgICAgICAgIC8vIGFzIHRoaXMgb25lIGRlbGl2ZXJzIGFsbCBwYXJzZXIgaW50ZXJuYWxzIHJlYWR5IGZvciBhY2Nlc3MgYnkgdXNlcmxhbmQgY29kZS5cbiAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyhudWxsIC8qIG5vIGVycm9yISAqLywgbnVsbCAvKiBubyBleGNlcHRpb24hICovLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaGFyZWRTdGF0ZV95eS5wb3N0X3BhcnNlKSB7XG4gICAgICAgICAgICAgICAgcnYgPSBzaGFyZWRTdGF0ZV95eS5wb3N0X3BhcnNlLmNhbGwodGhpcywgc2hhcmVkU3RhdGVfeXksIHJlc3VsdFZhbHVlLCBoYXNoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ2ICE9PSAndW5kZWZpbmVkJykgcmVzdWx0VmFsdWUgPSBydjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvc3RfcGFyc2UpIHtcbiAgICAgICAgICAgICAgICBydiA9IHRoaXMucG9zdF9wYXJzZS5jYWxsKHRoaXMsIHNoYXJlZFN0YXRlX3l5LCByZXN1bHRWYWx1ZSwgaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydiAhPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFZhbHVlID0gcnY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNsZWFudXA6XG4gICAgICAgICAgICBpZiAoaGFzaCAmJiBoYXNoLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBoYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9fcmVlbnRyYW50X2NhbGxfZGVwdGggPiAxKSByZXR1cm4gcmVzdWx0VmFsdWU7ICAgICAgICAvLyBkbyBub3QgKHlldCkga2lsbCB0aGUgc2hhcmVkU3RhdGUgd2hlbiB0aGlzIGlzIGEgcmVlbnRyYW50IHJ1bi5cblxuICAgICAgICAvLyBjbGVhbiB1cCB0aGUgbGluZ2VyaW5nIGxleGVyIHN0cnVjdHVyZXMgYXMgd2VsbDpcbiAgICAgICAgaWYgKGxleGVyLmNsZWFudXBBZnRlckxleCkge1xuICAgICAgICAgICAgbGV4ZXIuY2xlYW51cEFmdGVyTGV4KGRvX25vdF9udWtlX2Vycm9yaW5mb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJldmVudCBsaW5nZXJpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyBmcm9tIGNhdXNpbmcgbWVtb3J5IGxlYWtzOlxuICAgICAgICBpZiAoc2hhcmVkU3RhdGVfeXkpIHtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlX3l5LmxleGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc2hhcmVkU3RhdGVfeXkucGFyc2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGxleGVyLnl5ID09PSBzaGFyZWRTdGF0ZV95eSkge1xuICAgICAgICAgICAgICAgIGxleGVyLnl5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNoYXJlZFN0YXRlX3l5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0aGlzLm9yaWdpbmFsUGFyc2VFcnJvcjtcbiAgICAgICAgdGhpcy5xdW90ZU5hbWUgPSB0aGlzLm9yaWdpbmFsUXVvdGVOYW1lO1xuXG4gICAgICAgIC8vIG51a2UgdGhlIHZzdGFja1tdIGFycmF5IGF0IGxlYXN0IGFzIHRoYXQgb25lIHdpbGwgc3RpbGwgcmVmZXJlbmNlIG9ic29sZXRlZCB1c2VyIHZhbHVlcy5cbiAgICAgICAgLy8gVG8gYmUgc2FmZSwgd2UgbnVrZSB0aGUgb3RoZXIgaW50ZXJuYWwgc3RhY2sgY29sdW1ucyBhcyB3ZWxsLi4uXG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7ICAgICAgICAgICAgICAgLy8gZmFzdGVzdCB3YXkgdG8gbnVrZSBhbiBhcnJheSB3aXRob3V0IG92ZXJseSBib3RoZXJpbmcgdGhlIEdDXG4gICAgICAgIHNzdGFjay5sZW5ndGggPSAwO1xuXG4gICAgICAgIHZzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBzcCA9IDA7XG5cbiAgICAgICAgLy8gbnVrZSB0aGUgZXJyb3IgaGFzaCBpbmZvIGluc3RhbmNlcyBjcmVhdGVkIGR1cmluZyB0aGlzIHJ1bi5cbiAgICAgICAgLy8gVXNlcmxhbmQgY29kZSBtdXN0IENPUFkgYW55IGRhdGEvcmVmZXJlbmNlc1xuICAgICAgICAvLyBpbiB0aGUgZXJyb3IgaGFzaCBpbnN0YW5jZShzKSBpdCBpcyBtb3JlIHBlcm1hbmVudGx5IGludGVyZXN0ZWQgaW4uXG4gICAgICAgIGlmICghZG9fbm90X251a2VfZXJyb3JpbmZvcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX19lcnJvcl9pbmZvcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX19lcnJvcl9pbmZvc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgdHlwZW9mIGVsLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX19lcnJvcl9pbmZvcy5sZW5ndGggPSAwO1xuXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRWYWx1ZTtcbiAgICB9O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAvLyBOT1RFOiBhcyB0aGlzIEFQSSB1c2VzIHBhcnNlKCkgYXMgYSBjbG9zdXJlLCBpdCBNVVNUIGJlIHNldCBhZ2FpbiBvbiBldmVyeSBwYXJzZSgpIGludm9jYXRpb24sXG4gICAgLy8gICAgICAgb3IgZWxzZSB5b3VyIGBsZXhlcmAsIGBzaGFyZWRTdGF0ZWAsIGV0Yy4gcmVmZXJlbmNlcyB3aWxsIGJlICp3cm9uZyohXG4gICAgdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyA9IGZ1bmN0aW9uIHBhcnNlcl9jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyhtc2csIGV4LCBleHBlY3RlZCwgcmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdmFyIHBlaSA9IHtcbiAgICAgICAgICAgIGVyclN0cjogbXNnLFxuICAgICAgICAgICAgZXhjZXB0aW9uOiBleCxcbiAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgdmFsdWU6IGxleGVyLnl5dGV4dCxcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLmRlc2NyaWJlU3ltYm9sKHN5bWJvbCkgfHwgc3ltYm9sLFxuICAgICAgICAgICAgdG9rZW5faWQ6IHN5bWJvbCxcbiAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLFxuXG4gICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICByZWNvdmVyYWJsZTogcmVjb3ZlcmFibGUsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIG5ld19zdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgICBzeW1ib2xfc3RhY2s6IHN0YWNrLFxuICAgICAgICAgICAgc3RhdGVfc3RhY2s6IHNzdGFjayxcbiAgICAgICAgICAgIHZhbHVlX3N0YWNrOiB2c3RhY2ssXG5cbiAgICAgICAgICAgIHN0YWNrX3BvaW50ZXI6IHNwLFxuICAgICAgICAgICAgeXk6IHNoYXJlZFN0YXRlX3l5LFxuICAgICAgICAgICAgbGV4ZXI6IGxleGVyLFxuICAgICAgICAgICAgcGFyc2VyOiB0aGlzLFxuXG4gICAgICAgICAgICAvLyBhbmQgbWFrZSBzdXJlIHRoZSBlcnJvciBpbmZvIGRvZXNuJ3Qgc3RheSBkdWUgdG8gcG90ZW50aWFsXG4gICAgICAgICAgICAvLyByZWYgY3ljbGUgdmlhIHVzZXJsYW5kIGNvZGUgbWFuaXB1bGF0aW9ucy5cbiAgICAgICAgICAgIC8vIFRoZXNlIHdvdWxkIG90aGVyd2lzZSBhbGwgYmUgbWVtb3J5IGxlYWsgb3Bwb3J0dW5pdGllcyFcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgb25seSBhcnJheSBhbmQgb2JqZWN0IHJlZmVyZW5jZXMgYXJlIG51a2VkIGFzIHRob3NlXG4gICAgICAgICAgICAvLyBjb25zdGl0dXRlIHRoZSBzZXQgb2YgZWxlbWVudHMgd2hpY2ggY2FuIHByb2R1Y2UgYSBjeWNsaWMgcmVmLlxuICAgICAgICAgICAgLy8gVGhlIHJlc3Qgb2YgdGhlIG1lbWJlcnMgaXMga2VwdCBpbnRhY3QgYXMgdGhleSBhcmUgaGFybWxlc3MuXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cnVjdFBhcnNlRXJyb3JJbmZvKCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjeWNsaWMgcmVmZXJlbmNlcyBhZGRlZCB0byBlcnJvciBpbmZvOlxuICAgICAgICAgICAgICAgIC8vIGluZm8ueXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGluZm8ubGV4ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGluZm8udmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGluZm8udmFsdWVfc3RhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIC4uLlxuICAgICAgICAgICAgICAgIHZhciByZWMgPSAhIXRoaXMucmVjb3ZlcmFibGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmFibGUgPSByZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRyYWNrIHRoaXMgaW5zdGFuY2Ugc28gd2UgY2FuIGBkZXN0cm95KClgIGl0IG9uY2Ugd2UgZGVlbSBpdCBzdXBlcmZsdW91cyBhbmQgcmVhZHkgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiFcbiAgICAgICAgdGhpcy5fX2Vycm9yX2luZm9zLnB1c2gocGVpKTtcbiAgICAgICAgcmV0dXJuIHBlaTtcbiAgICB9O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0Tm9uVGVybWluYWxGcm9tQ29kZShzeW1ib2wpIHtcbiAgICAgICAgdmFyIHRva2VuTmFtZSA9IHNlbGYuZ2V0U3ltYm9sTmFtZShzeW1ib2wpO1xuICAgICAgICBpZiAoIXRva2VuTmFtZSkge1xuICAgICAgICAgICAgdG9rZW5OYW1lID0gc3ltYm9sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbk5hbWU7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdGRMZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleGVyLmxleCgpO1xuICAgICAgICAvLyBpZiB0b2tlbiBpc24ndCBpdHMgbnVtZXJpYyB2YWx1ZSwgY29udmVydFxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbiB8fCBFT0Y7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmFzdExleCgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbGV4ZXIuZmFzdExleCgpO1xuICAgICAgICAvLyBpZiB0b2tlbiBpc24ndCBpdHMgbnVtZXJpYyB2YWx1ZSwgY29udmVydFxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbiB8fCBFT0Y7XG4gICAgfVxuXG4gICAgdmFyIGxleCA9IHN0ZExleDtcblxuXG4gICAgdmFyIHN0YXRlLCBhY3Rpb24sIHIsIHQ7XG4gICAgdmFyIHl5dmFsID0ge1xuICAgICAgICAkOiB0cnVlLFxuICAgICAgICBfJDogdW5kZWZpbmVkLFxuICAgICAgICB5eTogc2hhcmVkU3RhdGVfeXlcbiAgICB9O1xuICAgIHZhciBwO1xuICAgIHZhciB5eXJ1bGVsZW47XG4gICAgdmFyIHRoaXNfcHJvZHVjdGlvbjtcbiAgICB2YXIgbmV3U3RhdGU7XG4gICAgdmFyIHJldHZhbCA9IGZhbHNlO1xuXG5cbiAgICB0cnkge1xuICAgICAgICB0aGlzLl9fcmVlbnRyYW50X2NhbGxfZGVwdGgrKztcblxuICAgICAgICBsZXhlci5zZXRJbnB1dChpbnB1dCwgc2hhcmVkU3RhdGVfeXkpO1xuXG4gICAgICAgIC8vIE5PVEU6IHdlICphc3N1bWUqIG5vIGxleGVyIHByZS9wb3N0IGhhbmRsZXJzIGFyZSBzZXQgdXAgKmFmdGVyKiBcbiAgICAgICAgLy8gdGhpcyBpbml0aWFsIGBzZXRJbnB1dCgpYCBjYWxsOiBoZW5jZSB3ZSBjYW4gbm93IGNoZWNrIGFuZCBkZWNpZGVcbiAgICAgICAgLy8gd2hldGhlciB3ZSdsbCBnbyB3aXRoIHRoZSBzdGFuZGFyZCwgc2xvd2VyLCBsZXgoKSBBUEkgb3IgdGhlXG4gICAgICAgIC8vIGBmYXN0X2xleCgpYCBvbmU6XG4gICAgICAgIGlmICh0eXBlb2YgbGV4ZXIuY2FuSVVzZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGxleGVySW5mbyA9IGxleGVyLmNhbklVc2UoKTtcbiAgICAgICAgICAgIGlmIChsZXhlckluZm8uZmFzdExleCAmJiB0eXBlb2YgZmFzdExleCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxleCA9IGZhc3RMZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG5cblxuXG4gICAgICAgIHZzdGFja1tzcF0gPSBudWxsO1xuICAgICAgICBzc3RhY2tbc3BdID0gMDtcbiAgICAgICAgc3RhY2tbc3BdID0gMDtcbiAgICAgICAgKytzcDtcblxuXG5cblxuXG4gICAgICAgIGlmICh0aGlzLnByZV9wYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5wcmVfcGFyc2UuY2FsbCh0aGlzLCBzaGFyZWRTdGF0ZV95eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXJlZFN0YXRlX3l5LnByZV9wYXJzZSkge1xuICAgICAgICAgICAgc2hhcmVkU3RhdGVfeXkucHJlX3BhcnNlLmNhbGwodGhpcywgc2hhcmVkU3RhdGVfeXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3U3RhdGUgPSBzc3RhY2tbc3AgLSAxXTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgLy8gcmV0cmlldmUgc3RhdGUgbnVtYmVyIGZyb20gdG9wIG9mIHN0YWNrXG4gICAgICAgICAgICBzdGF0ZSA9IG5ld1N0YXRlOyAgICAgICAgICAgICAgIC8vIHNzdGFja1tzcCAtIDFdO1xuXG4gICAgICAgICAgICAvLyB1c2UgZGVmYXVsdCBhY3Rpb25zIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gMjtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2luZ2xlIGA9PWAgY29uZGl0aW9uIGJlbG93IGNvdmVycyBib3RoIHRoZXNlIGA9PT1gIGNvbXBhcmlzb25zIGluIGEgc2luZ2xlXG4gICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9uOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PT0gJ3VuZGVmaW5lZCcpIC4uLlxuICAgICAgICAgICAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZWFkIGFjdGlvbiBmb3IgY3VycmVudCBzdGF0ZSBhbmQgZmlyc3QgaW5wdXRcbiAgICAgICAgICAgICAgICB0ID0gKHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXSkgfHwgTk9fQUNUSU9OO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdFsxXTtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSB0WzBdO1xuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgcGFyc2UgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyU3RyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyU3ltYm9sRGVzY3IgPSAodGhpcy5kZXNjcmliZVN5bWJvbChzeW1ib2wpIHx8IHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZCA9IHRoaXMuY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQoc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcG9ydCBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxleGVyLnl5bGluZW5vID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArIChsZXhlci55eWxpbmVubyArIDEpICsgJzogJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvcjogJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxleGVyLnNob3dQb3NpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyICs9ICdcXG4nICsgbGV4ZXIuc2hvd1Bvc2l0aW9uKDc5IC0gMTAsIDEwKSArICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciArPSAnRXhwZWN0aW5nICcgKyBleHBlY3RlZC5qb2luKCcsICcpICsgJywgZ290IHVuZXhwZWN0ZWQgJyArIGVyclN5bWJvbERlc2NyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyICs9ICdVbmV4cGVjdGVkICcgKyBlcnJTeW1ib2xEZXNjcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QgcmVjb3ZlciBmcm9tIHRoZSBlcnJvciFcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8oZXJyU3RyLCBudWxsLCBleHBlY3RlZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uUGFyc2VyRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSByO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB9XG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBjYXRjaCBtaXNjLiBwYXJzZSBmYWlsdXJlczpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuLCB1bmxlc3MgcmVzb2x2ZSBkZWZhdWx0cyBhcmUgb2ZmXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSB0aGlzLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJyArIHN0YXRlICsgJywgdG9rZW46ICcgKyBzeW1ib2wsIG51bGwsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvblBhcnNlckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQW5vdGhlciBjYXNlIG9mIGJldHRlciBzYWZlIHRoYW4gc29ycnk6IGluIGNhc2Ugc3RhdGUgdHJhbnNpdGlvbnMgY29tZSBvdXQgb2YgYW5vdGhlciBlcnJvciByZWNvdmVyeSBwcm9jZXNzXG4gICAgICAgICAgICAgICAgLy8gb3IgYSBidWdneSBMVVQgKExvb2tVcCBUYWJsZSk6XG4gICAgICAgICAgICAgICAgcCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ1BhcnNpbmcgaGFsdGVkLiBObyB2aWFibGUgZXJyb3IgcmVjb3ZlcnkgYXBwcm9hY2ggYXZhaWxhYmxlIGR1ZSB0byBpbnRlcm5hbCBzeXN0ZW0gZmFpbHVyZS4nLCBudWxsLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgciA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvblBhcnNlckVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBzaGlmdDpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzdGFja1tzcF0gPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgdnN0YWNrW3NwXSA9IGxleGVyLnl5dGV4dDtcblxuICAgICAgICAgICAgICAgIHNzdGFja1tzcF0gPSBuZXdTdGF0ZTsgLy8gcHVzaCBzdGF0ZVxuXG4gICAgICAgICAgICAgICAgKytzcDtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSAwO1xuXG5cblxuXG4gICAgICAgICAgICAgICAgLy8gUGljayB1cCB0aGUgbGV4ZXIgZGV0YWlscyBmb3IgdGhlIGN1cnJlbnQgc3ltYm9sIGFzIHRoYXQgb25lIGlzIG5vdCAnbG9vay1haGVhZCcgYW55IG1vcmU6XG5cblxuXG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gcmVkdWNlOlxuICAgICAgICAgICAgY2FzZSAyOlxuXG5cblxuICAgICAgICAgICAgICAgIHRoaXNfcHJvZHVjdGlvbiA9IHRoaXMucHJvZHVjdGlvbnNfW25ld1N0YXRlIC0gMV07ICAvLyBgdGhpcy5wcm9kdWN0aW9uc19bXWAgaXMgemVyby1iYXNlZCBpbmRleGVkIHdoaWxlIHN0YXRlcyBzdGFydCBmcm9tIDEgdXB3YXJkcy4uLlxuICAgICAgICAgICAgICAgIHl5cnVsZWxlbiA9IHRoaXNfcHJvZHVjdGlvblsxXTtcblxuXG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh5eXZhbCwgbmV3U3RhdGUsIHNwIC0gMSwgdnN0YWNrKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcG9wIG9mZiBzdGFja1xuICAgICAgICAgICAgICAgIHNwIC09IHl5cnVsZWxlbjtcblxuICAgICAgICAgICAgICAgIC8vIGRvbid0IG92ZXJ3cml0ZSB0aGUgYHN5bWJvbGAgdmFyaWFibGU6IHVzZSBhIGxvY2FsIHZhciB0byBzcGVlZCB0aGluZ3MgdXA6XG4gICAgICAgICAgICAgICAgdmFyIG50c3ltYm9sID0gdGhpc19wcm9kdWN0aW9uWzBdOyAgICAvLyBwdXNoIG5vbnRlcm1pbmFsIChyZWR1Y2UpXG4gICAgICAgICAgICAgICAgc3RhY2tbc3BdID0gbnRzeW1ib2w7XG4gICAgICAgICAgICAgICAgdnN0YWNrW3NwXSA9IHl5dmFsLiQ7XG5cbiAgICAgICAgICAgICAgICAvLyBnb3RvIG5ldyBzdGF0ZSA9IHRhYmxlW1NUQVRFXVtOT05URVJNSU5BTF1cbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3NzdGFja1tzcCAtIDFdXVtudHN5bWJvbF07XG4gICAgICAgICAgICAgICAgc3N0YWNrW3NwXSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgICsrc3A7XG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGFjY2VwdDpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoc3AgIT09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYCRhY2NlcHRgIHJ1bGUncyBgJCRgIHJlc3VsdCwgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBKSVNPTiBhbHdheXMgYWRkcyB0aGlzIHRvcC1tb3N0IGAkYWNjZXB0YCBydWxlICh3aXRoIGltcGxpY2l0LFxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LCBhY3Rpb24pOlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgJGFjY2VwdDogPHN0YXJ0U3ltYm9sPiAkZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgJXsgJCQgPSAkMTsgQCQgPSBAMTsgJX1cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2gsIGNvbWJpbmVkIHdpdGggdGhlIHBhcnNlIGtlcm5lbCdzIGAkYWNjZXB0YCBzdGF0ZSBiZWhhdmlvdXIgY29kZWQgYmVsb3csXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgcHJvZHVjZSB0aGUgYCQkYCB2YWx1ZSBvdXRwdXQgb2YgdGhlIDxzdGFydFN5bWJvbD4gcnVsZSBhcyB0aGUgcGFyc2UgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAvLyBJRkYgdGhhdCByZXN1bHQgaXMgKm5vdCogYHVuZGVmaW5lZGAuIChTZWUgYWxzbyB0aGUgcGFyc2VyIGtlcm5lbCBjb2RlLilcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gY29kZTpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAle1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBAJCA9IEAxOyAgICAgICAgICAgIC8vIGlmIGxvY2F0aW9uIHRyYWNraW5nIHN1cHBvcnQgaXMgaW5jbHVkZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAkMSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJDE7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgLy8gdGhlIGRlZmF1bHQgcGFyc2UgcmVzdWx0IGlmIHRoZSBydWxlIGFjdGlvbnMgZG9uJ3QgcHJvZHVjZSBhbnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICV9XG4gICAgICAgICAgICAgICAgICAgIHNwLS07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdnN0YWNrW3NwXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHZzdGFja1tzcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJyZWFrIG91dCBvZiBsb29wOiB3ZSBhY2NlcHQgb3IgZmFpbCB3aXRoIGVycm9yXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIC8vIHJlcG9ydCBleGNlcHRpb25zIHRocm91Z2ggdGhlIHBhcnNlRXJyb3IgY2FsbGJhY2sgdG9vLCBidXQga2VlcCB0aGUgZXhjZXB0aW9uIGludGFjdFxuICAgICAgICAvLyBpZiBpdCBpcyBhIGtub3duIHBhcnNlciBvciBsZXhlciBlcnJvciB3aGljaCBoYXMgYmVlbiB0aHJvd24gYnkgcGFyc2VFcnJvcigpIGFscmVhZHk6XG4gICAgICAgIGlmIChleCBpbnN0YW5jZW9mIHRoaXMuSmlzb25QYXJzZXJFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGV4ZXIgJiYgdHlwZW9mIGxleGVyLkppc29uTGV4ZXJFcnJvciA9PT0gJ2Z1bmN0aW9uJyAmJiBleCBpbnN0YW5jZW9mIGxleGVyLkppc29uTGV4ZXJFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cblxuICAgICAgICBwID0gdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbygnUGFyc2luZyBhYm9ydGVkIGR1ZSB0byBleGNlcHRpb24uJywgZXgsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgcmV0dmFsID0gZmFsc2U7XG4gICAgICAgIHIgPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25QYXJzZXJFcnJvcik7XG4gICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHI7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXR2YWwgPSB0aGlzLmNsZWFudXBBZnRlclBhcnNlKHJldHZhbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX19yZWVudHJhbnRfY2FsbF9kZXB0aC0tO1xuICAgIH0gICAvLyAvZmluYWxseVxuXG4gICAgcmV0dXJuIHJldHZhbDtcbn1cbn07XG5wYXJzZXIub3JpZ2luYWxQYXJzZUVycm9yID0gcGFyc2VyLnBhcnNlRXJyb3I7XG5wYXJzZXIub3JpZ2luYWxRdW90ZU5hbWUgPSBwYXJzZXIucXVvdGVOYW1lO1xuLyogbGV4ZXIgZ2VuZXJhdGVkIGJ5IGppc29uLWxleCAwLjYuMS0yMTUgKi9cblxuLypcbiAqIFJldHVybnMgYSBMZXhlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKlxuICogIExleGVyOiB7XG4gKiAgICB5eToge30gICAgIFRoZSBzby1jYWxsZWQgXCJzaGFyZWQgc3RhdGVcIiBvciByYXRoZXIgdGhlICpzb3VyY2UqIG9mIGl0O1xuICogICAgICAgICAgICAgICB0aGUgcmVhbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWAgcGFzc2VkIGFyb3VuZCB0b1xuICogICAgICAgICAgICAgICB0aGUgcnVsZSBhY3Rpb25zLCBldGMuIGlzIGEgZGlyZWN0IHJlZmVyZW5jZSFcbiAqXG4gKiAgICAgICAgICAgICAgIFRoaXMgXCJzaGFyZWQgY29udGV4dFwiIG9iamVjdCB3YXMgcGFzc2VkIHRvIHRoZSBsZXhlciBieSB3YXkgb2YgXG4gKiAgICAgICAgICAgICAgIHRoZSBgbGV4ZXIuc2V0SW5wdXQoc3RyLCB5eSlgIEFQSSBiZWZvcmUgeW91IG1heSB1c2UgaXQuXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIFwic2hhcmVkIGNvbnRleHRcIiBvYmplY3QgaXMgcGFzc2VkIHRvIHRoZSBsZXhlciBhY3Rpb24gY29kZSBpbiBgcGVyZm9ybUFjdGlvbigpYFxuICogICAgICAgICAgICAgICBzbyB1c2VybGFuZCBjb2RlIGluIHRoZSBsZXhlciBhY3Rpb25zIG1heSBjb21tdW5pY2F0ZSB3aXRoIHRoZSBvdXRzaWRlIHdvcmxkIFxuICogICAgICAgICAgICAgICBhbmQvb3Igb3RoZXIgbGV4ZXIgcnVsZXMnIGFjdGlvbnMgaW4gbW9yZSBvciBsZXNzIGNvbXBsZXggd2F5cy5cbiAqXG4gKiAgfVxuICpcbiAqICBMZXhlci5wcm90b3R5cGU6IHtcbiAqICAgIEVPRjogMSxcbiAqICAgIEVSUk9SOiAyLFxuICpcbiAqICAgIHl5OiAgICAgICAgVGhlIG92ZXJhbGwgXCJzaGFyZWQgY29udGV4dFwiIG9iamVjdCByZWZlcmVuY2UuXG4gKlxuICogICAgSmlzb25MZXhlckVycm9yOiBmdW5jdGlvbihtc2csIGhhc2gpLFxuICpcbiAqICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGxleGVyX19wZXJmb3JtQWN0aW9uKHl5LCB5eXJ1bGVudW1iZXIsIFlZX1NUQVJUKSxcbiAqXG4gKiAgICAgICAgICAgICAgIFRoZSBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFuZCBgdGhpc2AgaGF2ZSB0aGUgZm9sbG93aW5nIHZhbHVlL21lYW5pbmc6XG4gKiAgICAgICAgICAgICAgIC0gYHRoaXNgICAgIDogcmVmZXJlbmNlIHRvIHRoZSBgbGV4ZXJgIGluc3RhbmNlLiBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB5eV9gIGlzIGFuIGFsaWFzIGZvciBgdGhpc2AgbGV4ZXIgaW5zdGFuY2UgcmVmZXJlbmNlIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5YCAgICAgIDogYSByZWZlcmVuY2UgdG8gdGhlIGB5eWAgXCJzaGFyZWQgc3RhdGVcIiBvYmplY3Qgd2hpY2ggd2FzIHBhc3NlZCB0byB0aGUgbGV4ZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSB3YXkgb2YgdGhlIGBsZXhlci5zZXRJbnB1dChzdHIsIHl5KWAgQVBJIGJlZm9yZS5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90ZTpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZXh0cmEgYXJndW1lbnRzIHlvdSBzcGVjaWZpZWQgaW4gdGhlIGAlcGFyc2UtcGFyYW1gIHN0YXRlbWVudCBpbiB5b3VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKipwYXJzZXIqKiBncmFtbWFyIGRlZmluaXRpb24gZmlsZSBhcmUgcGFzc2VkIHRvIHRoZSBsZXhlciB2aWEgdGhpcyBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UgYXMgbWVtYmVyIHZhcmlhYmxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5cnVsZW51bWJlcmAgICA6IGluZGV4IG9mIHRoZSBtYXRjaGVkIGxleGVyIHJ1bGUgKHJlZ2V4KSwgdXNlZCBpbnRlcm5hbGx5LlxuICpcbiAqICAgICAgICAgICAgICAgLSBgWVlfU1RBUlRgOiB0aGUgY3VycmVudCBsZXhlciBcInN0YXJ0IGNvbmRpdGlvblwiIHN0YXRlLlxuICpcbiAqICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpLFxuICpcbiAqICAgIGNvbnN0cnVjdExleEVycm9ySW5mbzogZnVuY3Rpb24oZXJyb3JfbWVzc2FnZSwgaXNfcmVjb3ZlcmFibGUpLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgIFByb2R1Y2VzIGEgbmV3IGVycm9ySW5mbyAnaGFzaCBvYmplY3QnIHdoaWNoIGNhbiBiZSBwYXNzZWQgaW50byBgcGFyc2VFcnJvcigpYC5cbiAqICAgICAgICAgICAgICAgU2VlIGl0J3MgdXNlIGluIHRoaXMgbGV4ZXIga2VybmVsIGluIG1hbnkgcGxhY2VzOyBleGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICAgICAgICAgICAgICAgIHZhciBpbmZvT2JqID0gbGV4ZXIuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ2ZhaWwhJywgdHJ1ZSk7XG4gKiAgICAgICAgICAgICAgICAgICB2YXIgcmV0VmFsID0gbGV4ZXIucGFyc2VFcnJvcihpbmZvT2JqLmVyclN0ciwgaW5mb09iaiwgbGV4ZXIuSmlzb25MZXhlckVycm9yKTtcbiAqXG4gKiAgICBvcHRpb25zOiB7IC4uLiBsZXhlciAlb3B0aW9ucyAuLi4gfSxcbiAqXG4gKiAgICBsZXg6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgICAgICAgIFByb2R1Y2Ugb25lIHRva2VuIG9mIGxleGVkIGlucHV0LCB3aGljaCB3YXMgcGFzc2VkIGluIGVhcmxpZXIgdmlhIHRoZSBgbGV4ZXIuc2V0SW5wdXQoKWAgQVBJLlxuICogICAgICAgICAgICAgICBZb3UgTUFZIHVzZSB0aGUgYWRkaXRpb25hbCBgYXJncy4uLmAgcGFyYW1ldGVycyBhcyBwZXIgYCVwYXJzZS1wYXJhbWAgc3BlYyBvZiB0aGUgKipsZXhlcioqIGdyYW1tYXI6XG4gKiAgICAgICAgICAgICAgIHRoZXNlIGV4dHJhIGBhcmdzLi4uYCBhcmUgYWRkZWQgdmVyYmF0aW0gdG8gdGhlIGB5eWAgb2JqZWN0IHJlZmVyZW5jZSBhcyBtZW1iZXIgdmFyaWFibGVzLlxuICpcbiAqICAgICAgICAgICAgICAgV0FSTklORzpcbiAqICAgICAgICAgICAgICAgTGV4ZXIncyBhZGRpdGlvbmFsIGBhcmdzLi4uYCBwYXJhbWV0ZXJzICh2aWEgbGV4ZXIncyBgJXBhcnNlLXBhcmFtYCkgTUFZIGNvbmZsaWN0IHdpdGhcbiAqICAgICAgICAgICAgICAgYW55IGF0dHJpYnV0ZXMgYWxyZWFkeSBhZGRlZCB0byBgeXlgIGJ5IHRoZSAqKnBhcnNlcioqIG9yIHRoZSBqaXNvbiBydW4tdGltZTsgXG4gKiAgICAgICAgICAgICAgIHdoZW4gc3VjaCBhIGNvbGxpc2lvbiBpcyBkZXRlY3RlZCBhbiBleGNlcHRpb24gaXMgdGhyb3duIHRvIHByZXZlbnQgdGhlIGdlbmVyYXRlZCBydW4tdGltZSBcbiAqICAgICAgICAgICAgICAgZnJvbSBzaWxlbnRseSBhY2NlcHRpbmcgdGhpcyBjb25mdXNpbmcgYW5kIHBvdGVudGlhbGx5IGhhemFyZG91cyBzaXR1YXRpb24hIFxuICpcbiAqICAgIGNsZWFudXBBZnRlckxleDogZnVuY3Rpb24oZG9fbm90X251a2VfZXJyb3JpbmZvcyksXG4gKiAgICAgICAgICAgICAgIEhlbHBlciBmdW5jdGlvbi5cbiAqXG4gKiAgICAgICAgICAgICAgIFRoaXMgaGVscGVyIEFQSSBpcyBpbnZva2VkIHdoZW4gdGhlICoqcGFyc2UgcHJvY2VzcyoqIGhhcyBjb21wbGV0ZWQ6IGl0IGlzIHRoZSByZXNwb25zaWJpbGl0eVxuICogICAgICAgICAgICAgICBvZiB0aGUgKipwYXJzZXIqKiAob3IgdGhlIGNhbGxpbmcgdXNlcmxhbmQgY29kZSkgdG8gaW52b2tlIHRoaXMgbWV0aG9kIG9uY2UgY2xlYW51cCBpcyBkZXNpcmVkLiBcbiAqXG4gKiAgICAgICAgICAgICAgIFRoaXMgaGVscGVyIG1heSBiZSBpbnZva2VkIGJ5IHVzZXIgY29kZSB0byBlbnN1cmUgdGhlIGludGVybmFsIGxleGVyIGdldHMgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKlxuICogICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0LCBbeXldKSxcbiAqXG4gKlxuICogICAgaW5wdXQ6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICpcbiAqXG4gKiAgICBtb3JlOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICByZWplY3Q6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIGxlc3M6IGZ1bmN0aW9uKG4pLFxuICpcbiAqXG4gKiAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICpcbiAqXG4gKiAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbihuKSxcbiAqXG4gKlxuICogICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCksXG4gKlxuICpcbiAqICAgIG5leHQ6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIGJlZ2luOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICpcbiAqXG4gKiAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gKlxuICpcbiAqICAgIHBvcFN0YXRlOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICB0b3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgc3RhdGVTdGFja1NpemU6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sIHl5cnVsZW51bWJlciwgWVlfU1RBUlQpLFxuICpcbiAqXG4gKiAgICBydWxlczogWy4uLl0sXG4gKlxuICpcbiAqICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICogIH1cbiAqXG4gKlxuICogIHRva2VuIGxvY2F0aW9uIGluZm8gKGB5eWxsb2NgKToge1xuICogICAgZmlyc3RfbGluZTogbixcbiAqICAgIGxhc3RfbGluZTogbixcbiAqICAgIGZpcnN0X2NvbHVtbjogbixcbiAqICAgIGxhc3RfY29sdW1uOiBuLFxuICogICAgcmFuZ2U6IFtzdGFydF9udW1iZXIsIGVuZF9udW1iZXJdXG4gKiAgICAgICAgICAgICAgICh3aGVyZSB0aGUgbnVtYmVycyBhcmUgaW5kZXhlcyBpbnRvIHRoZSBpbnB1dCBzdHJpbmcsIHplcm8tYmFzZWQpXG4gKiAgfVxuICpcbiAqIC0tLVxuICpcbiAqIFRoZSBgcGFyc2VFcnJvcmAgZnVuY3Rpb24gcmVjZWl2ZXMgYSAnaGFzaCcgb2JqZWN0IHdpdGggdGhlc2UgbWVtYmVycyBmb3IgbGV4ZXIgZXJyb3JzOlxuICpcbiAqICB7XG4gKiAgICB0ZXh0OiAgICAgICAgKG1hdGNoZWQgdGV4dClcbiAqICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpXG4gKiAgICB0b2tlbl9pZDogICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiBudW1lcmljIElELCBpZiBhbnkpXG4gKiAgICBsaW5lOiAgICAgICAgKHl5bGluZW5vKVxuICogICAgbG9jOiAgICAgICAgICh5eWxsb2MpXG4gKiAgICByZWNvdmVyYWJsZTogKGJvb2xlYW46IFRSVUUgd2hlbiB0aGUgcGFyc2VyIE1BWSBoYXZlIGFuIGVycm9yIHJlY292ZXJ5IHJ1bGVcbiAqICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlIGZvciB0aGlzIHBhcnRpY3VsYXIgZXJyb3IpXG4gKiAgICB5eTogICAgICAgICAgKG9iamVjdDogdGhlIGN1cnJlbnQgcGFyc2VyIGludGVybmFsIFwic2hhcmVkIHN0YXRlXCIgYHl5YFxuICogICAgICAgICAgICAgICAgICBhcyBpcyBhbHNvIGF2YWlsYWJsZSBpbiB0aGUgcnVsZSBhY3Rpb25zOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgbGV4ZXI6ICAgICAgIChyZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbGV4ZXIgaW5zdGFuY2UgdXNlZCBieSB0aGUgcGFyc2VyKVxuICogIH1cbiAqXG4gKiB3aGlsZSBgdGhpc2Agd2lsbCByZWZlcmVuY2UgdGhlIGN1cnJlbnQgbGV4ZXIgaW5zdGFuY2UuXG4gKlxuICogV2hlbiBgcGFyc2VFcnJvcmAgaXMgaW52b2tlZCBieSB0aGUgbGV4ZXIsIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGxcbiAqIGF0dGVtcHQgdG8gaW52b2tlIGB5eS5wYXJzZXIucGFyc2VFcnJvcigpYDsgd2hlbiB0aGlzIGNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZFxuICogaXQgd2lsbCB0cnkgdG8gaW52b2tlIGB5eS5wYXJzZUVycm9yKClgIGluc3RlYWQuIFdoZW4gdGhhdCBjYWxsYmFjayBpcyBhbHNvIG5vdFxuICogcHJvdmlkZWQsIGEgYEppc29uTGV4ZXJFcnJvcmAgZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIGNvbnRhaW5pbmcgdGhlIGVycm9yXG4gKiBtZXNzYWdlIGFuZCBgaGFzaGAsIGFzIGNvbnN0cnVjdGVkIGJ5IHRoZSBgY29uc3RydWN0TGV4RXJyb3JJbmZvKClgIEFQSS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGxleGVyJ3MgYEppc29uTGV4ZXJFcnJvcmAgZXJyb3IgY2xhc3MgaXMgcGFzc2VkIHZpYSB0aGVcbiAqIGBFeGNlcHRpb25DbGFzc2AgYXJndW1lbnQsIHdoaWNoIGlzIGludm9rZWQgdG8gY29uc3RydWN0IHRoZSBleGNlcHRpb25cbiAqIGluc3RhbmNlIHRvIGJlIHRocm93biwgc28gdGVjaG5pY2FsbHkgYHBhcnNlRXJyb3JgIHdpbGwgdGhyb3cgdGhlIG9iamVjdFxuICogcHJvZHVjZWQgYnkgdGhlIGBuZXcgRXhjZXB0aW9uQ2xhc3Moc3RyLCBoYXNoKWAgSmF2YVNjcmlwdCBleHByZXNzaW9uLlxuICpcbiAqIC0tLVxuICpcbiAqIFlvdSBjYW4gc3BlY2lmeSBsZXhlciBvcHRpb25zIGJ5IHNldHRpbmcgLyBtb2RpZnlpbmcgdGhlIGAub3B0aW9uc2Agb2JqZWN0IG9mIHlvdXIgTGV4ZXIgaW5zdGFuY2UuXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBhdmFpbGFibGU6XG4gKlxuICogKE9wdGlvbnMgYXJlIHBlcm1hbmVudC4pXG4gKiAgXG4gKiAgeXk6IHtcbiAqICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcylcbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBwYXJzZUVycm9yYCBmdW5jdGlvbi5cbiAqICB9XG4gKlxuICogIGxleGVyLm9wdGlvbnM6IHtcbiAqICAgICAgcHJlX2xleDogIGZ1bmN0aW9uKClcbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCBiZWZvcmUgdGhlIGxleGVyIGlzIGludm9rZWQgdG8gcHJvZHVjZSBhbm90aGVyIHRva2VuLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqICAgICAgcG9zdF9sZXg6IGZ1bmN0aW9uKHRva2VuKSB7IHJldHVybiB0b2tlbjsgfVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIHdoZW4gdGhlIGxleGVyIGhhcyBwcm9kdWNlZCBhIHRva2VuIGB0b2tlbmA7XG4gKiAgICAgICAgICAgICAgICAgdGhpcyBmdW5jdGlvbiBjYW4gb3ZlcnJpZGUgdGhlIHJldHVybmVkIHRva2VuIHZhbHVlIGJ5IHJldHVybmluZyBhbm90aGVyLlxuICogICAgICAgICAgICAgICAgIFdoZW4gaXQgZG9lcyBub3QgcmV0dXJuIGFueSAodHJ1dGh5KSB2YWx1ZSwgdGhlIGxleGVyIHdpbGwgcmV0dXJuXG4gKiAgICAgICAgICAgICAgICAgdGhlIG9yaWdpbmFsIGB0b2tlbmAuXG4gKiAgICAgICAgICAgICAgICAgYHRoaXNgIHJlZmVycyB0byB0aGUgTGV4ZXIgb2JqZWN0LlxuICpcbiAqIFdBUk5JTkc6IHRoZSBuZXh0IHNldCBvZiBvcHRpb25zIGFyZSBub3QgbWVhbnQgdG8gYmUgY2hhbmdlZC4gVGhleSBlY2hvIHRoZSBhYmlsaXRpZXMgb2ZcbiAqIHRoZSBsZXhlciBhcyBwZXIgd2hlbiBpdCB3YXMgY29tcGlsZWQhXG4gKlxuICogICAgICByYW5nZXM6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiB0b2tlbiBsb2NhdGlvbiBpbmZvIHdpbGwgaW5jbHVkZSBhIC5yYW5nZVtdIG1lbWJlci5cbiAqICAgICAgZmxleDogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IGZsZXgtbGlrZSBsZXhpbmcgYmVoYXZpb3VyIHdoZXJlIHRoZSBydWxlcyBhcmUgdGVzdGVkXG4gKiAgICAgICAgICAgICAgICAgZXhoYXVzdGl2ZWx5IHRvIGZpbmQgdGhlIGxvbmdlc3QgbWF0Y2guXG4gKiAgICAgIGJhY2t0cmFja19sZXhlcjogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGludm9rZWQ7XG4gKiAgICAgICAgICAgICAgICAgdGhlIGxleGVyIHRlcm1pbmF0ZXMgdGhlIHNjYW4gd2hlbiBhIHRva2VuIGlzIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24gY29kZS5cbiAqICAgICAgeHJlZ2V4cDogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IGxleGVyIHJ1bGUgcmVnZXhlcyBhcmUgXCJleHRlbmRlZCByZWdleCBmb3JtYXRcIiByZXF1aXJpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgYFhSZWdFeHBgIGxpYnJhcnkuIFdoZW4gdGhpcyAlb3B0aW9uIGhhcyBub3QgYmVlbiBzcGVjaWZpZWQgYXQgY29tcGlsZSB0aW1lLCBhbGwgbGV4ZXJcbiAqICAgICAgICAgICAgICAgICBydWxlIHJlZ2V4ZXMgaGF2ZSBiZWVuIHdyaXR0ZW4gYXMgc3RhbmRhcmQgSmF2YVNjcmlwdCBSZWdFeHAgZXhwcmVzc2lvbnMuXG4gKiAgfVxuICovXG5cblxudmFyIGxleGVyID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBTZWUgYWxzbzpcbiAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzgyMTA3L3doYXRzLWEtZ29vZC13YXktdG8tZXh0ZW5kLWVycm9yLWluLWphdmFzY3JpcHQvIzM1ODgxNTA4XG4gICAqIGJ1dCB3ZSBrZWVwIHRoZSBwcm90b3R5cGUuY29uc3RydWN0b3IgYW5kIHByb3RvdHlwZS5uYW1lIGFzc2lnbm1lbnQgbGluZXMgdG9vIGZvciBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggdXNlcmxhbmQgY29kZSB3aGljaCBtaWdodCBhY2Nlc3MgdGhlIGRlcml2ZWQgY2xhc3MgaW4gYSAnY2xhc3NpYycgd2F5LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbm9jb2xsYXBzZVxuICAgKi9cbiAgZnVuY3Rpb24gSmlzb25MZXhlckVycm9yKG1zZywgaGFzaCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6ICdKaXNvbkxleGVyRXJyb3InXG4gICAgfSk7XG5cbiAgICBpZiAobXNnID09IG51bGwpXG4gICAgICBtc2cgPSAnPz8/JztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbXNnXG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgIHZhciBzdGFja3RyYWNlO1xuXG4gICAgaWYgKGhhc2ggJiYgaGFzaC5leGNlcHRpb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdmFyIGV4MiA9IGhhc2guZXhjZXB0aW9uO1xuICAgICAgdGhpcy5tZXNzYWdlID0gZXgyLm1lc3NhZ2UgfHwgbXNnO1xuICAgICAgc3RhY2t0cmFjZSA9IGV4Mi5zdGFjaztcbiAgICB9XG5cbiAgICBpZiAoIXN0YWNrdHJhY2UpIHtcbiAgICAgIGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkge1xuICAgICAgICAvLyBWOFxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrdHJhY2UgPSBuZXcgRXJyb3IobXNnKS5zdGFjaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhY2t0cmFjZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHN0YWNrdHJhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEppc29uTGV4ZXJFcnJvci5wcm90b3R5cGUsIEVycm9yLnByb3RvdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgSmlzb25MZXhlckVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgfVxuXG4gIEppc29uTGV4ZXJFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKaXNvbkxleGVyRXJyb3I7XG4gIEppc29uTGV4ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdKaXNvbkxleGVyRXJyb3InO1xuXG4gIHZhciBsZXhlciA9IHtcbiAgICBcbi8vIENvZGUgR2VuZXJhdG9yIEluZm9ybWF0aW9uIFJlcG9ydFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vL1xuLy8gT3B0aW9uczpcbi8vXG4vLyAgIGJhY2t0cmFja2luZzogLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgbG9jYXRpb24ucmFuZ2VzOiAuLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICBsb2NhdGlvbiBsaW5lK2NvbHVtbiB0cmFja2luZzogLi4uIHRydWVcbi8vXG4vL1xuLy8gRm9yd2FyZGVkIFBhcnNlciBBbmFseXNpcyBmbGFnczpcbi8vXG4vLyAgIHVzZXMgeXlsZW5nOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgdXNlcyB5eWxpbmVubzogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICB1c2VzIHl5dGV4dDogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIHVzZXMgeXlsbG9jOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgdXNlcyBsZXhlciB2YWx1ZXM6IC4uLi4uLi4uLi4uLi4uLiB0cnVlIC8gdHJ1ZVxuLy8gICBsb2NhdGlvbiB0cmFja2luZzogLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIGxvY2F0aW9uIGFzc2lnbm1lbnQ6IC4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vXG4vL1xuLy8gTGV4ZXIgQW5hbHlzaXMgZmxhZ3M6XG4vL1xuLy8gICB1c2VzIHl5bGVuZzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHl5bGluZW5vOiAuLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHl5dGV4dDogLi4uLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHl5bGxvYzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIFBhcnNlRXJyb3IgQVBJOiAuLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHl5ZXJyb3I6IC4uLi4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIGxvY2F0aW9uIHRyYWNraW5nICYgZWRpdGluZzogID8/P1xuLy8gICB1c2VzIG1vcmUoKSBBUEk6IC4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHVucHV0KCkgQVBJOiAuLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIHJlamVjdCgpIEFQSTogLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIGxlc3MoKSBBUEk6IC4uLi4uLi4uLi4uLi4uLi4uID8/P1xuLy8gICB1c2VzIGRpc3BsYXkgQVBJcyBwYXN0SW5wdXQoKSwgdXBjb21pbmdJbnB1dCgpLCBzaG93UG9zaXRpb24oKTpcbi8vICAgICAgICAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyBkZXNjcmliZVlZTExPQygpIEFQSTogLi4uLi4uLiA/Pz9cbi8vXG4vLyAtLS0tLS0tLS0gRU5EIE9GIFJFUE9SVCAtLS0tLS0tLS0tLVxuXG5FT0Y6IDEsXG4gICAgRVJST1I6IDIsXG5cbiAgICAvLyBKaXNvbkxleGVyRXJyb3I6IEppc29uTGV4ZXJFcnJvciwgICAgICAgIC8vLyA8LS0gaW5qZWN0ZWQgYnkgdGhlIGNvZGUgZ2VuZXJhdG9yXG5cbiAgICAvLyBvcHRpb25zOiB7fSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyA8LS0gaW5qZWN0ZWQgYnkgdGhlIGNvZGUgZ2VuZXJhdG9yXG5cbiAgICAvLyB5eTogLi4uLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyA8LS0gaW5qZWN0ZWQgYnkgc2V0SW5wdXQoKVxuXG4gICAgX19jdXJyZW50UnVsZVNldF9fOiBudWxsLCAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFk6IGludGVybmFsIHJ1bGUgc2V0IGNhY2hlIGZvciB0aGUgY3VycmVudCBsZXhlciBzdGF0ZSAgXG5cbiAgICBfX2Vycm9yX2luZm9zOiBbXSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWTogdGhlIHNldCBvZiBsZXhFcnJvckluZm8gb2JqZWN0cyBjcmVhdGVkIHNpbmNlIHRoZSBsYXN0IGNsZWFudXAgIFxuICAgIF9fZGVjb21wcmVzc2VkOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZOiBtYXJrIHdoZXRoZXIgdGhlIGxleGVyIGluc3RhbmNlIGhhcyBiZWVuICd1bmZvbGRlZCcgY29tcGxldGVseSBhbmQgaXMgbm93IHJlYWR5IGZvciB1c2UgIFxuICAgIGRvbmU6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZICBcbiAgICBfYmFja3RyYWNrOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWSAgXG4gICAgX2lucHV0OiAnJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFkgIFxuICAgIF9tb3JlOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZICBcbiAgICBfc2lnbmFsZWRfZXJyb3JfdG9rZW46IGZhbHNlLCAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWSAgXG4gICAgY29uZGl0aW9uU3RhY2s6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFk7IG1hbmFnZWQgdmlhIGBwdXNoU3RhdGUoKWAsIGBwb3BTdGF0ZSgpYCwgYHRvcFN0YXRlKClgIGFuZCBgc3RhdGVTdGFja1NpemUoKWAgIFxuICAgIG1hdGNoOiAnJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIGlucHV0IHdoaWNoIGhhcyBiZWVuIG1hdGNoZWQgc28gZmFyIGZvciB0aGUgbGV4ZXIgdG9rZW4gdW5kZXIgY29uc3RydWN0aW9uLiBgbWF0Y2hgIGlzIGlkZW50aWNhbCB0byBgeXl0ZXh0YCBleGNlcHQgdGhhdCB0aGlzIG9uZSBzdGlsbCBjb250YWlucyB0aGUgbWF0Y2hlZCBpbnB1dCBzdHJpbmcgYWZ0ZXIgYGxleGVyLnBlcmZvcm1BY3Rpb24oKWAgaGFzIGJlZW4gaW52b2tlZCwgd2hlcmUgdXNlcmxhbmQgY29kZSBNQVkgaGF2ZSBjaGFuZ2VkL3JlcGxhY2VkIHRoZSBgeXl0ZXh0YCB2YWx1ZSBlbnRpcmVseSEgIFxuICAgIG1hdGNoZWQ6ICcnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIGVudGlyZSBpbnB1dCB3aGljaCBoYXMgYmVlbiBtYXRjaGVkIHNvIGZhciAgXG4gICAgbWF0Y2hlczogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgUkUgbWF0Y2ggcmVzdWx0IGZvciBsYXN0IChzdWNjZXNzZnVsKSBtYXRjaCBhdHRlbXB0ICBcbiAgICB5eXRleHQ6ICcnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIGlucHV0IHdoaWNoIGhhcyBiZWVuIG1hdGNoZWQgc28gZmFyIGZvciB0aGUgbGV4ZXIgdG9rZW4gdW5kZXIgY29uc3RydWN0aW9uOyB0aGlzIHZhbHVlIGlzIHRyYW5zZmVycmVkIHRvIHRoZSBwYXJzZXIgYXMgdGhlICd0b2tlbiB2YWx1ZScgd2hlbiB0aGUgcGFyc2VyIGNvbnN1bWVzIHRoZSBsZXhlciB0b2tlbiBwcm9kdWNlZCB0aHJvdWdoIGEgY2FsbCB0byB0aGUgYGxleCgpYCBBUEkuICBcbiAgICBvZmZzZXQ6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyB0aGUgJ2N1cnNvciBwb3NpdGlvbicgaW4gdGhlIGlucHV0IHN0cmluZywgaS5lLiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgbWF0Y2hlZCBzbyBmYXIgIFxuICAgIHl5bGVuZzogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogbGVuZ3RoIG9mIG1hdGNoZWQgaW5wdXQgZm9yIHRoZSB0b2tlbiB1bmRlciBjb25zdHJ1Y3Rpb24gKGB5eXRleHRgKSAgXG4gICAgeXlsaW5lbm86IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiAnbGluZSBudW1iZXInIGF0IHdoaWNoIHRoZSB0b2tlbiB1bmRlciBjb25zdHJ1Y3Rpb24gaXMgbG9jYXRlZCAgXG4gICAgeXlsbG9jOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgbG9jYXRpb24gaW5mbyAobGluZXMgKyBjb2x1bW5zKSBmb3IgdGhlIHRva2VuIHVuZGVyIGNvbnN0cnVjdGlvbiAgXG5cbiAgICAvKipcbiAgICAgKiBJTlRFUk5BTCBVU0U6IGNvbnN0cnVjdCBhIHN1aXRhYmxlIGVycm9yIGluZm8gaGFzaCBvYmplY3QgaW5zdGFuY2UgZm9yIGBwYXJzZUVycm9yYC5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdExleEVycm9ySW5mbzogZnVuY3Rpb24gbGV4ZXJfY29uc3RydWN0TGV4RXJyb3JJbmZvKG1zZywgcmVjb3ZlcmFibGUsIHNob3dfaW5wdXRfcG9zaXRpb24pIHtcbiAgICAgIG1zZyA9ICcnICsgbXNnO1xuXG4gICAgICAvLyBoZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlcnJvciBtZXNzYWdlIGFscmVhZHkgY29udGFpbnMgYSAocGFydGlhbCkgc291cmNlIGNvZGUgZHVtcFxuICAgICAgLy8gYXMgcHJvZHVjZWQgYnkgZWl0aGVyIGBzaG93UG9zaXRpb24oKWAgb3IgYHByZXR0eVByaW50UmFuZ2UoKWA6XG4gICAgICBpZiAoc2hvd19pbnB1dF9wb3NpdGlvbiA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2hvd19pbnB1dF9wb3NpdGlvbiA9ICEobXNnLmluZGV4T2YoJ1xcbicpID4gMCAmJiBtc2cuaW5kZXhPZignXicpID4gMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnl5bGxvYyAmJiBzaG93X2lucHV0X3Bvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmV0dHlQcmludFJhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHByZXR0eV9zcmMgPSB0aGlzLnByZXR0eVByaW50UmFuZ2UodGhpcy55eWxsb2MpO1xuXG4gICAgICAgICAgaWYgKCEvXFxuXFxzKiQvLnRlc3QobXNnKSkge1xuICAgICAgICAgICAgbXNnICs9ICdcXG4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1zZyArPSAnXFxuICBFcnJvbmVvdXMgYXJlYTpcXG4nICsgdGhpcy5wcmV0dHlQcmludFJhbmdlKHRoaXMueXlsbG9jKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zaG93UG9zaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgcG9zX3N0ciA9IHRoaXMuc2hvd1Bvc2l0aW9uKCk7XG5cbiAgICAgICAgICBpZiAocG9zX3N0cikge1xuICAgICAgICAgICAgaWYgKG1zZy5sZW5ndGggJiYgbXNnW21zZy5sZW5ndGggLSAxXSAhPT0gJ1xcbicgJiYgcG9zX3N0clswXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgbXNnICs9ICdcXG4nICsgcG9zX3N0cjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1zZyArPSBwb3Nfc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQGNvbnN0cnVjdG9yICovXG4gICAgICB2YXIgcGVpID0ge1xuICAgICAgICBlcnJTdHI6IG1zZyxcbiAgICAgICAgcmVjb3ZlcmFibGU6ICEhcmVjb3ZlcmFibGUsXG4gICAgICAgIHRleHQ6IHRoaXMubWF0Y2gsICAgICAgICAgICAvLyBUaGlzIG9uZSBNQVkgYmUgZW1wdHk7IHVzZXJsYW5kIGNvZGUgc2hvdWxkIHVzZSB0aGUgYHVwY29taW5nSW5wdXRgIEFQSSB0byBvYnRhaW4gbW9yZSB0ZXh0IHdoaWNoIGZvbGxvd3MgdGhlICdsZXhlciBjdXJzb3IgcG9zaXRpb24nLi4uICBcbiAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm8sXG4gICAgICAgIGxvYzogdGhpcy55eWxsb2MsXG4gICAgICAgIHl5OiB0aGlzLnl5LFxuICAgICAgICBsZXhlcjogdGhpcyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYW5kIG1ha2Ugc3VyZSB0aGUgZXJyb3IgaW5mbyBkb2Vzbid0IHN0YXkgZHVlIHRvIHBvdGVudGlhbFxuICAgICAgICAgKiByZWYgY3ljbGUgdmlhIHVzZXJsYW5kIGNvZGUgbWFuaXB1bGF0aW9ucy5cbiAgICAgICAgICogVGhlc2Ugd291bGQgb3RoZXJ3aXNlIGFsbCBiZSBtZW1vcnkgbGVhayBvcHBvcnR1bml0aWVzIVxuICAgICAgICAgKiBcbiAgICAgICAgICogTm90ZSB0aGF0IG9ubHkgYXJyYXkgYW5kIG9iamVjdCByZWZlcmVuY2VzIGFyZSBudWtlZCBhcyB0aG9zZVxuICAgICAgICAgKiBjb25zdGl0dXRlIHRoZSBzZXQgb2YgZWxlbWVudHMgd2hpY2ggY2FuIHByb2R1Y2UgYSBjeWNsaWMgcmVmLlxuICAgICAgICAgKiBUaGUgcmVzdCBvZiB0aGUgbWVtYmVycyBpcyBrZXB0IGludGFjdCBhcyB0aGV5IGFyZSBoYXJtbGVzcy5cbiAgICAgICAgICogXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHRoaXMge0xleEVycm9ySW5mb31cbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3RydWN0TGV4RXJyb3JJbmZvKCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBjeWNsaWMgcmVmZXJlbmNlcyBhZGRlZCB0byBlcnJvciBpbmZvOlxuICAgICAgICAgIC8vIGluZm8ueXkgPSBudWxsO1xuICAgICAgICAgIC8vIGluZm8ubGV4ZXIgPSBudWxsO1xuICAgICAgICAgIC8vIC4uLlxuICAgICAgICAgIHZhciByZWMgPSAhIXRoaXMucmVjb3ZlcmFibGU7XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICB0aGlzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZWNvdmVyYWJsZSA9IHJlYztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gdHJhY2sgdGhpcyBpbnN0YW5jZSBzbyB3ZSBjYW4gYGRlc3Ryb3koKWAgaXQgb25jZSB3ZSBkZWVtIGl0IHN1cGVyZmx1b3VzIGFuZCByZWFkeSBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uIVxuICAgICAgdGhpcy5fX2Vycm9yX2luZm9zLnB1c2gocGVpKTtcblxuICAgICAgcmV0dXJuIHBlaTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlciB3aGljaCBpcyBpbnZva2VkIHdoZW4gYSBsZXhlciBlcnJvciBvY2N1cnMuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbiBsZXhlcl9wYXJzZUVycm9yKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICAgIGlmICghRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICAgICAgRXhjZXB0aW9uQ2xhc3MgPSB0aGlzLkppc29uTGV4ZXJFcnJvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMueXkpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyICYmIHR5cGVvZiB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3IuY2FsbCh0aGlzLCBzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB8fCB0aGlzLkVSUk9SO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy55eS5wYXJzZUVycm9yLmNhbGwodGhpcywgc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcykgfHwgdGhpcy5FUlJPUjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uQ2xhc3Moc3RyLCBoYXNoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWV0aG9kIHdoaWNoIGltcGxlbWVudHMgYHl5ZXJyb3Ioc3RyLCAuLi5hcmdzKWAgZnVuY3Rpb25hbGl0eSBmb3IgdXNlIGluc2lkZSBsZXhlciBhY3Rpb25zLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgeXllcnJvcjogZnVuY3Rpb24geXlFcnJvcihzdHIgLyosIC4uLmFyZ3MgKi8pIHtcbiAgICAgIHZhciBsaW5lbm9fbXNnID0gJyc7XG5cbiAgICAgIGlmICh0aGlzLnl5bGxvYykge1xuICAgICAgICBsaW5lbm9fbXNnID0gJyBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcCA9IHRoaXMuY29uc3RydWN0TGV4RXJyb3JJbmZvKFxuICAgICAgICAnTGV4aWNhbCBlcnJvcicgKyBsaW5lbm9fbXNnICsgJzogJyArIHN0cixcbiAgICAgICAgdGhpcy5vcHRpb25zLmxleGVyRXJyb3JzQXJlUmVjb3ZlcmFibGVcbiAgICAgICk7XG5cbiAgICAgIC8vIEFkZCBhbnkgZXh0cmEgYXJncyB0byB0aGUgaGFzaCB1bmRlciB0aGUgbmFtZSBgZXh0cmFfZXJyb3JfYXR0cmlidXRlc2A6XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBwLmV4dHJhX2Vycm9yX2F0dHJpYnV0ZXMgPSBhcmdzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uTGV4ZXJFcnJvcikgfHwgdGhpcy5FUlJPUjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZmluYWwgY2xlYW51cCBmdW5jdGlvbiBmb3Igd2hlbiB3ZSBoYXZlIGNvbXBsZXRlZCBsZXhpbmcgdGhlIGlucHV0O1xuICAgICAqIG1ha2UgaXQgYW4gQVBJIHNvIHRoYXQgZXh0ZXJuYWwgY29kZSBjYW4gdXNlIHRoaXMgb25lIG9uY2UgdXNlcmxhbmRcbiAgICAgKiBjb2RlIGhhcyBkZWNpZGVkIGl0J3MgdGltZSB0byBkZXN0cm95IGFueSBsaW5nZXJpbmcgbGV4ZXIgZXJyb3JcbiAgICAgKiBoYXNoIG9iamVjdCBpbnN0YW5jZXMgYW5kIHRoZSBsaWtlOiB0aGlzIGZ1bmN0aW9uIGhlbHBzIHRvIGNsZWFuXG4gICAgICogdXAgdGhlc2UgY29uc3RydWN0cywgd2hpY2ggKm1heSogY2FycnkgY3ljbGljIHJlZmVyZW5jZXMgd2hpY2ggd291bGRcbiAgICAgKiBvdGhlcndpc2UgcHJldmVudCB0aGUgaW5zdGFuY2VzIGZyb20gYmVpbmcgcHJvcGVybHkgYW5kIHRpbWVseVxuICAgICAqIGdhcmJhZ2UtY29sbGVjdGVkLCBpLmUuIHRoaXMgZnVuY3Rpb24gaGVscHMgcHJldmVudCBtZW1vcnkgbGVha3MhXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBjbGVhbnVwQWZ0ZXJMZXg6IGZ1bmN0aW9uIGxleGVyX2NsZWFudXBBZnRlckxleChkb19ub3RfbnVrZV9lcnJvcmluZm9zKSB7XG4gICAgICAvLyBwcmV2ZW50IGxpbmdlcmluZyBjaXJjdWxhciByZWZlcmVuY2VzIGZyb20gY2F1c2luZyBtZW1vcnkgbGVha3M6XG4gICAgICB0aGlzLnNldElucHV0KCcnLCB7fSk7XG5cbiAgICAgIC8vIG51a2UgdGhlIGVycm9yIGhhc2ggaW5mbyBpbnN0YW5jZXMgY3JlYXRlZCBkdXJpbmcgdGhpcyBydW4uXG4gICAgICAvLyBVc2VybGFuZCBjb2RlIG11c3QgQ09QWSBhbnkgZGF0YS9yZWZlcmVuY2VzXG4gICAgICAvLyBpbiB0aGUgZXJyb3IgaGFzaCBpbnN0YW5jZShzKSBpdCBpcyBtb3JlIHBlcm1hbmVudGx5IGludGVyZXN0ZWQgaW4uXG4gICAgICBpZiAoIWRvX25vdF9udWtlX2Vycm9yaW5mb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX19lcnJvcl9pbmZvcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBlbCA9IHRoaXMuX19lcnJvcl9pbmZvc1tpXTtcblxuICAgICAgICAgIGlmIChlbCAmJiB0eXBlb2YgZWwuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZWwuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19lcnJvcl9pbmZvcy5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2xlYXIgdGhlIGxleGVyIHRva2VuIGNvbnRleHQ7IGludGVuZGVkIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGxleGVyX2NsZWFyKCkge1xuICAgICAgdGhpcy55eXRleHQgPSAnJztcbiAgICAgIHRoaXMueXlsZW5nID0gMDtcbiAgICAgIHRoaXMubWF0Y2ggPSAnJztcblxuICAgICAgLy8gLSBETyBOT1QgcmVzZXQgYHRoaXMubWF0Y2hlZGBcbiAgICAgIHRoaXMubWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciBjb2wgPSAodGhpcy55eWxsb2MgPyB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiA6IDApO1xuXG4gICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgIGZpcnN0X2NvbHVtbjogY29sLFxuICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICBsYXN0X2NvbHVtbjogY29sLFxuICAgICAgICByYW5nZTogW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldF1cbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlc2V0cyB0aGUgbGV4ZXIsIHNldHMgbmV3IGlucHV0XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBzZXRJbnB1dDogZnVuY3Rpb24gbGV4ZXJfc2V0SW5wdXQoaW5wdXQsIHl5KSB7XG4gICAgICB0aGlzLnl5ID0geXkgfHwgdGhpcy55eSB8fCB7fTtcblxuICAgICAgLy8gYWxzbyBjaGVjayBpZiB3ZSd2ZSBmdWxseSBpbml0aWFsaXplZCB0aGUgbGV4ZXIgaW5zdGFuY2UsXG4gICAgICAvLyBpbmNsdWRpbmcgZXhwYW5zaW9uIHdvcmsgdG8gYmUgZG9uZSB0byBnbyBmcm9tIGEgbG9hZGVkXG4gICAgICAvLyBsZXhlciB0byBhIHVzYWJsZSBsZXhlcjpcbiAgICAgIGlmICghdGhpcy5fX2RlY29tcHJlc3NlZCkge1xuICAgICAgICAvLyBzdGVwIDE6IGRlY29tcHJlc3MgdGhlIHJlZ2V4IGxpc3Q6XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJ1bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJ1bGVfcmUgPSBydWxlc1tpXTtcblxuICAgICAgICAgIC8vIGNvbXByZXNzaW9uOiBpcyB0aGUgUkUgYW4geHJlZiB0byBhbm90aGVyIFJFIHNsb3QgaW4gdGhlIHJ1bGVzW10gdGFibGU/XG4gICAgICAgICAgaWYgKHR5cGVvZiBydWxlX3JlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcnVsZXNbaV0gPSBydWxlc1tydWxlX3JlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdGVwIDI6IHVuZm9sZCB0aGUgY29uZGl0aW9uc1tdIHNldCB0byBtYWtlIHRoZXNlIHJlYWR5IGZvciB1c2U6XG4gICAgICAgIHZhciBjb25kaXRpb25zID0gdGhpcy5jb25kaXRpb25zO1xuXG4gICAgICAgIGZvciAodmFyIGsgaW4gY29uZGl0aW9ucykge1xuICAgICAgICAgIHZhciBzcGVjID0gY29uZGl0aW9uc1trXTtcbiAgICAgICAgICB2YXIgcnVsZV9pZHMgPSBzcGVjLnJ1bGVzO1xuICAgICAgICAgIHZhciBsZW4gPSBydWxlX2lkcy5sZW5ndGg7XG4gICAgICAgICAgdmFyIHJ1bGVfcmVnZXhlcyA9IG5ldyBBcnJheShsZW4gKyAxKTsgICAgICAgICAgICAgLy8gc2xvdCAwIGlzIHVudXNlZDsgd2UgdXNlIGEgMS1iYXNlZCBpbmRleCBhcHByb2FjaCBoZXJlIHRvIGtlZXAgdGhlIGhvdHRlc3QgY29kZSBpbiBgbGV4ZXJfbmV4dCgpYCBmYXN0IGFuZCBzaW1wbGUhIFxuICAgICAgICAgIHZhciBydWxlX25ld19pZHMgPSBuZXcgQXJyYXkobGVuICsgMSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gcnVsZV9pZHNbaV07XG4gICAgICAgICAgICB2YXIgcnVsZV9yZSA9IHJ1bGVzW2lkeF07XG4gICAgICAgICAgICBydWxlX3JlZ2V4ZXNbaSArIDFdID0gcnVsZV9yZTtcbiAgICAgICAgICAgIHJ1bGVfbmV3X2lkc1tpICsgMV0gPSBpZHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3BlYy5ydWxlcyA9IHJ1bGVfbmV3X2lkcztcbiAgICAgICAgICBzcGVjLl9fcnVsZV9yZWdleGVzID0gcnVsZV9yZWdleGVzO1xuICAgICAgICAgIHNwZWMuX19ydWxlX2NvdW50ID0gbGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2RlY29tcHJlc3NlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQgfHwgJyc7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLnl5bGluZW5vID0gMDtcbiAgICAgIHRoaXMubWF0Y2hlZCA9ICcnO1xuICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgdGhpcy5fX2N1cnJlbnRSdWxlU2V0X18gPSBudWxsO1xuXG4gICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgZmlyc3RfbGluZTogMSxcbiAgICAgICAgZmlyc3RfY29sdW1uOiAwLFxuICAgICAgICBsYXN0X2xpbmU6IDEsXG4gICAgICAgIGxhc3RfY29sdW1uOiAwLFxuICAgICAgICByYW5nZTogWzAsIDBdXG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZWRpdCB0aGUgcmVtYWluaW5nIGlucHV0IHZpYSB1c2VyLXNwZWNpZmllZCBjYWxsYmFjay5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGZvcndhcmQtYWRqdXN0IHRoZSBpbnB1dC10by1wYXJzZSwgXG4gICAgICogZS5nLiBpbnNlcnRpbmcgbWFjcm8gZXhwYW5zaW9ucyBhbmQgYWxpa2UgaW4gdGhlXG4gICAgICogaW5wdXQgd2hpY2ggaGFzIHlldCB0byBiZSBsZXhlZC5cbiAgICAgKiBUaGUgYmVoYXZpb3VyIG9mIHRoaXMgQVBJIGNvbnRyYXN0cyB0aGUgYHVucHV0KClgIGV0IGFsXG4gICAgICogQVBJcyBhcyB0aG9zZSBhY3Qgb24gdGhlICpjb25zdW1lZCogaW5wdXQsIHdoaWxlIHRoaXNcbiAgICAgKiBvbmUgYWxsb3dzIG9uZSB0byBtYW5pcHVsYXRlIHRoZSBmdXR1cmUsIHdpdGhvdXQgaW1wYWN0aW5nXG4gICAgICogdGhlIGN1cnJlbnQgYHl5bG9jYCBjdXJzb3IgbG9jYXRpb24gb3IgYW55IGhpc3RvcnkuIFxuICAgICAqIFxuICAgICAqIFVzZSB0aGlzIEFQSSB0byBoZWxwIGltcGxlbWVudCBDLXByZXByb2Nlc3Nvci1saWtlXG4gICAgICogYCNpbmNsdWRlYCBzdGF0ZW1lbnRzLCBldGMuXG4gICAgICogXG4gICAgICogVGhlIHByb3ZpZGVkIGNhbGxiYWNrIG11c3QgYmUgc3luY2hyb25vdXMgYW5kIGlzXG4gICAgICogZXhwZWN0ZWQgdG8gcmV0dXJuIHRoZSBlZGl0ZWQgaW5wdXQgKHN0cmluZykuXG4gICAgICpcbiAgICAgKiBUaGUgYGNwc0FyZ2AgYXJndW1lbnQgdmFsdWUgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFja1xuICAgICAqIGFzLWlzLlxuICAgICAqXG4gICAgICogYGNhbGxiYWNrYCBpbnRlcmZhY2U6IFxuICAgICAqIGBmdW5jdGlvbiBjYWxsYmFjayhpbnB1dCwgY3BzQXJnKWBcbiAgICAgKiBcbiAgICAgKiAtIGBpbnB1dGAgd2lsbCBjYXJyeSB0aGUgcmVtYWluaW5nLWlucHV0LXRvLWxleCBzdHJpbmdcbiAgICAgKiAgIGZyb20gdGhlIGxleGVyLlxuICAgICAqIC0gYGNwc0FyZ2AgaXMgYGNwc0FyZ2AgcGFzc2VkIGludG8gdGhpcyBBUEkuXG4gICAgICogXG4gICAgICogVGhlIGB0aGlzYCByZWZlcmVuY2UgZm9yIHRoZSBjYWxsYmFjayB3aWxsIGJlIHNldCB0b1xuICAgICAqIHJlZmVyZW5jZSB0aGlzIGxleGVyIGluc3RhbmNlIHNvIHRoYXQgdXNlcmxhbmQgY29kZVxuICAgICAqIGluIHRoZSBjYWxsYmFjayBjYW4gZWFzaWx5IGFuZCBxdWlja2x5IGFjY2VzcyBhbnkgbGV4ZXJcbiAgICAgKiBBUEkuIFxuICAgICAqXG4gICAgICogV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIG5vbi1zdHJpbmctdHlwZSBmYWxzZXkgdmFsdWUsXG4gICAgICogd2UgYXNzdW1lIHRoZSBjYWxsYmFjayBkaWQgbm90IGVkaXQgdGhlIGlucHV0IGFuZCB3ZVxuICAgICAqIHdpbGwgdXNpbmcgdGhlIGlucHV0IGFzLWlzLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIG5vbi1zdHJpbmctdHlwZSB2YWx1ZSwgaXRcbiAgICAgKiBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgZm9yIGxleGluZyB2aWEgdGhlIGBcIlwiICsgcmV0dmFsYFxuICAgICAqIG9wZXJhdGlvbi4gKFNlZSBhbHNvIHdoeTogaHR0cDovLzJhbGl0eS5jb20vMjAxMi8wMy9jb252ZXJ0aW5nLXRvLXN0cmluZy5odG1sIFxuICAgICAqIC0tIHRoYXQgd2F5IGFueSByZXR1cm5lZCBvYmplY3QncyBgdG9WYWx1ZSgpYCBhbmQgYHRvU3RyaW5nKClgXG4gICAgICogbWV0aG9kcyB3aWxsIGJlIGludm9rZWQgaW4gYSBwcm9wZXIvZGVzaXJhYmxlIG9yZGVyLilcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGVkaXRSZW1haW5pbmdJbnB1dDogZnVuY3Rpb24gbGV4ZXJfZWRpdFJlbWFpbmluZ0lucHV0KGNhbGxiYWNrLCBjcHNBcmcpIHtcbiAgICAgIHZhciBydiA9IGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5faW5wdXQsIGNwc0FyZyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcnYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChydikge1xuICAgICAgICAgIHRoaXMuX2lucHV0ID0gJycgKyBydjtcbiAgICAgICAgfSBcbiAgICAgICAgLy8gZWxzZToga2VlcCBgdGhpcy5faW5wdXRgIGFzIGlzLiAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dCA9IHJ2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29uc3VtZXMgYW5kIHJldHVybnMgb25lIGNoYXIgZnJvbSB0aGUgaW5wdXRcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGlucHV0OiBmdW5jdGlvbiBsZXhlcl9pbnB1dCgpIHtcbiAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgLy90aGlzLmRvbmUgPSB0cnVlOyAgICAtLSBkb24ndCBzZXQgYGRvbmVgIGFzIHdlIHdhbnQgdGhlIGxleCgpL25leHQoKSBBUEkgdG8gYmUgYWJsZSB0byBwcm9kdWNlIG9uZSBjdXN0b20gRU9GIHRva2VuIG1hdGNoIGFmdGVyIHRoaXMgYW55aG93LiAobGV4ZXIgY2FuIG1hdGNoIHNwZWNpYWwgPDxFT0Y+PiB0b2tlbnMgYW5kIHBlcmZvcm0gdXNlciBhY3Rpb24gY29kZSBmb3IgYSA8PEVPRj4+IG1hdGNoLCBidXQgb25seSBkb2VzIHNvICpvbmNlKilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7XG5cbiAgICAgIC8vIENvdW50IHRoZSBsaW5lbnVtYmVyIHVwIHdoZW4gd2UgaGl0IHRoZSBMRiAob3IgYSBzdGFuZC1hbG9uZSBDUikuXG4gICAgICAvLyBPbiBDUkxGLCB0aGUgbGluZW51bWJlciBpcyBpbmNyZW1lbnRlZCB3aGVuIHlvdSBmZXRjaCB0aGUgQ1Igb3IgdGhlIENSTEYgY29tYm9cbiAgICAgIC8vIGFuZCB3ZSBhZHZhbmNlIGltbWVkaWF0ZWx5IHBhc3QgdGhlIExGIGFzIHdlbGwsIHJldHVybmluZyBib3RoIHRvZ2V0aGVyIGFzIGlmXG4gICAgICAvLyBpdCB3YXMgYWxsIGEgc2luZ2xlICdjaGFyYWN0ZXInIG9ubHkuXG4gICAgICB2YXIgc2xpY2VfbGVuID0gMTtcblxuICAgICAgdmFyIGxpbmVzID0gZmFsc2U7XG5cbiAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgbGluZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgbGluZXMgPSB0cnVlO1xuICAgICAgICB2YXIgY2gyID0gdGhpcy5faW5wdXRbMV07XG5cbiAgICAgICAgaWYgKGNoMiA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBzbGljZV9sZW4rKztcbiAgICAgICAgICBjaCArPSBjaDI7XG4gICAgICAgICAgdGhpcy55eXRleHQgKz0gY2gyO1xuICAgICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICB0aGlzLm1hdGNoICs9IGNoMjtcbiAgICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2gyO1xuICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKHNsaWNlX2xlbik7XG4gICAgICByZXR1cm4gY2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhbiBlbnRpcmUgc3RyaW5nKSBpbnRvIHRoZSBpbnB1dFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgdW5wdXQ6IGZ1bmN0aW9uIGxleGVyX3VucHV0KGNoKSB7XG4gICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbik7XG4gICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aCAtIGxlbik7XG4gICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSBsZW4pO1xuXG4gICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSA9IHRoaXMueXlsaW5lbm8gKyAxO1xuXG4gICAgICAgIC8vIEdldCBsYXN0IGVudGlyZWx5IG1hdGNoZWQgbGluZSBpbnRvIHRoZSBgcHJlX2xpbmVzW11gIGFycmF5J3NcbiAgICAgICAgLy8gbGFzdCBpbmRleCBzbG90OyB3ZSBkb24ndCBtaW5kIHdoZW4gb3RoZXIgcHJldmlvdXNseSBcbiAgICAgICAgLy8gbWF0Y2hlZCBsaW5lcyBlbmQgdXAgaW4gdGhlIGFycmF5IHRvby4gXG4gICAgICAgIHZhciBwcmUgPSB0aGlzLm1hdGNoO1xuXG4gICAgICAgIHZhciBwcmVfbGluZXMgPSBwcmUuc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcblxuICAgICAgICBpZiAocHJlX2xpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHByZSA9IHRoaXMubWF0Y2hlZDtcbiAgICAgICAgICBwcmVfbGluZXMgPSBwcmUuc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gcHJlX2xpbmVzW3ByZV9saW5lcy5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiAtPSBsZW47XG4gICAgICB9XG5cbiAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdID0gdGhpcy55eWxsb2MucmFuZ2VbMF0gKyB0aGlzLnl5bGVuZztcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhY2hlIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kIGl0IG9uIG5leHQgYWN0aW9uXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBtb3JlOiBmdW5jdGlvbiBsZXhlcl9tb3JlKCkge1xuICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2lnbmFsIHRoZSBsZXhlciB0aGF0IHRoaXMgcnVsZSBmYWlscyB0byBtYXRjaCB0aGUgaW5wdXQsIHNvIHRoZVxuICAgICAqIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHJlamVjdDogZnVuY3Rpb24gbGV4ZXJfcmVqZWN0KCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdoZW4gdGhlIGBwYXJzZUVycm9yKClgIGNhbGwgcmV0dXJucywgd2UgTVVTVCBlbnN1cmUgdGhhdCB0aGUgZXJyb3IgaXMgcmVnaXN0ZXJlZC5cbiAgICAgICAgLy8gV2UgYWNjb21wbGlzaCB0aGlzIGJ5IHNpZ25hbGluZyBhbiAnZXJyb3InIHRva2VuIHRvIGJlIHByb2R1Y2VkIGZvciB0aGUgY3VycmVudFxuICAgICAgICAvLyBgLmxleCgpYCBydW4uXG4gICAgICAgIHZhciBsaW5lbm9fbXNnID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMueXlsbG9jKSB7XG4gICAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwID0gdGhpcy5jb25zdHJ1Y3RMZXhFcnJvckluZm8oXG4gICAgICAgICAgJ0xleGljYWwgZXJyb3InICsgbGluZW5vX21zZyArICc6IFlvdSBjYW4gb25seSBpbnZva2UgcmVqZWN0KCkgaW4gdGhlIGxleGVyIHdoZW4gdGhlIGxleGVyIGlzIG9mIHRoZSBiYWNrdHJhY2tpbmcgcGVyc3Vhc2lvbiAob3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIgPSB0cnVlKS4nLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4gPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25MZXhlckVycm9yKSB8fCB0aGlzLkVSUk9SO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGxlc3M6IGZ1bmN0aW9uIGxleGVyX2xlc3Mobikge1xuICAgICAgcmV0dXJuIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiAocGFydCBvZiB0aGUpIGFscmVhZHkgbWF0Y2hlZCBpbnB1dCwgaS5lLiBmb3IgZXJyb3JcbiAgICAgKiBtZXNzYWdlcy5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIGxlbmd0aCB0byBgbWF4U2l6ZWAgKGRlZmF1bHQ6IDIwKS5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIHRvIHRoZSBgbWF4TGluZXNgIG51bWJlciBvZiBsaW5lcyBvZlxuICAgICAqIGlucHV0IChkZWZhdWx0OiAxKS5cbiAgICAgKiBcbiAgICAgKiBOZWdhdGl2ZSBsaW1pdCB2YWx1ZXMgZXF1YWwgKnVubGltaXRlZCouXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uIGxleGVyX3Bhc3RJbnB1dChtYXhTaXplLCBtYXhMaW5lcykge1xuICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyaW5nKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG5cbiAgICAgIGlmIChtYXhTaXplIDwgMClcbiAgICAgICAgbWF4U2l6ZSA9IHBhc3QubGVuZ3RoO1xuICAgICAgZWxzZSBpZiAoIW1heFNpemUpXG4gICAgICAgIG1heFNpemUgPSAyMDtcblxuICAgICAgaWYgKG1heExpbmVzIDwgMClcbiAgICAgICAgbWF4TGluZXMgPSBwYXN0Lmxlbmd0aDsgICAgICAgICAgLy8gY2FuJ3QgZXZlciBoYXZlIG1vcmUgaW5wdXQgbGluZXMgdGhhbiB0aGlzISBcbiAgICAgIGVsc2UgaWYgKCFtYXhMaW5lcylcbiAgICAgICAgbWF4TGluZXMgPSAxO1xuXG4gICAgICAvLyBgc3Vic3RyYCBhbnRpY2lwYXRpb246IHRyZWF0IFxcclxcbiBhcyBhIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIHRha2UgYSBsaXR0bGVcbiAgICAgIC8vIG1vcmUgdGhhbiBuZWNlc3Nhcnkgc28gdGhhdCB3ZSBjYW4gc3RpbGwgcHJvcGVybHkgY2hlY2sgYWdhaW5zdCBtYXhTaXplXG4gICAgICAvLyBhZnRlciB3ZSd2ZSB0cmFuc2Zvcm1lZCBhbmQgbGltaXRlZCB0aGUgbmV3TGluZXMgaW4gaGVyZTpcbiAgICAgIHBhc3QgPSBwYXN0LnN1YnN0cigtbWF4U2l6ZSAqIDIgLSAyKTtcblxuICAgICAgLy8gbm93IHRoYXQgd2UgaGF2ZSBhIHNpZ25pZmljYW50bHkgcmVkdWNlZCBzdHJpbmcgdG8gcHJvY2VzcywgdHJhbnNmb3JtIHRoZSBuZXdsaW5lc1xuICAgICAgLy8gYW5kIGNob3AgdGhlbSwgdGhlbiBsaW1pdCB0aGVtOlxuICAgICAgdmFyIGEgPSBwYXN0LnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgYSA9IGEuc2xpY2UoLW1heExpbmVzKTtcbiAgICAgIHBhc3QgPSBhLmpvaW4oJ1xcbicpO1xuXG4gICAgICAvLyBXaGVuLCBhZnRlciBsaW1pdGluZyB0byBtYXhMaW5lcywgd2Ugc3RpbGwgaGF2ZSB0b28gbXVjaCB0byByZXR1cm4sXG4gICAgICAvLyBkbyBhZGQgYW4gZWxsaXBzaXMgcHJlZml4Li4uXG4gICAgICBpZiAocGFzdC5sZW5ndGggPiBtYXhTaXplKSB7XG4gICAgICAgIHBhc3QgPSAnLi4uJyArIHBhc3Quc3Vic3RyKC1tYXhTaXplKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiAocGFydCBvZiB0aGUpIHVwY29taW5nIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIGxlbmd0aCB0byBgbWF4U2l6ZWAgKGRlZmF1bHQ6IDIwKS5cbiAgICAgKiBcbiAgICAgKiBMaW1pdCB0aGUgcmV0dXJuZWQgc3RyaW5nIHRvIHRoZSBgbWF4TGluZXNgIG51bWJlciBvZiBsaW5lcyBvZiBpbnB1dCAoZGVmYXVsdDogMSkuXG4gICAgICogXG4gICAgICogTmVnYXRpdmUgbGltaXQgdmFsdWVzIGVxdWFsICp1bmxpbWl0ZWQqLlxuICAgICAqXG4gICAgICogPiAjIyMgTk9URSAjIyNcbiAgICAgKiA+XG4gICAgICogPiAqXCJ1cGNvbWluZyBpbnB1dFwiKiBpcyBkZWZpbmVkIGFzIHRoZSB3aG9sZSBvZiB0aGUgYm90aFxuICAgICAqID4gdGhlICpjdXJyZW50bHkgbGV4ZWQqIGlucHV0LCB0b2dldGhlciB3aXRoIGFueSByZW1haW5pbmcgaW5wdXRcbiAgICAgKiA+IGZvbGxvd2luZyB0aGF0LiAqXCJjdXJyZW50bHkgbGV4ZWRcIiogaW5wdXQgaXMgdGhlIGlucHV0IFxuICAgICAqID4gYWxyZWFkeSByZWNvZ25pemVkIGJ5IHRoZSBsZXhlciBidXQgbm90IHlldCByZXR1cm5lZCB3aXRoXG4gICAgICogPiB0aGUgbGV4ZXIgdG9rZW4uIFRoaXMgaGFwcGVucyB3aGVuIHlvdSBhcmUgaW52b2tpbmcgdGhpcyBBUElcbiAgICAgKiA+IGZyb20gaW5zaWRlIGFueSBsZXhlciBydWxlIGFjdGlvbiBjb2RlIGJsb2NrLiBcbiAgICAgKiA+XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbiBsZXhlcl91cGNvbWluZ0lucHV0KG1heFNpemUsIG1heExpbmVzKSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XG5cbiAgICAgIGlmIChtYXhTaXplIDwgMClcbiAgICAgICAgbWF4U2l6ZSA9IG5leHQubGVuZ3RoICsgdGhpcy5faW5wdXQubGVuZ3RoO1xuICAgICAgZWxzZSBpZiAoIW1heFNpemUpXG4gICAgICAgIG1heFNpemUgPSAyMDtcblxuICAgICAgaWYgKG1heExpbmVzIDwgMClcbiAgICAgICAgbWF4TGluZXMgPSBtYXhTaXplOyAgICAgICAgICAvLyBjYW4ndCBldmVyIGhhdmUgbW9yZSBpbnB1dCBsaW5lcyB0aGFuIHRoaXMhIFxuICAgICAgZWxzZSBpZiAoIW1heExpbmVzKVxuICAgICAgICBtYXhMaW5lcyA9IDE7XG5cbiAgICAgIC8vIGBzdWJzdHJpbmdgIGFudGljaXBhdGlvbjogdHJlYXQgXFxyXFxuIGFzIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgdGFrZSBhIGxpdHRsZVxuICAgICAgLy8gbW9yZSB0aGFuIG5lY2Vzc2FyeSBzbyB0aGF0IHdlIGNhbiBzdGlsbCBwcm9wZXJseSBjaGVjayBhZ2FpbnN0IG1heFNpemVcbiAgICAgIC8vIGFmdGVyIHdlJ3ZlIHRyYW5zZm9ybWVkIGFuZCBsaW1pdGVkIHRoZSBuZXdMaW5lcyBpbiBoZXJlOlxuICAgICAgaWYgKG5leHQubGVuZ3RoIDwgbWF4U2l6ZSAqIDIgKyAyKSB7XG4gICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKDAsIG1heFNpemUgKiAyICsgMik7ICAgLy8gc3Vic3RyaW5nIGlzIGZhc3RlciBvbiBDaHJvbWUvVjggXG4gICAgICB9XG5cbiAgICAgIC8vIG5vdyB0aGF0IHdlIGhhdmUgYSBzaWduaWZpY2FudGx5IHJlZHVjZWQgc3RyaW5nIHRvIHByb2Nlc3MsIHRyYW5zZm9ybSB0aGUgbmV3bGluZXNcbiAgICAgIC8vIGFuZCBjaG9wIHRoZW0sIHRoZW4gbGltaXQgdGhlbTpcbiAgICAgIHZhciBhID0gbmV4dC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIGEgPSBhLnNsaWNlKDAsIG1heExpbmVzKTtcbiAgICAgIG5leHQgPSBhLmpvaW4oJ1xcbicpO1xuXG4gICAgICAvLyBXaGVuLCBhZnRlciBsaW1pdGluZyB0byBtYXhMaW5lcywgd2Ugc3RpbGwgaGF2ZSB0b28gbXVjaCB0byByZXR1cm4sXG4gICAgICAvLyBkbyBhZGQgYW4gZWxsaXBzaXMgcG9zdGZpeC4uLlxuICAgICAgaWYgKG5leHQubGVuZ3RoID4gbWF4U2l6ZSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5zdWJzdHJpbmcoMCwgbWF4U2l6ZSkgKyAnLi4uJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIHN0cmluZyB3aGljaCBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZVxuICAgICAqIGxleGluZyBlcnJvciBvY2N1cnJlZCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24gbGV4ZXJfc2hvd1Bvc2l0aW9uKG1heFByZWZpeCwgbWF4UG9zdGZpeCkge1xuICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KG1heFByZWZpeCkucmVwbGFjZSgvXFxzL2csICcgJyk7XG4gICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbignLScpO1xuICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dChtYXhQb3N0Zml4KS5yZXBsYWNlKC9cXHMvZywgJyAnKSArICdcXG4nICsgYyArICdeJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGFuIFlZTExPQyBpbmZvIG9iamVjdCBkZXJpdmVkIG9mZiB0aGUgZ2l2ZW4gY29udGV4dCAoYWN0dWFsLCBwcmVjZWRpbmcsIGZvbGxvd2luZywgY3VycmVudCkuXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHdoZW4gdGhlIGdpdmVuIGBhY3R1YWxgIGxvY2F0aW9uIGlzIG5vdCBndWFyYW50ZWVkIHRvIGV4aXN0IChpLmUuIHdoZW5cbiAgICAgKiBpdCBNQVkgYmUgTlVMTCkgYW5kIHlvdSBNVVNUIGhhdmUgYSB2YWxpZCBsb2NhdGlvbiBpbmZvIG9iamVjdCBhbnl3YXk6XG4gICAgICogdGhlbiB3ZSB0YWtlIHRoZSBnaXZlbiBjb250ZXh0IG9mIHRoZSBgcHJlY2VkaW5nYCBhbmQgYGZvbGxvd2luZ2AgbG9jYXRpb25zLCBJRkYgdGhvc2UgYXJlIGF2YWlsYWJsZSxcbiAgICAgKiBhbmQgcmVjb25zdHJ1Y3QgdGhlIGBhY3R1YWxgIGxvY2F0aW9uIGluZm8gZnJvbSB0aG9zZS5cbiAgICAgKiBJZiB0aGlzIGZhaWxzLCB0aGUgaGV1cmlzdGljIGlzIHRvIHRha2UgdGhlIGBjdXJyZW50YCBsb2NhdGlvbiwgSUZGIGF2YWlsYWJsZS5cbiAgICAgKiBJZiB0aGlzIGZhaWxzIGFzIHdlbGwsIHdlIGFzc3VtZSB0aGUgc291Z2h0IGxvY2F0aW9uIGlzIGF0L2Fyb3VuZCB0aGUgY3VycmVudCBsZXhlciBwb3NpdGlvblxuICAgICAqIGFuZCB0aGVuIHByb2R1Y2UgdGhhdCBvbmUgYXMgYSByZXNwb25zZS4gRE8gTk9URSB0aGF0IHRoZXNlIGhldXJpc3RpYy9kZXJpdmVkIGxvY2F0aW9uIGluZm9cbiAgICAgKiB2YWx1ZXMgTUFZIGJlIGluYWNjdXJhdGUhXG4gICAgICpcbiAgICAgKiBOT1RFOiBgZGVyaXZlTG9jYXRpb25JbmZvKClgIEFMV0FZUyBwcm9kdWNlcyBhIGxvY2F0aW9uIGluZm8gb2JqZWN0ICpjb3B5KiBvZiBgYWN0dWFsYCwgbm90IGp1c3RcbiAgICAgKiBhICpyZWZlcmVuY2UqIGhlbmNlIGFsbCBpbnB1dCBsb2NhdGlvbiBvYmplY3RzIGNhbiBiZSBhc3N1bWVkIHRvIGJlICdjb25zdGFudCcgKGZ1bmN0aW9uIGhhcyBubyBzaWRlLWVmZmVjdHMpLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgZGVyaXZlTG9jYXRpb25JbmZvOiBmdW5jdGlvbiBsZXhlcl9kZXJpdmVZWUxMT0MoYWN0dWFsLCBwcmVjZWRpbmcsIGZvbGxvd2luZywgY3VycmVudCkge1xuICAgICAgdmFyIGxvYyA9IHtcbiAgICAgICAgZmlyc3RfbGluZTogMSxcbiAgICAgICAgZmlyc3RfY29sdW1uOiAwLFxuICAgICAgICBsYXN0X2xpbmU6IDEsXG4gICAgICAgIGxhc3RfY29sdW1uOiAwLFxuICAgICAgICByYW5nZTogWzAsIDBdXG4gICAgICB9O1xuXG4gICAgICBpZiAoYWN0dWFsKSB7XG4gICAgICAgIGxvYy5maXJzdF9saW5lID0gYWN0dWFsLmZpcnN0X2xpbmUgfCAwO1xuICAgICAgICBsb2MubGFzdF9saW5lID0gYWN0dWFsLmxhc3RfbGluZSB8IDA7XG4gICAgICAgIGxvYy5maXJzdF9jb2x1bW4gPSBhY3R1YWwuZmlyc3RfY29sdW1uIHwgMDtcbiAgICAgICAgbG9jLmxhc3RfY29sdW1uID0gYWN0dWFsLmxhc3RfY29sdW1uIHwgMDtcblxuICAgICAgICBpZiAoYWN0dWFsLnJhbmdlKSB7XG4gICAgICAgICAgbG9jLnJhbmdlWzBdID0gYWN0dWFsLnJhbmdlWzBdIHwgMDtcbiAgICAgICAgICBsb2MucmFuZ2VbMV0gPSBhY3R1YWwucmFuZ2VbMV0gfCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2MuZmlyc3RfbGluZSA8PSAwIHx8IGxvYy5sYXN0X2xpbmUgPCBsb2MuZmlyc3RfbGluZSkge1xuICAgICAgICAvLyBwbGFuIEI6IGhldXJpc3RpYyB1c2luZyBwcmVjZWRpbmcgYW5kIGZvbGxvd2luZzpcbiAgICAgICAgaWYgKGxvYy5maXJzdF9saW5lIDw9IDAgJiYgcHJlY2VkaW5nKSB7XG4gICAgICAgICAgbG9jLmZpcnN0X2xpbmUgPSBwcmVjZWRpbmcubGFzdF9saW5lIHwgMDtcbiAgICAgICAgICBsb2MuZmlyc3RfY29sdW1uID0gcHJlY2VkaW5nLmxhc3RfY29sdW1uIHwgMDtcblxuICAgICAgICAgIGlmIChwcmVjZWRpbmcucmFuZ2UpIHtcbiAgICAgICAgICAgIGxvYy5yYW5nZVswXSA9IGFjdHVhbC5yYW5nZVsxXSB8IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChsb2MubGFzdF9saW5lIDw9IDAgfHwgbG9jLmxhc3RfbGluZSA8IGxvYy5maXJzdF9saW5lKSAmJiBmb2xsb3dpbmcpIHtcbiAgICAgICAgICBsb2MubGFzdF9saW5lID0gZm9sbG93aW5nLmZpcnN0X2xpbmUgfCAwO1xuICAgICAgICAgIGxvYy5sYXN0X2NvbHVtbiA9IGZvbGxvd2luZy5maXJzdF9jb2x1bW4gfCAwO1xuXG4gICAgICAgICAgaWYgKGZvbGxvd2luZy5yYW5nZSkge1xuICAgICAgICAgICAgbG9jLnJhbmdlWzFdID0gYWN0dWFsLnJhbmdlWzBdIHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwbGFuIEM/OiBzZWUgaWYgdGhlICdjdXJyZW50JyBsb2NhdGlvbiBpcyB1c2VmdWwvc2FuZSB0b286XG4gICAgICAgIGlmIChsb2MuZmlyc3RfbGluZSA8PSAwICYmIGN1cnJlbnQgJiYgKGxvYy5sYXN0X2xpbmUgPD0gMCB8fCBjdXJyZW50Lmxhc3RfbGluZSA8PSBsb2MubGFzdF9saW5lKSkge1xuICAgICAgICAgIGxvYy5maXJzdF9saW5lID0gY3VycmVudC5maXJzdF9saW5lIHwgMDtcbiAgICAgICAgICBsb2MuZmlyc3RfY29sdW1uID0gY3VycmVudC5maXJzdF9jb2x1bW4gfCAwO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmFuZ2UpIHtcbiAgICAgICAgICAgIGxvYy5yYW5nZVswXSA9IGN1cnJlbnQucmFuZ2VbMF0gfCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2MubGFzdF9saW5lIDw9IDAgJiYgY3VycmVudCAmJiAobG9jLmZpcnN0X2xpbmUgPD0gMCB8fCBjdXJyZW50LmZpcnN0X2xpbmUgPj0gbG9jLmZpcnN0X2xpbmUpKSB7XG4gICAgICAgICAgbG9jLmxhc3RfbGluZSA9IGN1cnJlbnQubGFzdF9saW5lIHwgMDtcbiAgICAgICAgICBsb2MubGFzdF9jb2x1bW4gPSBjdXJyZW50Lmxhc3RfY29sdW1uIHwgMDtcblxuICAgICAgICAgIGlmIChjdXJyZW50LnJhbmdlKSB7XG4gICAgICAgICAgICBsb2MucmFuZ2VbMV0gPSBjdXJyZW50LnJhbmdlWzFdIHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc2FuaXRpemU6IGZpeCBsYXN0X2xpbmUgQkVGT1JFIHdlIGZpeCBmaXJzdF9saW5lIGFzIHdlIHVzZSB0aGUgJ3JhdycgdmFsdWUgb2YgdGhlIGxhdHRlclxuICAgICAgLy8gb3IgcGxhbiBEIGhldXJpc3RpY3MgdG8gcHJvZHVjZSBhICdzZW5zaWJsZScgbGFzdF9saW5lIHZhbHVlOlxuICAgICAgaWYgKGxvYy5sYXN0X2xpbmUgPD0gMCkge1xuICAgICAgICBpZiAobG9jLmZpcnN0X2xpbmUgPD0gMCkge1xuICAgICAgICAgIGxvYy5maXJzdF9saW5lID0gdGhpcy55eWxsb2MuZmlyc3RfbGluZTtcbiAgICAgICAgICBsb2MubGFzdF9saW5lID0gdGhpcy55eWxsb2MubGFzdF9saW5lO1xuICAgICAgICAgIGxvYy5maXJzdF9jb2x1bW4gPSB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW47XG4gICAgICAgICAgbG9jLmxhc3RfY29sdW1uID0gdGhpcy55eWxsb2MubGFzdF9jb2x1bW47XG4gICAgICAgICAgbG9jLnJhbmdlWzBdID0gdGhpcy55eWxsb2MucmFuZ2VbMF07XG4gICAgICAgICAgbG9jLnJhbmdlWzFdID0gdGhpcy55eWxsb2MucmFuZ2VbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9jLmxhc3RfbGluZSA9IHRoaXMueXlsbG9jLmxhc3RfbGluZTtcbiAgICAgICAgICBsb2MubGFzdF9jb2x1bW4gPSB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbjtcbiAgICAgICAgICBsb2MucmFuZ2VbMV0gPSB0aGlzLnl5bGxvYy5yYW5nZVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobG9jLmZpcnN0X2xpbmUgPD0gMCkge1xuICAgICAgICBsb2MuZmlyc3RfbGluZSA9IGxvYy5sYXN0X2xpbmU7XG4gICAgICAgIGxvYy5maXJzdF9jb2x1bW4gPSAwOyAgLy8gbG9jLmxhc3RfY29sdW1uOyBcbiAgICAgICAgbG9jLnJhbmdlWzFdID0gbG9jLnJhbmdlWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9jLmZpcnN0X2NvbHVtbiA8IDApIHtcbiAgICAgICAgbG9jLmZpcnN0X2NvbHVtbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2MubGFzdF9jb2x1bW4gPCAwKSB7XG4gICAgICAgIGxvYy5sYXN0X2NvbHVtbiA9IChsb2MuZmlyc3RfY29sdW1uID4gMCA/IGxvYy5maXJzdF9jb2x1bW4gOiA4MCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIHN0cmluZyB3aGljaCBkaXNwbGF5cyB0aGUgbGluZXMgJiBjb2x1bW5zIG9mIGlucHV0IHdoaWNoIGFyZSByZWZlcmVuY2VkIFxuICAgICAqIGJ5IHRoZSBnaXZlbiBsb2NhdGlvbiBpbmZvIHJhbmdlLCBwbHVzIGEgZmV3IGxpbmVzIG9mIGNvbnRleHQuXG4gICAgICogXG4gICAgICogVGhpcyBmdW5jdGlvbiBwcmV0dHktcHJpbnRzIHRoZSBpbmRpY2F0ZWQgc2VjdGlvbiBvZiB0aGUgaW5wdXQsIHdpdGggbGluZSBudW1iZXJzIFxuICAgICAqIGFuZCBldmVyeXRoaW5nIVxuICAgICAqIFxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdmVyeSB1c2VmdWwgdG8gcHJvdmlkZSBoaWdobHkgcmVhZGFibGUgZXJyb3IgcmVwb3J0cywgd2hpbGVcbiAgICAgKiB0aGUgbG9jYXRpb24gcmFuZ2UgbWF5IGJlIHNwZWNpZmllZCBpbiB2YXJpb3VzIGZsZXhpYmxlIHdheXM6XG4gICAgICogXG4gICAgICogLSBgbG9jYCBpcyB0aGUgbG9jYXRpb24gaW5mbyBvYmplY3Qgd2hpY2ggcmVmZXJlbmNlcyB0aGUgYXJlYSB3aGljaCBzaG91bGQgYmVcbiAgICAgKiAgIGRpc3BsYXllZCBhbmQgJ21hcmtlZCB1cCc6IHRoZXNlIGxpbmVzICYgY29sdW1ucyBvZiB0ZXh0IGFyZSBtYXJrZWQgdXAgYnkgYF5gXG4gICAgICogICBjaGFyYWN0ZXJzIGJlbG93IGVhY2ggY2hhcmFjdGVyIGluIHRoZSBlbnRpcmUgaW5wdXQgcmFuZ2UuXG4gICAgICogXG4gICAgICogLSBgY29udGV4dF9sb2NgIGlzIHRoZSAqb3B0aW9uYWwqIGxvY2F0aW9uIGluZm8gb2JqZWN0IHdoaWNoIGluc3RydWN0cyB0aGlzXG4gICAgICogICBwcmV0dHktcHJpbnRlciBob3cgbXVjaCAqbGVhZGluZyogY29udGV4dCBzaG91bGQgYmUgZGlzcGxheWVkIGFsb25nc2lkZVxuICAgICAqICAgdGhlIGFyZWEgcmVmZXJlbmNlZCBieSBgbG9jYC4gVGhpcyBjYW4gaGVscCBwcm92aWRlIGNvbnRleHQgZm9yIHRoZSBkaXNwbGF5ZWRcbiAgICAgKiAgIGVycm9yLCBldGMuXG4gICAgICogXG4gICAgICogICBXaGVuIHRoaXMgbG9jYXRpb24gaW5mbyBpcyBub3QgcHJvdmlkZWQsIGEgZGVmYXVsdCBjb250ZXh0IG9mIDMgbGluZXMgaXNcbiAgICAgKiAgIHVzZWQuXG4gICAgICogXG4gICAgICogLSBgY29udGV4dF9sb2MyYCBpcyBhbm90aGVyICpvcHRpb25hbCogbG9jYXRpb24gaW5mbyBvYmplY3QsIHdoaWNoIHNlcnZlc1xuICAgICAqICAgYSBzaW1pbGFyIHB1cnBvc2UgdG8gYGNvbnRleHRfbG9jYDogaXQgc3BlY2lmaWVzIHRoZSBhbW91bnQgb2YgKnRyYWlsaW5nKlxuICAgICAqICAgY29udGV4dCBsaW5lcyB0byBkaXNwbGF5IGluIHRoZSBwcmV0dHktcHJpbnQgb3V0cHV0LlxuICAgICAqIFxuICAgICAqICAgV2hlbiB0aGlzIGxvY2F0aW9uIGluZm8gaXMgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQgY29udGV4dCBvZiAxIGxpbmUgb25seSBpc1xuICAgICAqICAgdXNlZC5cbiAgICAgKiBcbiAgICAgKiBTcGVjaWFsIE5vdGVzOlxuICAgICAqIFxuICAgICAqIC0gd2hlbiB0aGUgYGxvY2AtaW5kaWNhdGVkIHJhbmdlIGlzIHZlcnkgbGFyZ2UgKGFib3V0IDUgbGluZXMgb3IgbW9yZSksIHRoZW5cbiAgICAgKiAgIG9ubHkgdGhlIGZpcnN0IGFuZCBsYXN0IGZldyBsaW5lcyBvZiB0aGlzIGJsb2NrIGFyZSBwcmludGVkIHdoaWxlIGFcbiAgICAgKiAgIGAuLi5jb250aW51ZWQuLi5gIG1lc3NhZ2Ugd2lsbCBiZSBwcmludGVkIGJldHdlZW4gdGhlbS5cbiAgICAgKiBcbiAgICAgKiAgIFRoaXMgc2VydmVzIHRoZSBwdXJwb3NlIG9mIG5vdCBwcmludGluZyBhIGh1Z2UgYW1vdW50IG9mIHRleHQgd2hlbiB0aGUgYGxvY2BcbiAgICAgKiAgIHJhbmdlIGhhcHBlbnMgdG8gYmUgaHVnZTogdGhpcyB3YXkgYSBtYW5hZ2VhYmxlICYgcmVhZGFibGUgb3V0cHV0IHJlc3VsdHNcbiAgICAgKiAgIGZvciBhcmJpdHJhcnkgbGFyZ2UgcmFuZ2VzLlxuICAgICAqIFxuICAgICAqIC0gdGhpcyBmdW5jdGlvbiBjYW4gZGlzcGxheSBsaW5lcyBvZiBpbnB1dCB3aGljaCB3aGF2ZSBub3QgeWV0IGJlZW4gbGV4ZWQuXG4gICAgICogICBgcHJldHR5UHJpbnRSYW5nZSgpYCBjYW4gYWNjZXNzIHRoZSBlbnRpcmUgaW5wdXQhXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwcmV0dHlQcmludFJhbmdlOiBmdW5jdGlvbiBsZXhlcl9wcmV0dHlQcmludFJhbmdlKGxvYywgY29udGV4dF9sb2MsIGNvbnRleHRfbG9jMikge1xuICAgICAgbG9jID0gdGhpcy5kZXJpdmVMb2NhdGlvbkluZm8obG9jLCBjb250ZXh0X2xvYywgY29udGV4dF9sb2MyKTtcbiAgICAgIGNvbnN0IENPTlRFWFQgPSAzO1xuICAgICAgY29uc3QgQ09OVEVYVF9UQUlMID0gMTtcbiAgICAgIGNvbnN0IE1JTklNVU1fVklTSUJMRV9OT05FTVBUWV9MSU5FX0NPVU5UID0gMjtcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMubWF0Y2hlZCArIHRoaXMuX2lucHV0O1xuICAgICAgdmFyIGxpbmVzID0gaW5wdXQuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGwwID0gTWF0aC5tYXgoMSwgKGNvbnRleHRfbG9jID8gY29udGV4dF9sb2MuZmlyc3RfbGluZSA6IGxvYy5maXJzdF9saW5lIC0gQ09OVEVYVCkpO1xuICAgICAgdmFyIGwxID0gTWF0aC5tYXgoMSwgKGNvbnRleHRfbG9jMiA/IGNvbnRleHRfbG9jMi5sYXN0X2xpbmUgOiBsb2MubGFzdF9saW5lICsgQ09OVEVYVF9UQUlMKSk7XG4gICAgICB2YXIgbGluZW5vX2Rpc3BsYXlfd2lkdGggPSAxICsgTWF0aC5sb2cxMChsMSB8IDEpIHwgMDtcbiAgICAgIHZhciB3c19wcmVmaXggPSBuZXcgQXJyYXkobGluZW5vX2Rpc3BsYXlfd2lkdGgpLmpvaW4oJyAnKTtcbiAgICAgIHZhciBub25lbXB0eV9saW5lX2luZGV4ZXMgPSBbXTtcblxuICAgICAgdmFyIHJ2ID0gbGluZXMuc2xpY2UobDAgLSAxLCBsMSArIDEpLm1hcChmdW5jdGlvbiBpbmplY3RMaW5lTnVtYmVyKGxpbmUsIGluZGV4KSB7XG4gICAgICAgIHZhciBsbm8gPSBpbmRleCArIGwwO1xuICAgICAgICB2YXIgbG5vX3BmeCA9ICh3c19wcmVmaXggKyBsbm8pLnN1YnN0cigtbGluZW5vX2Rpc3BsYXlfd2lkdGgpO1xuICAgICAgICB2YXIgcnYgPSBsbm9fcGZ4ICsgJzogJyArIGxpbmU7XG4gICAgICAgIHZhciBlcnJwZnggPSBuZXcgQXJyYXkobGluZW5vX2Rpc3BsYXlfd2lkdGggKyAxKS5qb2luKCdeJyk7XG4gICAgICAgIHZhciBvZmZzZXQgPSAyICsgMTtcbiAgICAgICAgdmFyIGxlbiA9IDA7XG5cbiAgICAgICAgaWYgKGxubyA9PT0gbG9jLmZpcnN0X2xpbmUpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gbG9jLmZpcnN0X2NvbHVtbjtcblxuICAgICAgICAgIGxlbiA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMixcbiAgICAgICAgICAgICgobG5vID09PSBsb2MubGFzdF9saW5lID8gbG9jLmxhc3RfY29sdW1uIDogbGluZS5sZW5ndGgpKSAtIGxvYy5maXJzdF9jb2x1bW4gKyAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChsbm8gPT09IGxvYy5sYXN0X2xpbmUpIHtcbiAgICAgICAgICBsZW4gPSBNYXRoLm1heCgyLCBsb2MubGFzdF9jb2x1bW4gKyAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChsbm8gPiBsb2MuZmlyc3RfbGluZSAmJiBsbm8gPCBsb2MubGFzdF9saW5lKSB7XG4gICAgICAgICAgbGVuID0gTWF0aC5tYXgoMiwgbGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICB2YXIgbGVhZCA9IG5ldyBBcnJheShvZmZzZXQpLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgbWFyayA9IG5ldyBBcnJheShsZW4pLmpvaW4oJ14nKTtcbiAgICAgICAgICBydiArPSAnXFxuJyArIGVycnBmeCArIGxlYWQgKyBtYXJrO1xuXG4gICAgICAgICAgaWYgKGxpbmUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5vbmVtcHR5X2xpbmVfaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydiA9IHJ2LnJlcGxhY2UoL1xcdC9nLCAnICcpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9KTtcblxuICAgICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBwcmludCBhbiBvdmVybHkgbGFyZ2UgYW1vdW50IG9mIGVycm9yIGFyZWE6IGxpbWl0IGl0IFxuICAgICAgLy8gdG8gdGhlIHRvcCBhbmQgYm90dG9tIGxpbmUgY291bnQ6XG4gICAgICBpZiAobm9uZW1wdHlfbGluZV9pbmRleGVzLmxlbmd0aCA+IDIgKiBNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVCkge1xuICAgICAgICB2YXIgY2xpcF9zdGFydCA9IG5vbmVtcHR5X2xpbmVfaW5kZXhlc1tNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVCAtIDFdICsgMTtcbiAgICAgICAgdmFyIGNsaXBfZW5kID0gbm9uZW1wdHlfbGluZV9pbmRleGVzW25vbmVtcHR5X2xpbmVfaW5kZXhlcy5sZW5ndGggLSBNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVF0gLSAxO1xuICAgICAgICB2YXIgaW50ZXJtZWRpYXRlX2xpbmUgPSBuZXcgQXJyYXkobGluZW5vX2Rpc3BsYXlfd2lkdGggKyAxKS5qb2luKCcgJykgKyAnICAoLi4uY29udGludWVkLi4uKSc7XG4gICAgICAgIGludGVybWVkaWF0ZV9saW5lICs9ICdcXG4nICsgbmV3IEFycmF5KGxpbmVub19kaXNwbGF5X3dpZHRoICsgMSkuam9pbignLScpICsgJyAgKC0tLS0tLS0tLS0tLS0tLSknO1xuICAgICAgICBydi5zcGxpY2UoY2xpcF9zdGFydCwgY2xpcF9lbmQgLSBjbGlwX3N0YXJ0ICsgMSwgaW50ZXJtZWRpYXRlX2xpbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnYuam9pbignXFxuJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhlbHBlciBmdW5jdGlvbiwgdXNlZCB0byBwcm9kdWNlIGEgaHVtYW4gcmVhZGFibGUgZGVzY3JpcHRpb24gYXMgYSBzdHJpbmcsIGdpdmVuXG4gICAgICogdGhlIGlucHV0IGB5eWxsb2NgIGxvY2F0aW9uIG9iamVjdC5cbiAgICAgKiBcbiAgICAgKiBTZXQgYGRpc3BsYXlfcmFuZ2VfdG9vYCB0byBUUlVFIHRvIGluY2x1ZGUgdGhlIHN0cmluZyBjaGFyYWN0ZXIgaW5kZXggcG9zaXRpb24ocylcbiAgICAgKiBpbiB0aGUgZGVzY3JpcHRpb24gaWYgdGhlIGB5eWxsb2MucmFuZ2VgIGlzIGF2YWlsYWJsZS5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGRlc2NyaWJlWVlMTE9DOiBmdW5jdGlvbiBsZXhlcl9kZXNjcmliZV95eWxsb2MoeXlsbG9jLCBkaXNwbGF5X3JhbmdlX3Rvbykge1xuICAgICAgdmFyIGwxID0geXlsbG9jLmZpcnN0X2xpbmU7XG4gICAgICB2YXIgbDIgPSB5eWxsb2MubGFzdF9saW5lO1xuICAgICAgdmFyIGMxID0geXlsbG9jLmZpcnN0X2NvbHVtbjtcbiAgICAgIHZhciBjMiA9IHl5bGxvYy5sYXN0X2NvbHVtbjtcbiAgICAgIHZhciBkbCA9IGwyIC0gbDE7XG4gICAgICB2YXIgZGMgPSBjMiAtIGMxO1xuICAgICAgdmFyIHJ2O1xuXG4gICAgICBpZiAoZGwgPT09IDApIHtcbiAgICAgICAgcnYgPSAnbGluZSAnICsgbDEgKyAnLCAnO1xuXG4gICAgICAgIGlmIChkYyA8PSAxKSB7XG4gICAgICAgICAgcnYgKz0gJ2NvbHVtbiAnICsgYzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnYgKz0gJ2NvbHVtbnMgJyArIGMxICsgJyAuLiAnICsgYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2ID0gJ2xpbmVzICcgKyBsMSArICcoY29sdW1uICcgKyBjMSArICcpIC4uICcgKyBsMiArICcoY29sdW1uICcgKyBjMiArICcpJztcbiAgICAgIH1cblxuICAgICAgaWYgKHl5bGxvYy5yYW5nZSAmJiBkaXNwbGF5X3JhbmdlX3Rvbykge1xuICAgICAgICB2YXIgcjEgPSB5eWxsb2MucmFuZ2VbMF07XG4gICAgICAgIHZhciByMiA9IHl5bGxvYy5yYW5nZVsxXSAtIDE7XG5cbiAgICAgICAgaWYgKHIyIDw9IHIxKSB7XG4gICAgICAgICAgcnYgKz0gJyB7U3RyaW5nIE9mZnNldDogJyArIHIxICsgJ30nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ2ICs9ICcge1N0cmluZyBPZmZzZXQgcmFuZ2U6ICcgKyByMSArICcgLi4gJyArIHIyICsgJ30nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGVzdCB0aGUgbGV4ZWQgdG9rZW46IHJldHVybiBGQUxTRSB3aGVuIG5vdCBhIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIHRva2VuLlxuICAgICAqIFxuICAgICAqIGBtYXRjaGAgaXMgc3VwcG9zZWQgdG8gYmUgYW4gYXJyYXkgY29taW5nIG91dCBvZiBhIHJlZ2V4IG1hdGNoLCBpLmUuIGBtYXRjaFswXWBcbiAgICAgKiBjb250YWlucyB0aGUgYWN0dWFsbHkgbWF0Y2hlZCB0ZXh0IHN0cmluZy5cbiAgICAgKiBcbiAgICAgKiBBbHNvIG1vdmUgdGhlIGlucHV0IGN1cnNvciBmb3J3YXJkIGFuZCB1cGRhdGUgdGhlIG1hdGNoIGNvbGxlY3RvcnM6XG4gICAgICogXG4gICAgICogLSBgeXl0ZXh0YFxuICAgICAqIC0gYHl5bGVuZ2BcbiAgICAgKiAtIGBtYXRjaGBcbiAgICAgKiAtIGBtYXRjaGVzYFxuICAgICAqIC0gYHl5bGxvY2BcbiAgICAgKiAtIGBvZmZzZXRgXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbiBsZXhlcl90ZXN0X21hdGNoKG1hdGNoLCBpbmRleGVkX3J1bGUpIHtcbiAgICAgIHZhciB0b2tlbiwgbGluZXMsIGJhY2t1cCwgbWF0Y2hfc3RyLCBtYXRjaF9zdHJfbGVuO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAvLyBzYXZlIGNvbnRleHRcbiAgICAgICAgYmFja3VwID0ge1xuICAgICAgICAgIHl5bGluZW5vOiB0aGlzLnl5bGluZW5vLFxuXG4gICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgIHJhbmdlOiB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LFxuICAgICAgICAgIG1hdGNoOiB0aGlzLm1hdGNoLFxuICAgICAgICAgIG1hdGNoZXM6IHRoaXMubWF0Y2hlcyxcbiAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsXG4gICAgICAgICAgeXlsZW5nOiB0aGlzLnl5bGVuZyxcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLFxuICAgICAgICAgIF9pbnB1dDogdGhpcy5faW5wdXQsXG5cbiAgICAgICAgICAvL19zaWduYWxlZF9lcnJvcl90b2tlbjogdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4sXG4gICAgICAgICAgeXk6IHRoaXMueXksXG5cbiAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSxcbiAgICAgICAgICBkb25lOiB0aGlzLmRvbmVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2hfc3RyID0gbWF0Y2hbMF07XG4gICAgICBtYXRjaF9zdHJfbGVuID0gbWF0Y2hfc3RyLmxlbmd0aDtcblxuICAgICAgLy8gaWYgKG1hdGNoX3N0ci5pbmRleE9mKCdcXG4nKSAhPT0gLTEgfHwgbWF0Y2hfc3RyLmluZGV4T2YoJ1xccicpICE9PSAtMSkge1xuICAgICAgbGluZXMgPSBtYXRjaF9zdHIuc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcblxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy55eWxpbmVubyArPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUgPSB0aGlzLnl5bGluZW5vICsgMTtcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArPSBtYXRjaF9zdHJfbGVuO1xuICAgICAgfVxuXG4gICAgICAvLyB9XG4gICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaF9zdHI7XG5cbiAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hfc3RyO1xuICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoX3N0cjtcbiAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSArPSBtYXRjaF9zdHJfbGVuO1xuXG4gICAgICAvLyBwcmV2aW91cyBsZXggcnVsZXMgTUFZIGhhdmUgaW52b2tlZCB0aGUgYG1vcmUoKWAgQVBJIHJhdGhlciB0aGFuIHByb2R1Y2luZyBhIHRva2VuOlxuICAgICAgLy8gdGhvc2UgcnVsZXMgd2lsbCBhbHJlYWR5IGhhdmUgbW92ZWQgdGhpcyBgb2Zmc2V0YCBmb3J3YXJkIG1hdGNoaW5nIHRoZWlyIG1hdGNoIGxlbmd0aHMsXG4gICAgICAvLyBoZW5jZSB3ZSBtdXN0IG9ubHkgYWRkIG91ciBvd24gbWF0Y2ggbGVuZ3RoIG5vdzpcbiAgICAgIHRoaXMub2Zmc2V0ICs9IG1hdGNoX3N0cl9sZW47XG5cbiAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2JhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaF9zdHJfbGVuKTtcblxuICAgICAgLy8gY2FsbGluZyB0aGlzIG1ldGhvZDpcbiAgICAgIC8vXG4gICAgICAvLyAgIGZ1bmN0aW9uIGxleGVyX19wZXJmb3JtQWN0aW9uKHl5LCB5eXJ1bGVudW1iZXIsIFlZX1NUQVJUKSB7Li4ufVxuICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy55eSxcbiAgICAgICAgaW5kZXhlZF9ydWxlLFxuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0gLyogPSBZWV9TVEFSVCAqL1xuICAgICAgKTtcblxuICAgICAgLy8gb3RoZXJ3aXNlLCB3aGVuIHRoZSBhY3Rpb24gY29kZXMgYXJlIGFsbCBzaW1wbGUgcmV0dXJuIHRva2VuIHN0YXRlbWVudHM6XG4gICAgICAvL3Rva2VuID0gdGhpcy5zaW1wbGVDYXNlQWN0aW9uQ2x1c3RlcnNbaW5kZXhlZF9ydWxlXTtcblxuICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkge1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgIC8vIHJlY292ZXIgY29udGV4dFxuICAgICAgICBmb3IgKHZhciBrIGluIGJhY2t1cCkge1xuICAgICAgICAgIHRoaXNba10gPSBiYWNrdXBba107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXyA9IG51bGw7XG4gICAgICAgIHJldHVybiBmYWxzZTsgIC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyB0aGUgbmV4dCBydWxlIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC4gXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuKSB7XG4gICAgICAgIC8vIHByb2R1Y2Ugb25lICdlcnJvcicgdG9rZW4gYXMgYC5wYXJzZUVycm9yKClgIGluIGByZWplY3QoKWBcbiAgICAgICAgLy8gZGlkIG5vdCBndWFyYW50ZWUgYSBmYWlsdXJlIHNpZ25hbCBieSB0aHJvd2luZyBhbiBleGNlcHRpb24hXG4gICAgICAgIHRva2VuID0gdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW47XG5cbiAgICAgICAgdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBuZXh0OiBmdW5jdGlvbiBsZXhlcl9uZXh0KCkge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9rZW4sIG1hdGNoLCB0ZW1wTWF0Y2gsIGluZGV4O1xuXG4gICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3BlYyA9IHRoaXMuX19jdXJyZW50UnVsZVNldF9fO1xuXG4gICAgICBpZiAoIXNwZWMpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBydWxlc2V0IGNhY2hlIGFzIHdlIGFwcGFyZW50bHkgZW5jb3VudGVyZWQgYSBzdGF0ZSBjaGFuZ2Ugb3IganVzdCBzdGFydGVkIGxleGluZy5cbiAgICAgICAgLy8gVGhlIGNhY2hlIGlzIHNldCB1cCBmb3IgZmFzdCBsb29rdXAgLS0gd2UgYXNzdW1lIGEgbGV4ZXIgd2lsbCBzd2l0Y2ggc3RhdGVzIG11Y2ggbGVzcyBvZnRlbiB0aGFuIGl0IHdpbGxcbiAgICAgICAgLy8gaW52b2tlIHRoZSBgbGV4KClgIHRva2VuLXByb2R1Y2luZyBBUEkgYW5kIHJlbGF0ZWQgQVBJcywgaGVuY2UgY2FjaGluZyB0aGUgc2V0IGZvciBkaXJlY3QgYWNjZXNzIGhlbHBzXG4gICAgICAgIC8vIHNwZWVkIHVwIHRob3NlIGFjdGl2aXRpZXMgYSB0aW55IGJpdC5cbiAgICAgICAgc3BlYyA9IHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBhICpzYW5lKiBjb25kaXRpb24gaGFzIGJlZW4gcHVzaGVkIGJlZm9yZTogdGhpcyBtYWtlcyB0aGUgbGV4ZXIgcm9idXN0IGFnYWluc3RcbiAgICAgICAgLy8gdXNlci1wcm9ncmFtbWVyIGJ1Z3Mgc3VjaCBhcyBodHRwczovL2dpdGh1Yi5jb20vemFhY2gvamlzb24tbGV4L2lzc3Vlcy8xOVxuICAgICAgICBpZiAoIXNwZWMgfHwgIXNwZWMucnVsZXMpIHtcbiAgICAgICAgICB2YXIgbGluZW5vX21zZyA9ICcnO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBsaW5lbm9fbXNnID0gJyBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwID0gdGhpcy5jb25zdHJ1Y3RMZXhFcnJvckluZm8oXG4gICAgICAgICAgICAnSW50ZXJuYWwgbGV4ZXIgZW5naW5lIGVycm9yJyArIGxpbmVub19tc2cgKyAnOiBUaGUgbGV4IGdyYW1tYXIgcHJvZ3JhbW1lciBwdXNoZWQgYSBub24tZXhpc3RpbmcgY29uZGl0aW9uIG5hbWUgXCInICsgdGhpcy50b3BTdGF0ZSgpICsgJ1wiOyB0aGlzIGlzIGEgZmF0YWwgZXJyb3IgYW5kIHNob3VsZCBiZSByZXBvcnRlZCB0byB0aGUgYXBwbGljYXRpb24gcHJvZ3JhbW1lciB0ZWFtIScsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBwcm9kdWNlIG9uZSAnZXJyb3InIHRva2VuIHVudGlsIHRoaXMgc2l0dWF0aW9uIGhhcyBiZWVuIHJlc29sdmVkLCBtb3N0IHByb2JhYmx5IGJ5IHBhcnNlIHRlcm1pbmF0aW9uIVxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25MZXhlckVycm9yKSB8fCB0aGlzLkVSUk9SO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBydWxlX2lkcyA9IHNwZWMucnVsZXM7XG4gICAgICB2YXIgcmVnZXhlcyA9IHNwZWMuX19ydWxlX3JlZ2V4ZXM7XG4gICAgICB2YXIgbGVuID0gc3BlYy5fX3J1bGVfY291bnQ7XG5cbiAgICAgIC8vIE5vdGU6IHRoZSBhcnJheXMgYXJlIDEtYmFzZWQsIHdoaWxlIGBsZW5gIGl0c2VsZiBpcyBhIHZhbGlkIGluZGV4LFxuICAgICAgLy8gaGVuY2UgdGhlIG5vbi1zdGFuZGFyZCBsZXNzLW9yLWVxdWFsIGNoZWNrIGluIHRoZSBuZXh0IGxvb3AgY29uZGl0aW9uIVxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2gocmVnZXhlc1tpXSk7XG5cbiAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKHRlbXBNYXRjaCwgcnVsZV9pZHNbaV0pO1xuXG4gICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBjb250aW51ZTsgIC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyBhIHJ1bGUgTUlTbWF0Y2guIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2gobWF0Y2gsIHJ1bGVfaWRzW2luZGV4XSk7XG5cbiAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxpbmVub19tc2cgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICBsaW5lbm9fbXNnID0gJyBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdExleEVycm9ySW5mbyhcbiAgICAgICAgICAnTGV4aWNhbCBlcnJvcicgKyBsaW5lbm9fbXNnICsgJzogVW5yZWNvZ25pemVkIHRleHQuJyxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubGV4ZXJFcnJvcnNBcmVSZWNvdmVyYWJsZVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBwZW5kaW5nSW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICAgICAgdmFyIGFjdGl2ZUNvbmRpdGlvbiA9IHRoaXMudG9wU3RhdGUoKTtcbiAgICAgICAgdmFyIGNvbmRpdGlvblN0YWNrRGVwdGggPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aDtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25MZXhlckVycm9yKSB8fCB0aGlzLkVSUk9SO1xuXG4gICAgICAgIGlmICh0b2tlbiA9PT0gdGhpcy5FUlJPUikge1xuICAgICAgICAgIC8vIHdlIGNhbiB0cnkgdG8gcmVjb3ZlciBmcm9tIGEgbGV4ZXIgZXJyb3IgdGhhdCBgcGFyc2VFcnJvcigpYCBkaWQgbm90ICdyZWNvdmVyJyBmb3IgdXNcbiAgICAgICAgICAvLyBieSBtb3ZpbmcgZm9yd2FyZCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZSBJRkYgdGhlICh1c2VyLXNwZWNpZmllZD8pIGBwYXJzZUVycm9yKClgXG4gICAgICAgICAgLy8gaGFzIG5vdCBjb25zdW1lZC9tb2RpZmllZCBhbnkgcGVuZGluZyBpbnB1dCBvciBjaGFuZ2VkIHN0YXRlIGluIHRoZSBlcnJvciBoYW5kbGVyOlxuICAgICAgICAgIGlmICghdGhpcy5tYXRjaGVzICYmIC8vIGFuZCBtYWtlIHN1cmUgdGhlIGlucHV0IGhhcyBiZWVuIG1vZGlmaWVkL2NvbnN1bWVkIC4uLlxuICAgICAgICAgIHBlbmRpbmdJbnB1dCA9PT0gdGhpcy5faW5wdXQgJiYgLy8gLi4ub3IgdGhlIGxleGVyIHN0YXRlIGhhcyBiZWVuIG1vZGlmaWVkIHNpZ25pZmljYW50bHkgZW5vdWdoXG4gICAgICAgICAgLy8gdG8gbWVyaXQgYSBub24tY29uc3VtaW5nIGVycm9yIGhhbmRsaW5nIGFjdGlvbiByaWdodCBub3cuXG4gICAgICAgICAgYWN0aXZlQ29uZGl0aW9uID09PSB0aGlzLnRvcFN0YXRlKCkgJiYgY29uZGl0aW9uU3RhY2tEZXB0aCA9PT0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGxleDogZnVuY3Rpb24gbGV4ZXJfbGV4KCkge1xuICAgICAgdmFyIHI7XG5cbiAgICAgIC8vIGFsbG93IHRoZSBQUkUvUE9TVCBoYW5kbGVycyBzZXQvbW9kaWZ5IHRoZSByZXR1cm4gdG9rZW4gZm9yIG1heGltdW0gZmxleGliaWxpdHkgb2YgdGhlIGdlbmVyYXRlZCBsZXhlcjpcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVfbGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHIgPSB0aGlzLnByZV9sZXguY2FsbCh0aGlzLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucHJlX2xleCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoYWxzbyBhY2NvdW50IGZvciBhIHVzZXJkZWYgZnVuY3Rpb24gd2hpY2ggZG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZToga2VlcCB0aGUgdG9rZW4gYXMgaXMpXG4gICAgICAgIHIgPSB0aGlzLm9wdGlvbnMucHJlX2xleC5jYWxsKHRoaXMsIHIpIHx8IHI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnl5ICYmIHR5cGVvZiB0aGlzLnl5LnByZV9sZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKGFsc28gYWNjb3VudCBmb3IgYSB1c2VyZGVmIGZ1bmN0aW9uIHdoaWNoIGRvZXMgbm90IHJldHVybiBhbnkgdmFsdWU6IGtlZXAgdGhlIHRva2VuIGFzIGlzKVxuICAgICAgICByID0gdGhpcy55eS5wcmVfbGV4LmNhbGwodGhpcywgcikgfHwgcjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCFyKSB7XG4gICAgICAgIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMueXkgJiYgdHlwZW9mIHRoaXMueXkucG9zdF9sZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKGFsc28gYWNjb3VudCBmb3IgYSB1c2VyZGVmIGZ1bmN0aW9uIHdoaWNoIGRvZXMgbm90IHJldHVybiBhbnkgdmFsdWU6IGtlZXAgdGhlIHRva2VuIGFzIGlzKVxuICAgICAgICByID0gdGhpcy55eS5wb3N0X2xleC5jYWxsKHRoaXMsIHIpIHx8IHI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnBvc3RfbGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIChhbHNvIGFjY291bnQgZm9yIGEgdXNlcmRlZiBmdW5jdGlvbiB3aGljaCBkb2VzIG5vdCByZXR1cm4gYW55IHZhbHVlOiBrZWVwIHRoZSB0b2tlbiBhcyBpcylcbiAgICAgICAgciA9IHRoaXMub3B0aW9ucy5wb3N0X2xleC5jYWxsKHRoaXMsIHIpIHx8IHI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5wb3N0X2xleCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoYWxzbyBhY2NvdW50IGZvciBhIHVzZXJkZWYgZnVuY3Rpb24gd2hpY2ggZG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZToga2VlcCB0aGUgdG9rZW4gYXMgaXMpXG4gICAgICAgIHIgPSB0aGlzLnBvc3RfbGV4LmNhbGwodGhpcywgcikgfHwgcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW4uIElkZW50aWNhbCB0byB0aGUgYGxleCgpYCBBUEkgYnV0IGRvZXMgbm90IGludm9rZSBhbnkgb2YgdGhlIFxuICAgICAqIGBwcmVfbGV4KClgIG5vciBhbnkgb2YgdGhlIGBwb3N0X2xleCgpYCBjYWxsYmFja3MuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBmYXN0TGV4OiBmdW5jdGlvbiBsZXhlcl9mYXN0TGV4KCkge1xuICAgICAgdmFyIHI7XG5cbiAgICAgIHdoaWxlICghcikge1xuICAgICAgICByID0gdGhpcy5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gaW5mbyBhYm91dCB0aGUgbGV4ZXIgc3RhdGUgdGhhdCBjYW4gaGVscCBhIHBhcnNlciBvciBvdGhlciBsZXhlciBBUEkgdXNlciB0byB1c2UgdGhlXG4gICAgICogbW9zdCBlZmZpY2llbnQgbWVhbnMgYXZhaWxhYmxlLiBUaGlzIEFQSSBpcyBwcm92aWRlZCB0byBhaWQgcnVuLXRpbWUgcGVyZm9ybWFuY2UgZm9yIGxhcmdlclxuICAgICAqIHN5c3RlbXMgd2hpY2ggZW1wbG95IHRoaXMgbGV4ZXIuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBjYW5JVXNlOiBmdW5jdGlvbiBsZXhlcl9jYW5JVXNlKCkge1xuICAgICAgdmFyIHJ2ID0ge1xuICAgICAgICBmYXN0TGV4OiAhKHR5cGVvZiB0aGlzLnByZV9sZXggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHRoaXMub3B0aW9ucy5wcmVfbGV4ID09PSAnZnVuY3Rpb24nIHx8IHRoaXMueXkgJiYgdHlwZW9mIHRoaXMueXkucHJlX2xleCA9PT0gJ2Z1bmN0aW9uJyB8fCB0aGlzLnl5ICYmIHR5cGVvZiB0aGlzLnl5LnBvc3RfbGV4ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0aGlzLm9wdGlvbnMucG9zdF9sZXggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHRoaXMucG9zdF9sZXggPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB0aGlzLmZhc3RMZXggPT09ICdmdW5jdGlvbidcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBydjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmFja3dhcmRzIGNvbXBhdGlibGUgYWxpYXMgZm9yIGBwdXNoU3RhdGUoKWA7XG4gICAgICogdGhlIGxhdHRlciBpcyBzeW1tZXRyaWNhbCB3aXRoIGBwb3BTdGF0ZSgpYCBhbmQgd2UgYWR2aXNlIHRvIHVzZVxuICAgICAqIHRob3NlIEFQSXMgaW4gYW55IG1vZGVybiBsZXhlciBjb2RlLCByYXRoZXIgdGhhbiBgYmVnaW4oKWAuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBiZWdpbjogZnVuY3Rpb24gbGV4ZXJfYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhdGUoY29uZGl0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYWN0aXZhdGVzIGEgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSAocHVzaGVzIHRoZSBuZXcgbGV4ZXJcbiAgICAgKiBjb25kaXRpb24gc3RhdGUgb250byB0aGUgY29uZGl0aW9uIHN0YWNrKVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcHVzaFN0YXRlOiBmdW5jdGlvbiBsZXhlcl9wdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgICAgIHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwb3AgdGhlIHByZXZpb3VzbHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvZmYgdGhlIGNvbmRpdGlvblxuICAgICAqIHN0YWNrXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBwb3BTdGF0ZTogZnVuY3Rpb24gbGV4ZXJfcG9wU3RhdGUoKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMTtcblxuICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgIHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZTsgd2hlbiBhbiBpbmRleFxuICAgICAqIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGl0IHByb2R1Y2VzIHRoZSBOLXRoIHByZXZpb3VzIGNvbmRpdGlvbiBzdGF0ZSxcbiAgICAgKiBpZiBhdmFpbGFibGVcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHRvcFN0YXRlOiBmdW5jdGlvbiBsZXhlcl90b3BTdGF0ZShuKSB7XG4gICAgICBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxIC0gTWF0aC5hYnMobiB8fCAwKTtcblxuICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnSU5JVElBTCc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIChpbnRlcm5hbCkgZGV0ZXJtaW5lIHRoZSBsZXhlciBydWxlIHNldCB3aGljaCBpcyBhY3RpdmUgZm9yIHRoZVxuICAgICAqIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbiBsZXhlcl9fY3VycmVudFJ1bGVzKCkge1xuICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoICYmIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zWydJTklUSUFMJ107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBzdGF0ZVN0YWNrU2l6ZTogZnVuY3Rpb24gbGV4ZXJfc3RhdGVTdGFja1NpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgfSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRyYWNrUG9zaXRpb246IHRydWVcbiAgICB9LFxuXG4gICAgSmlzb25MZXhlckVycm9yOiBKaXNvbkxleGVyRXJyb3IsXG5cbiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBsZXhlcl9fcGVyZm9ybUFjdGlvbih5eSwgeXlydWxlbnVtYmVyLCBZWV9TVEFSVCkge1xuICAgICAgdmFyIHl5XyA9IHRoaXM7XG4gICAgICB2YXIgWVlTVEFURSA9IFlZX1NUQVJUO1xuXG4gICAgICBzd2l0Y2ggKHl5cnVsZW51bWJlcikge1xuICAgICAgY2FzZSAxOlxuICAgICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgICAgLyohIFJ1bGU6OiAgICAgICBcXHMrICovXG4gICAgICAgIC8qIHNraXAgd2hpdGVzcGFjZSAqL1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltcGxlQ2FzZUFjdGlvbkNsdXN0ZXJzW3l5cnVsZW51bWJlcl07XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpbXBsZUNhc2VBY3Rpb25DbHVzdGVyczoge1xuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgICgtLVswLTlhLXotQS1aLV0qKSAqL1xuICAgICAgMDogMTMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXCogKi9cbiAgICAgIDI6IDUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXC8gKi9cbiAgICAgIDM6IDYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXCsgKi9cbiAgICAgIDQ6IDMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAtICovXG4gICAgICA1OiA0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspcHhcXGIgKi9cbiAgICAgIDY6IDE1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspY21cXGIgKi9cbiAgICAgIDc6IDE1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspbW1cXGIgKi9cbiAgICAgIDg6IDE1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspaW5cXGIgKi9cbiAgICAgIDk6IDE1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspcHRcXGIgKi9cbiAgICAgIDEwOiAxNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKXBjXFxiICovXG4gICAgICAxMTogMTUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKylkZWdcXGIgKi9cbiAgICAgIDEyOiAxNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKWdyYWRcXGIgKi9cbiAgICAgIDEzOiAxNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKXJhZFxcYiAqL1xuICAgICAgMTQ6IDE2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspdHVyblxcYiAqL1xuICAgICAgMTU6IDE2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspc1xcYiAqL1xuICAgICAgMTY6IDE3LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspbXNcXGIgKi9cbiAgICAgIDE3OiAxNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKUh6XFxiICovXG4gICAgICAxODogMTgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKylrSHpcXGIgKi9cbiAgICAgIDE5OiAxOCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKWRwaVxcYiAqL1xuICAgICAgMjA6IDE5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspZHBjbVxcYiAqL1xuICAgICAgMjE6IDE5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspZHBweFxcYiAqL1xuICAgICAgMjI6IDE5LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspZW1cXGIgKi9cbiAgICAgIDIzOiAyMCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKWV4XFxiICovXG4gICAgICAyNDogMjEsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKyljaFxcYiAqL1xuICAgICAgMjU6IDIyLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspcmVtXFxiICovXG4gICAgICAyNjogMjMsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKyl2d1xcYiAqL1xuICAgICAgMjc6IDI1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspdmhcXGIgKi9cbiAgICAgIDI4OiAyNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKXZtaW5cXGIgKi9cbiAgICAgIDI5OiAyNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKXZtYXhcXGIgKi9cbiAgICAgIDMwOiAyNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKSUgKi9cbiAgICAgIDMxOiAyOCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKVxcYiAqL1xuICAgICAgMzI6IDExLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKGNhbGMpICovXG4gICAgICAzMzogOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgICh2YXIpICovXG4gICAgICAzNDogMTIsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoW2Etel0rKSAqL1xuICAgICAgMzU6IDEwLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwoICovXG4gICAgICAzNjogNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcKSAqL1xuICAgICAgMzc6IDgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAsICovXG4gICAgICAzODogMTQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAkICovXG4gICAgICAzOTogMVxuICAgIH0sXG5cbiAgICBydWxlczogW1xuICAgICAgLyogIDA6ICovICAvXig/OigtLVtcXGRcXC1BLVphLXpdKikpLyxcbiAgICAgIC8qICAxOiAqLyAgL14oPzpcXHMrKS8sXG4gICAgICAvKiAgMjogKi8gIC9eKD86XFwqKS8sXG4gICAgICAvKiAgMzogKi8gIC9eKD86XFwvKS8sXG4gICAgICAvKiAgNDogKi8gIC9eKD86XFwrKS8sXG4gICAgICAvKiAgNTogKi8gIC9eKD86LSkvLFxuICAgICAgLyogIDY6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKXB4XFxiKS8sXG4gICAgICAvKiAgNzogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspY21cXGIpLyxcbiAgICAgIC8qICA4OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKyltbVxcYikvLFxuICAgICAgLyogIDk6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKWluXFxiKS8sXG4gICAgICAvKiAxMDogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspcHRcXGIpLyxcbiAgICAgIC8qIDExOiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylwY1xcYikvLFxuICAgICAgLyogMTI6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKWRlZ1xcYikvLFxuICAgICAgLyogMTM6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKWdyYWRcXGIpLyxcbiAgICAgIC8qIDE0OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylyYWRcXGIpLyxcbiAgICAgIC8qIDE1OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKyl0dXJuXFxiKS8sXG4gICAgICAvKiAxNjogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspc1xcYikvLFxuICAgICAgLyogMTc6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKW1zXFxiKS8sXG4gICAgICAvKiAxODogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspSHpcXGIpLyxcbiAgICAgIC8qIDE5OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylrSHpcXGIpLyxcbiAgICAgIC8qIDIwOiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylkcGlcXGIpLyxcbiAgICAgIC8qIDIxOiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylkcGNtXFxiKS8sXG4gICAgICAvKiAyMjogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspZHBweFxcYikvLFxuICAgICAgLyogMjM6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKWVtXFxiKS8sXG4gICAgICAvKiAyNDogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspZXhcXGIpLyxcbiAgICAgIC8qIDI1OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKyljaFxcYikvLFxuICAgICAgLyogMjY6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKXJlbVxcYikvLFxuICAgICAgLyogMjc6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKXZ3XFxiKS8sXG4gICAgICAvKiAyODogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspdmhcXGIpLyxcbiAgICAgIC8qIDI5OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKyl2bWluXFxiKS8sXG4gICAgICAvKiAzMDogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspdm1heFxcYikvLFxuICAgICAgLyogMzE6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKSUpLyxcbiAgICAgIC8qIDMyOiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylcXGIpLyxcbiAgICAgIC8qIDMzOiAqLyAgL14oPzooY2FsYykpLyxcbiAgICAgIC8qIDM0OiAqLyAgL14oPzoodmFyKSkvLFxuICAgICAgLyogMzU6ICovICAvXig/OihbYS16XSspKS8sXG4gICAgICAvKiAzNjogKi8gIC9eKD86XFwoKS8sXG4gICAgICAvKiAzNzogKi8gIC9eKD86XFwpKS8sXG4gICAgICAvKiAzODogKi8gIC9eKD86LCkvLFxuICAgICAgLyogMzk6ICovICAvXig/OiQpL1xuICAgIF0sXG5cbiAgICBjb25kaXRpb25zOiB7XG4gICAgICAnSU5JVElBTCc6IHtcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMixcbiAgICAgICAgICAzLFxuICAgICAgICAgIDQsXG4gICAgICAgICAgNSxcbiAgICAgICAgICA2LFxuICAgICAgICAgIDcsXG4gICAgICAgICAgOCxcbiAgICAgICAgICA5LFxuICAgICAgICAgIDEwLFxuICAgICAgICAgIDExLFxuICAgICAgICAgIDEyLFxuICAgICAgICAgIDEzLFxuICAgICAgICAgIDE0LFxuICAgICAgICAgIDE1LFxuICAgICAgICAgIDE2LFxuICAgICAgICAgIDE3LFxuICAgICAgICAgIDE4LFxuICAgICAgICAgIDE5LFxuICAgICAgICAgIDIwLFxuICAgICAgICAgIDIxLFxuICAgICAgICAgIDIyLFxuICAgICAgICAgIDIzLFxuICAgICAgICAgIDI0LFxuICAgICAgICAgIDI1LFxuICAgICAgICAgIDI2LFxuICAgICAgICAgIDI3LFxuICAgICAgICAgIDI4LFxuICAgICAgICAgIDI5LFxuICAgICAgICAgIDMwLFxuICAgICAgICAgIDMxLFxuICAgICAgICAgIDMyLFxuICAgICAgICAgIDMzLFxuICAgICAgICAgIDM0LFxuICAgICAgICAgIDM1LFxuICAgICAgICAgIDM2LFxuICAgICAgICAgIDM3LFxuICAgICAgICAgIDM4LFxuICAgICAgICAgIDM5XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsZXhlcjtcbn0oKTtcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuXG5cblxuZnVuY3Rpb24gUGFyc2VyKCkge1xuICB0aGlzLnl5ID0ge307XG59XG5QYXJzZXIucHJvdG90eXBlID0gcGFyc2VyO1xucGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcblxucmV0dXJuIG5ldyBQYXJzZXIoKTtcbn0pKCk7XG5cbiAgICAgICAgXG5cblxuaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG4gIGV4cG9ydHMuUGFyc2VyID0gcGFyc2VyLlBhcnNlcjtcbiAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlLmFwcGx5KHBhcnNlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgXG59XG4iXSwibmFtZXMiOlsicGFyc2VyIiwiSmlzb25QYXJzZXJFcnJvciIsIm1zZyIsImhhc2giLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwic3RhY2t0cmFjZSIsImV4Y2VwdGlvbiIsIkVycm9yIiwiZXgyIiwibWVzc2FnZSIsInN0YWNrIiwiaGFzT3duUHJvcGVydHkiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImNvbnN0cnVjdG9yIiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJjcmVhdGUiLCJuYW1lIiwiYnAiLCJzIiwicnYiLCJwIiwicG9wIiwiciIsInJ1bGUiLCJpIiwibCIsImxlbmd0aCIsInB1c2giLCJiZGEiLCJkIiwiaWR4IiwiZyIsImdvdG8iLCJqIiwiYnQiLCJsZW4iLCJ5Iiwic3ltYm9sIiwidCIsInR5cGUiLCJhIiwic3RhdGUiLCJtIiwibW9kZSIsIm4iLCJxIiwieiIsInNoaWZ0IiwiYyIsInUiLCJlIiwiYXBwbHkiLCJ0cmFjZSIsIm5vX29wX3RyYWNlIiwieXkiLCJvcHRpb25zIiwiaGFzUGFydGlhbExyVXBncmFkZU9uQ29uZmxpY3QiLCJlcnJvclJlY292ZXJ5VG9rZW5EaXNjYXJkQ291bnQiLCJzeW1ib2xzXyIsInRlcm1pbmFsc18iLCJURVJST1IiLCJFT0YiLCJvcmlnaW5hbFF1b3RlTmFtZSIsIm9yaWdpbmFsUGFyc2VFcnJvciIsImNsZWFudXBBZnRlclBhcnNlIiwiY29uc3RydWN0UGFyc2VFcnJvckluZm8iLCJ5eU1lcmdlTG9jYXRpb25JbmZvIiwiX19yZWVudHJhbnRfY2FsbF9kZXB0aCIsIl9fZXJyb3JfaW5mb3MiLCJfX2Vycm9yX3JlY292ZXJ5X2luZm9zIiwicXVvdGVOYW1lIiwicGFyc2VyX3F1b3RlTmFtZSIsImlkX3N0ciIsImdldFN5bWJvbE5hbWUiLCJwYXJzZXJfZ2V0U3ltYm9sTmFtZSIsImtleSIsImRlc2NyaWJlU3ltYm9sIiwicGFyc2VyX2Rlc2NyaWJlU3ltYm9sIiwidGVybWluYWxfZGVzY3JpcHRpb25zXyIsImlkIiwiY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQiLCJwYXJzZXJfY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQiLCJkb19ub3RfZGVzY3JpYmUiLCJ0b2tlbnNldCIsImNoZWNrIiwic3RhdGVfZGVzY3JpcHRpb25zXyIsInRhYmxlIiwicHJvZHVjdGlvbnNfIiwicGVyZm9ybUFjdGlvbiIsInBhcnNlcl9fUGVyZm9ybUFjdGlvbiIsInl5c3RhdGUiLCJ5eXNwIiwieXl2c3RhY2siLCJ5eXBhcnNlciIsInl5bGV4ZXIiLCJsZXhlciIsIiQiLCJvcGVyYXRvciIsImxlZnQiLCJyaWdodCIsInByZWZpeCIsInBhcnNlRmxvYXQiLCJmYWxsYmFjayIsInVuaXQiLCJleGVjIiwicHJldiIsImRlZmF1bHRBY3Rpb25zIiwicGFyc2VFcnJvciIsInN0ciIsIkV4Y2VwdGlvbkNsYXNzIiwicmVjb3ZlcmFibGUiLCJkZXN0cm95IiwicGFyc2UiLCJpbnB1dCIsInNlbGYiLCJBcnJheSIsInNzdGFjayIsInZzdGFjayIsInNwIiwiRVJST1JfUkVDT1ZFUllfVE9LRU5fRElTQ0FSRF9DT1VOVCIsIk5PX0FDVElPTiIsIl9fbGV4ZXJfXyIsInNoYXJlZFN0YXRlX3l5IiwidW5kZWZpbmVkIiwicHJlX3BhcnNlIiwicG9zdF9wYXJzZSIsInByZV9sZXgiLCJwb3N0X2xleCIsIkFTU0VSVCIsImFzc2VydCIsIkppc29uQXNzZXJ0IiwiY29uZCIsInl5R2V0U2hhcmVkU3RhdGUiLCJzaGFsbG93X2NvcHlfbm9jbG9iYmVyIiwiZHN0Iiwic3JjIiwiayIsImNhbGwiLCJwYXJzZUVycm9yQWx0IiwicXVvdGVOYW1lQWx0IiwicGFyc2VyX2NsZWFudXBBZnRlclBhcnNlIiwicmVzdWx0VmFsdWUiLCJpbnZva2VfcG9zdF9tZXRob2RzIiwiZG9fbm90X251a2VfZXJyb3JpbmZvcyIsImNsZWFudXBBZnRlckxleCIsImVsIiwicGFyc2VyX2NvbnN0cnVjdFBhcnNlRXJyb3JJbmZvIiwiZXgiLCJleHBlY3RlZCIsInBlaSIsImVyclN0ciIsInRleHQiLCJtYXRjaCIsInl5dGV4dCIsInRva2VuIiwidG9rZW5faWQiLCJsaW5lIiwieXlsaW5lbm8iLCJhY3Rpb24iLCJuZXdfc3RhdGUiLCJuZXdTdGF0ZSIsInN5bWJvbF9zdGFjayIsInN0YXRlX3N0YWNrIiwidmFsdWVfc3RhY2siLCJzdGFja19wb2ludGVyIiwiZGVzdHJ1Y3RQYXJzZUVycm9ySW5mbyIsInJlYyIsImdldE5vblRlcm1pbmFsRnJvbUNvZGUiLCJ0b2tlbk5hbWUiLCJzdGRMZXgiLCJsZXgiLCJmYXN0TGV4IiwieXl2YWwiLCJfJCIsInl5cnVsZWxlbiIsInRoaXNfcHJvZHVjdGlvbiIsInJldHZhbCIsInNldElucHV0IiwiY2FuSVVzZSIsImxleGVySW5mbyIsImVyclN5bWJvbERlc2NyIiwic2hvd1Bvc2l0aW9uIiwiam9pbiIsIm50c3ltYm9sIiwiSmlzb25MZXhlckVycm9yIiwiRVJST1IiLCJfX2N1cnJlbnRSdWxlU2V0X18iLCJfX2RlY29tcHJlc3NlZCIsImRvbmUiLCJfYmFja3RyYWNrIiwiX2lucHV0IiwiX21vcmUiLCJfc2lnbmFsZWRfZXJyb3JfdG9rZW4iLCJjb25kaXRpb25TdGFjayIsIm1hdGNoZWQiLCJtYXRjaGVzIiwib2Zmc2V0IiwieXlsZW5nIiwieXlsbG9jIiwiY29uc3RydWN0TGV4RXJyb3JJbmZvIiwibGV4ZXJfY29uc3RydWN0TGV4RXJyb3JJbmZvIiwic2hvd19pbnB1dF9wb3NpdGlvbiIsImluZGV4T2YiLCJwcmV0dHlQcmludFJhbmdlIiwicHJldHR5X3NyYyIsInRlc3QiLCJwb3Nfc3RyIiwibG9jIiwiZGVzdHJ1Y3RMZXhFcnJvckluZm8iLCJsZXhlcl9wYXJzZUVycm9yIiwieXllcnJvciIsInl5RXJyb3IiLCJsaW5lbm9fbXNnIiwibGV4ZXJFcnJvcnNBcmVSZWNvdmVyYWJsZSIsImFyZ3MiLCJzbGljZSIsImFyZ3VtZW50cyIsImV4dHJhX2Vycm9yX2F0dHJpYnV0ZXMiLCJsZXhlcl9jbGVhbnVwQWZ0ZXJMZXgiLCJjbGVhciIsImxleGVyX2NsZWFyIiwiY29sIiwibGFzdF9jb2x1bW4iLCJmaXJzdF9saW5lIiwiZmlyc3RfY29sdW1uIiwibGFzdF9saW5lIiwicmFuZ2UiLCJsZXhlcl9zZXRJbnB1dCIsInJ1bGVzIiwicnVsZV9yZSIsImNvbmRpdGlvbnMiLCJzcGVjIiwicnVsZV9pZHMiLCJydWxlX3JlZ2V4ZXMiLCJydWxlX25ld19pZHMiLCJfX3J1bGVfcmVnZXhlcyIsIl9fcnVsZV9jb3VudCIsImVkaXRSZW1haW5pbmdJbnB1dCIsImxleGVyX2VkaXRSZW1haW5pbmdJbnB1dCIsImNhbGxiYWNrIiwiY3BzQXJnIiwibGV4ZXJfaW5wdXQiLCJjaCIsInNsaWNlX2xlbiIsImxpbmVzIiwiY2gyIiwidW5wdXQiLCJsZXhlcl91bnB1dCIsInNwbGl0Iiwic3Vic3RyIiwicHJlIiwicHJlX2xpbmVzIiwibW9yZSIsImxleGVyX21vcmUiLCJyZWplY3QiLCJsZXhlcl9yZWplY3QiLCJiYWNrdHJhY2tfbGV4ZXIiLCJsZXNzIiwibGV4ZXJfbGVzcyIsInBhc3RJbnB1dCIsImxleGVyX3Bhc3RJbnB1dCIsIm1heFNpemUiLCJtYXhMaW5lcyIsInBhc3QiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwidXBjb21pbmdJbnB1dCIsImxleGVyX3VwY29taW5nSW5wdXQiLCJuZXh0IiwibGV4ZXJfc2hvd1Bvc2l0aW9uIiwibWF4UHJlZml4IiwibWF4UG9zdGZpeCIsImRlcml2ZUxvY2F0aW9uSW5mbyIsImxleGVyX2Rlcml2ZVlZTExPQyIsImFjdHVhbCIsInByZWNlZGluZyIsImZvbGxvd2luZyIsImN1cnJlbnQiLCJsZXhlcl9wcmV0dHlQcmludFJhbmdlIiwiY29udGV4dF9sb2MiLCJjb250ZXh0X2xvYzIiLCJDT05URVhUIiwiQ09OVEVYVF9UQUlMIiwiTUlOSU1VTV9WSVNJQkxFX05PTkVNUFRZX0xJTkVfQ09VTlQiLCJsMCIsIk1hdGgiLCJtYXgiLCJsMSIsImxpbmVub19kaXNwbGF5X3dpZHRoIiwibG9nMTAiLCJ3c19wcmVmaXgiLCJub25lbXB0eV9saW5lX2luZGV4ZXMiLCJtYXAiLCJpbmplY3RMaW5lTnVtYmVyIiwiaW5kZXgiLCJsbm8iLCJsbm9fcGZ4IiwiZXJycGZ4IiwibGVhZCIsIm1hcmsiLCJ0cmltIiwiY2xpcF9zdGFydCIsImNsaXBfZW5kIiwiaW50ZXJtZWRpYXRlX2xpbmUiLCJzcGxpY2UiLCJkZXNjcmliZVlZTExPQyIsImxleGVyX2Rlc2NyaWJlX3l5bGxvYyIsImRpc3BsYXlfcmFuZ2VfdG9vIiwibDIiLCJjMSIsImMyIiwiZGwiLCJkYyIsInIxIiwicjIiLCJ0ZXN0X21hdGNoIiwibGV4ZXJfdGVzdF9tYXRjaCIsImluZGV4ZWRfcnVsZSIsImJhY2t1cCIsIm1hdGNoX3N0ciIsIm1hdGNoX3N0cl9sZW4iLCJsZXhlcl9uZXh0IiwidGVtcE1hdGNoIiwiX2N1cnJlbnRSdWxlcyIsInRyYWNrUG9zaXRpb24iLCJ0b3BTdGF0ZSIsInJlZ2V4ZXMiLCJmbGV4IiwicGVuZGluZ0lucHV0IiwiYWN0aXZlQ29uZGl0aW9uIiwiY29uZGl0aW9uU3RhY2tEZXB0aCIsImxleGVyX2xleCIsImxleGVyX2Zhc3RMZXgiLCJsZXhlcl9jYW5JVXNlIiwiYmVnaW4iLCJsZXhlcl9iZWdpbiIsImNvbmRpdGlvbiIsInB1c2hTdGF0ZSIsImxleGVyX3B1c2hTdGF0ZSIsInBvcFN0YXRlIiwibGV4ZXJfcG9wU3RhdGUiLCJsZXhlcl90b3BTdGF0ZSIsImFicyIsImxleGVyX19jdXJyZW50UnVsZXMiLCJzdGF0ZVN0YWNrU2l6ZSIsImxleGVyX3N0YXRlU3RhY2tTaXplIiwibGV4ZXJfX3BlcmZvcm1BY3Rpb24iLCJ5eXJ1bGVudW1iZXIiLCJZWV9TVEFSVCIsInl5XyIsIllZU1RBVEUiLCJzaW1wbGVDYXNlQWN0aW9uQ2x1c3RlcnMiLCJpbmNsdXNpdmUiLCJQYXJzZXIiLCJyZXF1aXJlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/reduce-css-calc@2.1.8/node_modules/reduce-css-calc/dist/parser.js\n");

/***/ })

};
;